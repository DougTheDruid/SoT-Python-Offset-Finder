// Name: SoT, Version: 2.4.0

#include "../pch.h"

/*!!DEFINE!!*/

/*!!HELPER_DEF!!*/

/*!!HELPER_INC!!*/

#ifdef _MSC_VER
	#pragma pack(push, 0x01)
#endif

namespace CG
{
//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------

void FTickFunction::AfterRead()
{
}

void FTickFunction::BeforeDelete()
{
}

void FActorComponentTickFunction::AfterRead()
{
	FTickFunction::AfterRead();

}

void FActorComponentTickFunction::BeforeDelete()
{
	FTickFunction::BeforeDelete();

}

void FBlueprintInputDelegateBinding::AfterRead()
{
}

void FBlueprintInputDelegateBinding::BeforeDelete()
{
}

void FBlueprintInputTouchDelegateBinding::AfterRead()
{
	FBlueprintInputDelegateBinding::AfterRead();

}

void FBlueprintInputTouchDelegateBinding::BeforeDelete()
{
	FBlueprintInputDelegateBinding::BeforeDelete();

}

void FOrbitOptions::AfterRead()
{
}

void FOrbitOptions::BeforeDelete()
{
}

void FExposedValueCopyRecord::AfterRead()
{
	READ_PTR_FULL(SourceProperty, UProperty);
	READ_PTR_FULL(DestProperty, UProperty);
	READ_PTR_FULL(CachedBoolSourceProperty, UBoolProperty);
	READ_PTR_FULL(CachedBoolDestProperty, UBoolProperty);
}

void FExposedValueCopyRecord::BeforeDelete()
{
	DELE_PTR_FULL(SourceProperty);
	DELE_PTR_FULL(DestProperty);
	DELE_PTR_FULL(CachedBoolSourceProperty);
	DELE_PTR_FULL(CachedBoolDestProperty);
}

void FExposedValueHandler::AfterRead()
{
}

void FExposedValueHandler::BeforeDelete()
{
}

void FAnimNode_Base::AfterRead()
{
}

void FAnimNode_Base::BeforeDelete()
{
}

void FInputScaleBias::AfterRead()
{
}

void FInputScaleBias::BeforeDelete()
{
}

void FPoseLinkBase::AfterRead()
{
}

void FPoseLinkBase::BeforeDelete()
{
}

void FComponentSpacePoseLink::AfterRead()
{
	FPoseLinkBase::AfterRead();

}

void FComponentSpacePoseLink::BeforeDelete()
{
	FPoseLinkBase::BeforeDelete();

}

void FIntegralKey::AfterRead()
{
}

void FIntegralKey::BeforeDelete()
{
}

void FKeyHandleMap::AfterRead()
{
}

void FKeyHandleMap::BeforeDelete()
{
}

void FIndexedCurve::AfterRead()
{
}

void FIndexedCurve::BeforeDelete()
{
}

void FIntegralCurve::AfterRead()
{
	FIndexedCurve::AfterRead();

}

void FIntegralCurve::BeforeDelete()
{
	FIndexedCurve::BeforeDelete();

}

void FStringCurveKey::AfterRead()
{
}

void FStringCurveKey::BeforeDelete()
{
}

void FSimpleMemberReference::AfterRead()
{
	READ_PTR_FULL(MemberParent, UObject);
}

void FSimpleMemberReference::BeforeDelete()
{
	DELE_PTR_FULL(MemberParent);
}

void FActorTickFunction::AfterRead()
{
	FTickFunction::AfterRead();

}

void FActorTickFunction::BeforeDelete()
{
	FTickFunction::BeforeDelete();

}

void FVector_NetQuantize100::AfterRead()
{
	FVector::AfterRead();

}

void FVector_NetQuantize100::BeforeDelete()
{
	FVector::BeforeDelete();

}

void FActorPtr::AfterRead()
{
	READ_PTR_FULL(Actor, AActor);
}

void FActorPtr::BeforeDelete()
{
	DELE_PTR_FULL(Actor);
}

void FVector_NetQuantize::AfterRead()
{
	FVector::AfterRead();

}

void FVector_NetQuantize::BeforeDelete()
{
	FVector::BeforeDelete();

}

void FVector_NetQuantizeNormal::AfterRead()
{
	FVector::AfterRead();

}

void FVector_NetQuantizeNormal::BeforeDelete()
{
	FVector::BeforeDelete();

}

void FHitResult::AfterRead()
{
}

void FHitResult::BeforeDelete()
{
}

void FVector_NetQuantize10::AfterRead()
{
	FVector::AfterRead();

}

void FVector_NetQuantize10::BeforeDelete()
{
	FVector::BeforeDelete();

}

void FRepRootMotionMontage::AfterRead()
{
	READ_PTR_FULL(AnimMontage, UAnimMontage);
	READ_PTR_FULL(MovementBase, UPrimitiveComponent);
}

void FRepRootMotionMontage::BeforeDelete()
{
	DELE_PTR_FULL(AnimMontage);
	DELE_PTR_FULL(MovementBase);
}

void FSimulatedRootMotionReplicatedMove::AfterRead()
{
}

void FSimulatedRootMotionReplicatedMove::BeforeDelete()
{
}

void FRootMotionMovementParams::AfterRead()
{
}

void FRootMotionMovementParams::BeforeDelete()
{
}

void FBasedMovementInfo::AfterRead()
{
	READ_PTR_FULL(MovementBase, UPrimitiveComponent);
}

void FBasedMovementInfo::BeforeDelete()
{
	DELE_PTR_FULL(MovementBase);
}

void FAnimTickRecord::AfterRead()
{
	READ_PTR_FULL(SourceAsset, UAnimationAsset);
}

void FAnimTickRecord::BeforeDelete()
{
	DELE_PTR_FULL(SourceAsset);
}

void FAnimGroupInstance::AfterRead()
{
}

void FAnimGroupInstance::BeforeDelete()
{
}

void FActiveVertexAnim::AfterRead()
{
	READ_PTR_FULL(VertAnim, UVertexAnimBase);
}

void FActiveVertexAnim::BeforeDelete()
{
	DELE_PTR_FULL(VertAnim);
}

void FAnimLinkableElement::AfterRead()
{
	READ_PTR_FULL(LinkedMontage, UAnimMontage);
	READ_PTR_FULL(LinkedSequence, UAnimSequenceBase);
}

void FAnimLinkableElement::BeforeDelete()
{
	DELE_PTR_FULL(LinkedMontage);
	DELE_PTR_FULL(LinkedSequence);
}

void FAnimNotifyEvent::AfterRead()
{
	FAnimLinkableElement::AfterRead();

	READ_PTR_FULL(Notify, UAnimNotify);
	READ_PTR_FULL(NotifyStateClass, UAnimNotifyState);
	READ_PTR_FULL(NotifyCondition, UAnimNotifyCondition);
}

void FAnimNotifyEvent::BeforeDelete()
{
	FAnimLinkableElement::BeforeDelete();

	DELE_PTR_FULL(Notify);
	DELE_PTR_FULL(NotifyStateClass);
	DELE_PTR_FULL(NotifyCondition);
}

void FPlayerAmbientLightOverrideSettings::AfterRead()
{
}

void FPlayerAmbientLightOverrideSettings::BeforeDelete()
{
}

void FWeightedBlendable::AfterRead()
{
	READ_PTR_FULL(Object, UObject);
}

void FWeightedBlendable::BeforeDelete()
{
	DELE_PTR_FULL(Object);
}

void FRainPostProcessSettings::AfterRead()
{
	READ_PTR_FULL(RainParticleTexture, UTexture);
	READ_PTR_FULL(RainMeshTexture, UTexture);
	READ_PTR_FULL(RainSplashData, UParticleComputeShaderData);
	READ_PTR_FULL(RainSplashData2, UParticleComputeShaderData);
}

void FRainPostProcessSettings::BeforeDelete()
{
	DELE_PTR_FULL(RainParticleTexture);
	DELE_PTR_FULL(RainMeshTexture);
	DELE_PTR_FULL(RainSplashData);
	DELE_PTR_FULL(RainSplashData2);
}

void FLPVCascadeSettings::AfterRead()
{
}

void FLPVCascadeSettings::BeforeDelete()
{
}

void FWeightedBlendables::AfterRead()
{
}

void FWeightedBlendables::BeforeDelete()
{
}

void FPostProcessSettings::AfterRead()
{
	READ_PTR_FULL(BloomDirtMask, UTexture);
	READ_PTR_FULL(AmbientCubemap, UTextureCube);
	READ_PTR_FULL(LensFlareBokehShape, UTexture);
	READ_PTR_FULL(ColorGradingLUT, UTexture);
	READ_PTR_FULL(DepthOfFieldBokehShape, UTexture);
}

void FPostProcessSettings::BeforeDelete()
{
	DELE_PTR_FULL(BloomDirtMask);
	DELE_PTR_FULL(AmbientCubemap);
	DELE_PTR_FULL(LensFlareBokehShape);
	DELE_PTR_FULL(ColorGradingLUT);
	DELE_PTR_FULL(DepthOfFieldBokehShape);
}

void FMinimalViewInfo::AfterRead()
{
}

void FMinimalViewInfo::BeforeDelete()
{
}

void FFOscillator::AfterRead()
{
}

void FFOscillator::BeforeDelete()
{
}

void FROscillator::AfterRead()
{
}

void FROscillator::BeforeDelete()
{
}

void FCollectionParameterBase::AfterRead()
{
}

void FCollectionParameterBase::BeforeDelete()
{
}

void FCollectionScalarParameter::AfterRead()
{
	FCollectionParameterBase::AfterRead();

}

void FCollectionScalarParameter::BeforeDelete()
{
	FCollectionParameterBase::BeforeDelete();

}

void FPoseLink::AfterRead()
{
	FPoseLinkBase::AfterRead();

}

void FPoseLink::BeforeDelete()
{
	FPoseLinkBase::BeforeDelete();

}

void FAnimNode_ApplyAdditive::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_ApplyAdditive::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAnimNode_AssetPlayerBase::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_AssetPlayerBase::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAlphaBlend::AfterRead()
{
	READ_PTR_FULL(CustomCurve, UCurveFloat);
}

void FAlphaBlend::BeforeDelete()
{
	DELE_PTR_FULL(CustomCurve);
}

void FAnimNode_BlendListBase::AfterRead()
{
	FAnimNode_Base::AfterRead();

	READ_PTR_FULL(CustomBlendCurve, UCurveFloat);
}

void FAnimNode_BlendListBase::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

	DELE_PTR_FULL(CustomBlendCurve);
}

void FAnimNode_BlendListByBool::AfterRead()
{
	FAnimNode_BlendListBase::AfterRead();

}

void FAnimNode_BlendListByBool::BeforeDelete()
{
	FAnimNode_BlendListBase::BeforeDelete();

}

void FAnimNode_BlendListByEnum::AfterRead()
{
	FAnimNode_BlendListBase::AfterRead();

}

void FAnimNode_BlendListByEnum::BeforeDelete()
{
	FAnimNode_BlendListBase::BeforeDelete();

}

void FAnimNode_BlendListByInt::AfterRead()
{
	FAnimNode_BlendListBase::AfterRead();

}

void FAnimNode_BlendListByInt::BeforeDelete()
{
	FAnimNode_BlendListBase::BeforeDelete();

}

void FAnimNode_BlendListByObject::AfterRead()
{
	FAnimNode_BlendListBase::AfterRead();

	READ_PTR_FULL(ActiveTypeValue, UClass);
}

void FAnimNode_BlendListByObject::BeforeDelete()
{
	FAnimNode_BlendListBase::BeforeDelete();

	DELE_PTR_FULL(ActiveTypeValue);
}

void FRepAttachment::AfterRead()
{
	READ_PTR_FULL(AttachParent, AActor);
	READ_PTR_FULL(AttachComponent, USceneComponent);
}

void FRepAttachment::BeforeDelete()
{
	DELE_PTR_FULL(AttachParent);
	DELE_PTR_FULL(AttachComponent);
}

void FPrimitiveSphereEmitterAngleRanges::AfterRead()
{
}

void FPrimitiveSphereEmitterAngleRanges::BeforeDelete()
{
}

void FRepMovement::AfterRead()
{
}

void FRepMovement::BeforeDelete()
{
}

void FCollisionResponseContainer::AfterRead()
{
}

void FCollisionResponseContainer::BeforeDelete()
{
}

void FResponseChannel::AfterRead()
{
}

void FResponseChannel::BeforeDelete()
{
}

void FCollisionResponse::AfterRead()
{
}

void FCollisionResponse::BeforeDelete()
{
}

void FFuncStatEntry::AfterRead()
{
}

void FFuncStatEntry::BeforeDelete()
{
}

void FSpikeStatEntry::AfterRead()
{
}

void FSpikeStatEntry::BeforeDelete()
{
}

void FRPCStatEntry::AfterRead()
{
}

void FRPCStatEntry::BeforeDelete()
{
}

void FRPCStats::AfterRead()
{
}

void FRPCStats::BeforeDelete()
{
}

void FFuncStatHolder::AfterRead()
{
}

void FFuncStatHolder::BeforeDelete()
{
}

void FAutoCompleteNode::AfterRead()
{
}

void FAutoCompleteNode::BeforeDelete()
{
}

void FRichCurveKey::AfterRead()
{
}

void FRichCurveKey::BeforeDelete()
{
}

void FRichCurve::AfterRead()
{
	FIndexedCurve::AfterRead();

}

void FRichCurve::BeforeDelete()
{
	FIndexedCurve::BeforeDelete();

}

void FRuntimeCurveLinearColor::AfterRead()
{
	READ_PTR_FULL(ExternalCurve, UCurveLinearColor);
}

void FRuntimeCurveLinearColor::BeforeDelete()
{
	DELE_PTR_FULL(ExternalCurve);
}

void FCurveTableRowHandle::AfterRead()
{
	READ_PTR_FULL(CurveTable, UCurveTable);
}

void FCurveTableRowHandle::BeforeDelete()
{
	DELE_PTR_FULL(CurveTable);
}

void FGraphReference::AfterRead()
{
	READ_PTR_FULL(MacroGraph, UEdGraph);
	READ_PTR_FULL(GraphBlueprint, UBlueprint);
}

void FGraphReference::BeforeDelete()
{
	DELE_PTR_FULL(MacroGraph);
	DELE_PTR_FULL(GraphBlueprint);
}

void FEdGraphSchemaAction::AfterRead()
{
}

void FEdGraphSchemaAction::BeforeDelete()
{
}

void FEdGraphSchemaAction_NewNode::AfterRead()
{
	FEdGraphSchemaAction::AfterRead();

	READ_PTR_FULL(NodeTemplate, UEdGraphNode);
}

void FEdGraphSchemaAction_NewNode::BeforeDelete()
{
	FEdGraphSchemaAction::BeforeDelete();

	DELE_PTR_FULL(NodeTemplate);
}

void FScreenMessageString::AfterRead()
{
}

void FScreenMessageString::BeforeDelete()
{
}

void FFullyLoadedPackagesInfo::AfterRead()
{
}

void FFullyLoadedPackagesInfo::BeforeDelete()
{
}

void FLevelStreamingStatus::AfterRead()
{
}

void FLevelStreamingStatus::BeforeDelete()
{
}

void FNamedNetDriver::AfterRead()
{
	READ_PTR_FULL(NetDriver, UNetDriver);
}

void FNamedNetDriver::BeforeDelete()
{
	DELE_PTR_FULL(NetDriver);
}

void FURL::AfterRead()
{
}

void FURL::BeforeDelete()
{
}

void FWorldContext::AfterRead()
{
	READ_PTR_FULL(PendingNetGame, UPendingNetGame);
	READ_PTR_FULL(GameViewport, UGameViewportClient);
	READ_PTR_FULL(OwningGameInstance, UGameInstance);
}

void FWorldContext::BeforeDelete()
{
	DELE_PTR_FULL(PendingNetGame);
	DELE_PTR_FULL(GameViewport);
	DELE_PTR_FULL(OwningGameInstance);
}

void FActiveHapticFeedbackEffect::AfterRead()
{
	READ_PTR_FULL(HapticEffect, UHapticFeedbackEffect);
}

void FActiveHapticFeedbackEffect::BeforeDelete()
{
	DELE_PTR_FULL(HapticEffect);
}

void FAnimNode_HIKBase::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_HIKBase::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FHIKElements::AfterRead()
{
}

void FHIKElements::BeforeDelete()
{
}

void FInterpEdSelKey::AfterRead()
{
	READ_PTR_FULL(Group, UInterpGroup);
	READ_PTR_FULL(Track, UInterpTrack);
}

void FInterpEdSelKey::BeforeDelete()
{
	DELE_PTR_FULL(Group);
	DELE_PTR_FULL(Track);
}

void FCameraPreviewInfo::AfterRead()
{
	READ_PTR_FULL(PawnClass, UClass);
	READ_PTR_FULL(AnimSeq, UAnimSequence);
	READ_PTR_FULL(PawnInst, APawn);
}

void FCameraPreviewInfo::BeforeDelete()
{
	DELE_PTR_FULL(PawnClass);
	DELE_PTR_FULL(AnimSeq);
	DELE_PTR_FULL(PawnInst);
}

void FSubTrackGroup::AfterRead()
{
}

void FSubTrackGroup::BeforeDelete()
{
}

void FSupportedSubTrackInfo::AfterRead()
{
	READ_PTR_FULL(SupportedClass, UClass);
}

void FSupportedSubTrackInfo::BeforeDelete()
{
	DELE_PTR_FULL(SupportedClass);
}

void FClientReceiveData::AfterRead()
{
	READ_PTR_FULL(LocalPC, APlayerController);
	READ_PTR_FULL(RelatedPlayerState_2, APlayerState);
	READ_PTR_FULL(RelatedPlayerState_3, APlayerState);
	READ_PTR_FULL(OptionalObject, UObject);
}

void FClientReceiveData::BeforeDelete()
{
	DELE_PTR_FULL(LocalPC);
	DELE_PTR_FULL(RelatedPlayerState_2);
	DELE_PTR_FULL(RelatedPlayerState_3);
	DELE_PTR_FULL(OptionalObject);
}

void FParticleCurvePair::AfterRead()
{
	READ_PTR_FULL(CurveObject, UObject);
}

void FParticleCurvePair::BeforeDelete()
{
	DELE_PTR_FULL(CurveObject);
}

void FBeamTargetData::AfterRead()
{
}

void FBeamTargetData::BeforeDelete()
{
}

void FParticleSystemReplayFrame::AfterRead()
{
}

void FParticleSystemReplayFrame::BeforeDelete()
{
}

void FParticleEmitterReplayFrame::AfterRead()
{
}

void FParticleEmitterReplayFrame::BeforeDelete()
{
}

void FSoundNodeEditorData::AfterRead()
{
}

void FSoundNodeEditorData::BeforeDelete()
{
}

void FStreamedAudioPlatformData::AfterRead()
{
}

void FStreamedAudioPlatformData::BeforeDelete()
{
}

void FSoundClassEditorData::AfterRead()
{
}

void FSoundClassEditorData::BeforeDelete()
{
}

void FAnimationRecordingSettings::AfterRead()
{
}

void FAnimationRecordingSettings::BeforeDelete()
{
}

void FScalarParameterValue::AfterRead()
{
}

void FScalarParameterValue::BeforeDelete()
{
}

void FTextureParameterValue::AfterRead()
{
	READ_PTR_FULL(ParameterValue, UTexture);
}

void FTextureParameterValue::BeforeDelete()
{
	DELE_PTR_FULL(ParameterValue);
}

void FMovementProperties::AfterRead()
{
}

void FMovementProperties::BeforeDelete()
{
}

void FNavAgentProperties::AfterRead()
{
	FMovementProperties::AfterRead();

}

void FNavAgentProperties::BeforeDelete()
{
	FMovementProperties::BeforeDelete();

}

void FNavAvoidanceMask::AfterRead()
{
}

void FNavAvoidanceMask::BeforeDelete()
{
}

void FCharacterMovementComponentPreClothTickFunction::AfterRead()
{
	FTickFunction::AfterRead();

}

void FCharacterMovementComponentPreClothTickFunction::BeforeDelete()
{
	FTickFunction::BeforeDelete();

}

void FGameNameRedirect::AfterRead()
{
}

void FGameNameRedirect::BeforeDelete()
{
}

void FClassRedirect::AfterRead()
{
}

void FClassRedirect::BeforeDelete()
{
}

void FPluginRedirect::AfterRead()
{
}

void FPluginRedirect::BeforeDelete()
{
}

void FStructRedirect::AfterRead()
{
}

void FStructRedirect::BeforeDelete()
{
}

void FRigidBodyErrorCorrection::AfterRead()
{
}

void FRigidBodyErrorCorrection::BeforeDelete()
{
}

void FNetDriverDefinition::AfterRead()
{
}

void FNetDriverDefinition::BeforeDelete()
{
}

void FGameClassShortName::AfterRead()
{
}

void FGameClassShortName::BeforeDelete()
{
}

void FCustomPrimitiveData::AfterRead()
{
}

void FCustomPrimitiveData::BeforeDelete()
{
}

void FWalkableSlopeOverride::AfterRead()
{
}

void FWalkableSlopeOverride::BeforeDelete()
{
}

void FMassPropertiesOverride::AfterRead()
{
}

void FMassPropertiesOverride::BeforeDelete()
{
}

void FBodyInstance::AfterRead()
{
	READ_PTR_FULL(PhysMaterialOverride, UPhysicalMaterial);
}

void FBodyInstance::BeforeDelete()
{
	DELE_PTR_FULL(PhysMaterialOverride);
}

void FPrimitiveComponentPostPhysicsTickFunction::AfterRead()
{
	FTickFunction::AfterRead();

}

void FPrimitiveComponentPostPhysicsTickFunction::BeforeDelete()
{
	FTickFunction::BeforeDelete();

}

void FOverlapInfo::AfterRead()
{
}

void FOverlapInfo::BeforeDelete()
{
}

void FDebugDisplayProperty::AfterRead()
{
	READ_PTR_FULL(Obj, UObject);
	READ_PTR_FULL(WithinClass, UClass);
}

void FDebugDisplayProperty::BeforeDelete()
{
	DELE_PTR_FULL(Obj);
	DELE_PTR_FULL(WithinClass);
}

void FUniqueNetIdRepl::AfterRead()
{
}

void FUniqueNetIdRepl::BeforeDelete()
{
}

void FActiveForceFeedbackEffect::AfterRead()
{
	READ_PTR_FULL(ForceFeedbackEffect, UForceFeedbackEffect);
}

void FActiveForceFeedbackEffect::BeforeDelete()
{
	DELE_PTR_FULL(ForceFeedbackEffect);
}

void FViewTargetTransitionParams::AfterRead()
{
}

void FViewTargetTransitionParams::BeforeDelete()
{
}

void FLatentActionInfo::AfterRead()
{
	READ_PTR_FULL(CallbackTarget, UObject);
}

void FLatentActionInfo::BeforeDelete()
{
	DELE_PTR_FULL(CallbackTarget);
}

void FLevelStreamingStatusUpdateInfo::AfterRead()
{
}

void FLevelStreamingStatusUpdateInfo::BeforeDelete()
{
}

void FGeomSelection::AfterRead()
{
}

void FGeomSelection::BeforeDelete()
{
}

void FGameModePrefix::AfterRead()
{
}

void FGameModePrefix::BeforeDelete()
{
}

void FLightmassWorldInfoSettings::AfterRead()
{
}

void FLightmassWorldInfoSettings::BeforeDelete()
{
}

void FReverbSettings::AfterRead()
{
	READ_PTR_FULL(ReverbEffect, UReverbEffect);
}

void FReverbSettings::BeforeDelete()
{
	DELE_PTR_FULL(ReverbEffect);
}

void FInteriorSettings::AfterRead()
{
}

void FInteriorSettings::BeforeDelete()
{
}

void FExternalMip::AfterRead()
{
}

void FExternalMip::BeforeDelete()
{
}

void FFeatureToggledStringAssetReferenceEntry::AfterRead()
{
}

void FFeatureToggledStringAssetReferenceEntry::BeforeDelete()
{
}

void FAtmospherePrecomputeParameters::AfterRead()
{
}

void FAtmospherePrecomputeParameters::BeforeDelete()
{
}

void FRuntimeFloatCurve::AfterRead()
{
	READ_PTR_FULL(ExternalCurve, UCurveFloat);
}

void FRuntimeFloatCurve::BeforeDelete()
{
	DELE_PTR_FULL(ExternalCurve);
}

void FAttenuationSettings::AfterRead()
{
}

void FAttenuationSettings::BeforeDelete()
{
}

void FAudioComponentParam::AfterRead()
{
	READ_PTR_FULL(SoundWaveParam, USoundWave);
}

void FAudioComponentParam::BeforeDelete()
{
	DELE_PTR_FULL(SoundWaveParam);
}

void FLightmassLightSettings::AfterRead()
{
}

void FLightmassLightSettings::BeforeDelete()
{
}

void FLightmassDirectionalLightSettings::AfterRead()
{
	FLightmassLightSettings::AfterRead();

}

void FLightmassDirectionalLightSettings::BeforeDelete()
{
	FLightmassLightSettings::BeforeDelete();

}

void FLightmassPointLightSettings::AfterRead()
{
	FLightmassLightSettings::AfterRead();

}

void FLightmassPointLightSettings::BeforeDelete()
{
	FLightmassLightSettings::BeforeDelete();

}

void FNavGraphNode::AfterRead()
{
	READ_PTR_FULL(Owner, UObject);
}

void FNavGraphNode::BeforeDelete()
{
	DELE_PTR_FULL(Owner);
}

void FFFTWaterComponentWaveParticleType::AfterRead()
{
	READ_PTR_FULL(ParticleComputeShaderData, UParticleComputeShaderData);
}

void FFFTWaterComponentWaveParticleType::BeforeDelete()
{
	DELE_PTR_FULL(ParticleComputeShaderData);
}

void FFFTWaterComponentIntersectParticleType::AfterRead()
{
	READ_PTR_FULL(ParticleComputeShaderData, UParticleComputeShaderData);
}

void FFFTWaterComponentIntersectParticleType::BeforeDelete()
{
	DELE_PTR_FULL(ParticleComputeShaderData);
}

void FMurkyRegion::AfterRead()
{
}

void FMurkyRegion::BeforeDelete()
{
}

void FA2Pose::AfterRead()
{
}

void FA2Pose::BeforeDelete()
{
}

void FA2CSPose::AfterRead()
{
	FA2Pose::AfterRead();

}

void FA2CSPose::BeforeDelete()
{
	FA2Pose::BeforeDelete();

}

void FAnimMontageInstance::AfterRead()
{
	READ_PTR_FULL(Montage, UAnimMontage);
}

void FAnimMontageInstance::BeforeDelete()
{
	DELE_PTR_FULL(Montage);
}

void FFogVolumeInfo::AfterRead()
{
	READ_PTR_FULL(Component, UFogVolumeComponent);
	READ_PTR_FULL(VolumeTexture, UTexture);
	READ_PTR_FULL(MeshFogVolumeTexture, UTexture);
}

void FFogVolumeInfo::BeforeDelete()
{
	DELE_PTR_FULL(Component);
	DELE_PTR_FULL(VolumeTexture);
	DELE_PTR_FULL(MeshFogVolumeTexture);
}

void FWaterSimPlane::AfterRead()
{
	READ_PTR_FULL(WaterId, UClass);
	READ_PTR_FULL(WaterOwner, UObject);
}

void FWaterSimPlane::BeforeDelete()
{
	DELE_PTR_FULL(WaterId);
	DELE_PTR_FULL(WaterOwner);
}

void FAnimationNode_TwoWayBlend::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimationNode_TwoWayBlend::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FFindFloorResult::AfterRead()
{
}

void FFindFloorResult::BeforeDelete()
{
}

void FPaintedVertex::AfterRead()
{
}

void FPaintedVertex::BeforeDelete()
{
}

void FStaticMeshComponentLODInfo::AfterRead()
{
}

void FStaticMeshComponentLODInfo::BeforeDelete()
{
}

void FLightmassMaterialInterfaceSettings::AfterRead()
{
}

void FLightmassMaterialInterfaceSettings::BeforeDelete()
{
}

void FMaterialInput::AfterRead()
{
	READ_PTR_FULL(Expression, UMaterialExpression);
}

void FMaterialInput::BeforeDelete()
{
	DELE_PTR_FULL(Expression);
}

void FScalarMaterialInput::AfterRead()
{
	FMaterialInput::AfterRead();

}

void FScalarMaterialInput::BeforeDelete()
{
	FMaterialInput::BeforeDelete();

}

void FVectorMaterialInput::AfterRead()
{
	FMaterialInput::AfterRead();

}

void FVectorMaterialInput::BeforeDelete()
{
	FMaterialInput::BeforeDelete();

}

void FVector2MaterialInput::AfterRead()
{
	FMaterialInput::AfterRead();

}

void FVector2MaterialInput::BeforeDelete()
{
	FMaterialInput::BeforeDelete();

}

void FExpressionInput::AfterRead()
{
	READ_PTR_FULL(Expression, UMaterialExpression);
}

void FExpressionInput::BeforeDelete()
{
	DELE_PTR_FULL(Expression);
}

void FMaterialAttributesInput::AfterRead()
{
	FExpressionInput::AfterRead();

}

void FMaterialAttributesInput::BeforeDelete()
{
	FExpressionInput::BeforeDelete();

}

void FMaterialFunctionInfo::AfterRead()
{
	READ_PTR_FULL(Function, UMaterialFunction);
}

void FMaterialFunctionInfo::BeforeDelete()
{
	DELE_PTR_FULL(Function);
}

void FMaterialParameterCollectionInfo::AfterRead()
{
	READ_PTR_FULL(ParameterCollection, UMaterialParameterCollection);
}

void FMaterialParameterCollectionInfo::BeforeDelete()
{
	DELE_PTR_FULL(ParameterCollection);
}

void FMaterialRelevance::AfterRead()
{
}

void FMaterialRelevance::BeforeDelete()
{
}

void FInstancedStaticMeshMappingInfo::AfterRead()
{
}

void FInstancedStaticMeshMappingInfo::BeforeDelete()
{
}

void FMaterialInstanceBasePropertyOverrides::AfterRead()
{
}

void FMaterialInstanceBasePropertyOverrides::BeforeDelete()
{
}

void FExpressionOutput::AfterRead()
{
}

void FExpressionOutput::BeforeDelete()
{
}

void FEventGraphFastCallPair::AfterRead()
{
	READ_PTR_FULL(FunctionToPatch, UFunction);
}

void FEventGraphFastCallPair::BeforeDelete()
{
	DELE_PTR_FULL(FunctionToPatch);
}

void FStatColorMapEntry::AfterRead()
{
}

void FStatColorMapEntry::BeforeDelete()
{
}

void FStatColorMapping::AfterRead()
{
}

void FStatColorMapping::BeforeDelete()
{
}

void FBoneReference::AfterRead()
{
}

void FBoneReference::BeforeDelete()
{
}

void FSimplygonChannelCastingSettings::AfterRead()
{
}

void FSimplygonChannelCastingSettings::BeforeDelete()
{
}

void FSimplygonMaterialLODSettings::AfterRead()
{
}

void FSimplygonMaterialLODSettings::BeforeDelete()
{
}

void FSkeletalMeshOptimizationSettings::AfterRead()
{
}

void FSkeletalMeshOptimizationSettings::BeforeDelete()
{
}

void FDropNoteInfo::AfterRead()
{
}

void FDropNoteInfo::BeforeDelete()
{
}

void FBlendSample::AfterRead()
{
	READ_PTR_FULL(Animation, UAnimSequence);
}

void FBlendSample::BeforeDelete()
{
	DELE_PTR_FULL(Animation);
}

void FFilePath::AfterRead()
{
}

void FFilePath::BeforeDelete()
{
}

void FOpenTestAsset::AfterRead()
{
}

void FOpenTestAsset::BeforeDelete()
{
}

void FInterpLookupPoint::AfterRead()
{
}

void FInterpLookupPoint::BeforeDelete()
{
}

void FInterpLookupTrack::AfterRead()
{
}

void FInterpLookupTrack::BeforeDelete()
{
}

void FDistributionLookupTable::AfterRead()
{
}

void FDistributionLookupTable::BeforeDelete()
{
}

void FRawDistribution::AfterRead()
{
}

void FRawDistribution::BeforeDelete()
{
}

void FRawDistributionFloat::AfterRead()
{
	FRawDistribution::AfterRead();

	READ_PTR_FULL(Distribution, UDistributionFloat);
}

void FRawDistributionFloat::BeforeDelete()
{
	FRawDistribution::BeforeDelete();

	DELE_PTR_FULL(Distribution);
}

void FEmitterDynamicParameter::AfterRead()
{
}

void FEmitterDynamicParameter::BeforeDelete()
{
}

void FParticleBurst::AfterRead()
{
}

void FParticleBurst::BeforeDelete()
{
}

void FNavAgentSelector::AfterRead()
{
}

void FNavAgentSelector::BeforeDelete()
{
}

void FNavigationLinkBase::AfterRead()
{
	READ_PTR_FULL(AreaClass, UClass);
}

void FNavigationLinkBase::BeforeDelete()
{
	DELE_PTR_FULL(AreaClass);
}

void FNavigationSegmentLink::AfterRead()
{
	FNavigationLinkBase::AfterRead();

}

void FNavigationSegmentLink::BeforeDelete()
{
	FNavigationLinkBase::BeforeDelete();

}

void FParticleSystemLOD::AfterRead()
{
}

void FParticleSystemLOD::BeforeDelete()
{
}

void FLODSoloTrack::AfterRead()
{
}

void FLODSoloTrack::BeforeDelete()
{
}

void FNamedEmitterMaterial::AfterRead()
{
	READ_PTR_FULL(Material, UMaterialInterface);
}

void FNamedEmitterMaterial::BeforeDelete()
{
	DELE_PTR_FULL(Material);
}

void FSkeletalMaterial::AfterRead()
{
	READ_PTR_FULL(MaterialInterface, UMaterialInterface);
}

void FSkeletalMaterial::BeforeDelete()
{
	DELE_PTR_FULL(MaterialInterface);
}

void FBoneMirrorInfo::AfterRead()
{
}

void FBoneMirrorInfo::BeforeDelete()
{
}

void FTriangleSortSettings::AfterRead()
{
}

void FTriangleSortSettings::BeforeDelete()
{
}

void FDeformablesSettings::AfterRead()
{
}

void FDeformablesSettings::BeforeDelete()
{
}

void FClothPhysicsProperties::AfterRead()
{
}

void FClothPhysicsProperties::BeforeDelete()
{
}

void FSkelMeshComponentLODInfo::AfterRead()
{
}

void FSkelMeshComponentLODInfo::BeforeDelete()
{
}

void FConstrainComponentPropName::AfterRead()
{
}

void FConstrainComponentPropName::BeforeDelete()
{
}

void FConstraintInstance::AfterRead()
{
	READ_PTR_FULL(OwnerComponent, USceneComponent);
}

void FConstraintInstance::BeforeDelete()
{
	DELE_PTR_FULL(OwnerComponent);
}

void FBoneNode::AfterRead()
{
}

void FBoneNode::BeforeDelete()
{
}

void FSkeletonToMeshLinkup::AfterRead()
{
}

void FSkeletonToMeshLinkup::BeforeDelete()
{
}

void FSmartNameContainer::AfterRead()
{
}

void FSmartNameContainer::BeforeDelete()
{
}

void FAnimSlotGroup::AfterRead()
{
}

void FAnimSlotGroup::BeforeDelete()
{
}

void FSingleAnimationPlayData::AfterRead()
{
	READ_PTR_FULL(AnimToPlay, UAnimationAsset);
	READ_PTR_FULL(VertexAnimToPlay, UVertexAnimation);
}

void FSingleAnimationPlayData::BeforeDelete()
{
	DELE_PTR_FULL(AnimToPlay);
	DELE_PTR_FULL(VertexAnimToPlay);
}

void FInterpControlPoint::AfterRead()
{
}

void FInterpControlPoint::BeforeDelete()
{
}

void FAnimCurveBase::AfterRead()
{
}

void FAnimCurveBase::BeforeDelete()
{
}

void FFloatCurve::AfterRead()
{
	FAnimCurveBase::AfterRead();

}

void FFloatCurve::BeforeDelete()
{
	FAnimCurveBase::BeforeDelete();

}

void FRawCurveTracks::AfterRead()
{
}

void FRawCurveTracks::BeforeDelete()
{
}

void FCompositeSection::AfterRead()
{
	FAnimLinkableElement::AfterRead();

}

void FCompositeSection::BeforeDelete()
{
	FAnimLinkableElement::BeforeDelete();

}

void FAnimSegment::AfterRead()
{
	READ_PTR_FULL(AnimReference, UAnimSequenceBase);
}

void FAnimSegment::BeforeDelete()
{
	DELE_PTR_FULL(AnimReference);
}

void FAnimTrack::AfterRead()
{
}

void FAnimTrack::BeforeDelete()
{
}

void FBranchingPoint::AfterRead()
{
	FAnimLinkableElement::AfterRead();

}

void FBranchingPoint::BeforeDelete()
{
	FAnimLinkableElement::BeforeDelete();

}

void FBranchingPointMarker::AfterRead()
{
}

void FBranchingPointMarker::BeforeDelete()
{
}

void FBatchedPoint::AfterRead()
{
}

void FBatchedPoint::BeforeDelete()
{
}

void FBatchedLine::AfterRead()
{
}

void FBatchedLine::BeforeDelete()
{
}

void FAnimNode_RotateRootBone::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_RotateRootBone::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FNetViewer::AfterRead()
{
	READ_PTR_FULL(InViewer, AActor);
	READ_PTR_FULL(ViewTarget, AActor);
}

void FNetViewer::BeforeDelete()
{
	DELE_PTR_FULL(InViewer);
	DELE_PTR_FULL(ViewTarget);
}

void FEdGraphPinType::AfterRead()
{
}

void FEdGraphPinType::BeforeDelete()
{
}

void FReferencePose::AfterRead()
{
}

void FReferencePose::BeforeDelete()
{
}

void FDebugTextInfo::AfterRead()
{
	READ_PTR_FULL(SrcActor, AActor);
	READ_PTR_FULL(Font, UFont);
}

void FDebugTextInfo::BeforeDelete()
{
	DELE_PTR_FULL(SrcActor);
	DELE_PTR_FULL(Font);
}

void FCameraCacheEntry::AfterRead()
{
}

void FCameraCacheEntry::BeforeDelete()
{
}

void FComponentKey::AfterRead()
{
	READ_PTR_FULL(OwnerClass, UClass);
}

void FComponentKey::BeforeDelete()
{
	DELE_PTR_FULL(OwnerClass);
}

void FComponentOverrideRecord::AfterRead()
{
	READ_PTR_FULL(ComponentTemplate, UActorComponent);
}

void FComponentOverrideRecord::BeforeDelete()
{
	DELE_PTR_FULL(ComponentTemplate);
}

void FKeyBind::AfterRead()
{
}

void FKeyBind::BeforeDelete()
{
}

void FInputAxisProperties::AfterRead()
{
}

void FInputAxisProperties::BeforeDelete()
{
}

void FInputActionKeyMapping::AfterRead()
{
}

void FInputActionKeyMapping::BeforeDelete()
{
}

void FInputAxisKeyMapping::AfterRead()
{
}

void FInputAxisKeyMapping::BeforeDelete()
{
}

void FInputCombinedAxisKeyMapping::AfterRead()
{
}

void FInputCombinedAxisKeyMapping::BeforeDelete()
{
}

void FCurveEdEntry::AfterRead()
{
	READ_PTR_FULL(CurveObject, UObject);
}

void FCurveEdEntry::BeforeDelete()
{
	DELE_PTR_FULL(CurveObject);
}

void FCurveEdTab::AfterRead()
{
}

void FCurveEdTab::BeforeDelete()
{
}

void FBoolTrackKey::AfterRead()
{
}

void FBoolTrackKey::BeforeDelete()
{
}

void FDirectorTrackCut::AfterRead()
{
}

void FDirectorTrackCut::BeforeDelete()
{
}

void FEventTrackKey::AfterRead()
{
}

void FEventTrackKey::BeforeDelete()
{
}

void FAnimControlTrackKey::AfterRead()
{
	READ_PTR_FULL(AnimSeq, UAnimSequence);
}

void FAnimControlTrackKey::BeforeDelete()
{
	DELE_PTR_FULL(AnimSeq);
}

void FColorMaterialInput::AfterRead()
{
	FMaterialInput::AfterRead();

}

void FColorMaterialInput::BeforeDelete()
{
	FMaterialInput::BeforeDelete();

}

void FHapticFeedbackDetails::AfterRead()
{
}

void FHapticFeedbackDetails::BeforeDelete()
{
}

void FEmitterPointData::AfterRead()
{
}

void FEmitterPointData::BeforeDelete()
{
}

void FParticleSysParam::AfterRead()
{
	READ_PTR_FULL(Actor, AActor);
	READ_PTR_FULL(Material, UMaterialInterface);
}

void FParticleSysParam::BeforeDelete()
{
	DELE_PTR_FULL(Actor);
	DELE_PTR_FULL(Material);
}

void FBlueprintInputActionDelegateBinding::AfterRead()
{
	FBlueprintInputDelegateBinding::AfterRead();

}

void FBlueprintInputActionDelegateBinding::BeforeDelete()
{
	FBlueprintInputDelegateBinding::BeforeDelete();

}

void FBlueprintInputAxisDelegateBinding::AfterRead()
{
	FBlueprintInputDelegateBinding::AfterRead();

}

void FBlueprintInputAxisDelegateBinding::BeforeDelete()
{
	FBlueprintInputDelegateBinding::BeforeDelete();

}

void FBlueprintInputAxisKeyDelegateBinding::AfterRead()
{
	FBlueprintInputDelegateBinding::AfterRead();

}

void FBlueprintInputAxisKeyDelegateBinding::BeforeDelete()
{
	FBlueprintInputDelegateBinding::BeforeDelete();

}

void FBlueprintInputKeyDelegateBinding::AfterRead()
{
	FBlueprintInputDelegateBinding::AfterRead();

}

void FBlueprintInputKeyDelegateBinding::BeforeDelete()
{
	FBlueprintInputDelegateBinding::BeforeDelete();

}

void FInstancedStaticMeshInstanceData::AfterRead()
{
}

void FInstancedStaticMeshInstanceData::BeforeDelete()
{
}

void FParticleReplayTrackKey::AfterRead()
{
}

void FParticleReplayTrackKey::BeforeDelete()
{
}

void FNavCollisionBox::AfterRead()
{
}

void FNavCollisionBox::BeforeDelete()
{
}

void FBasedPosition::AfterRead()
{
	READ_PTR_FULL(Base, AActor);
}

void FBasedPosition::BeforeDelete()
{
	DELE_PTR_FULL(Base);
}

void FRigidBodyContactInfo::AfterRead()
{
	READ_PTR_FULL(PhysMaterial[0x2], UPhysicalMaterial);
}

void FRigidBodyContactInfo::BeforeDelete()
{
	DELE_PTR_FULL(PhysMaterial[0x2]);
}

void FCollisionImpactData::AfterRead()
{
}

void FCollisionImpactData::BeforeDelete()
{
}

void FRigidBodyState::AfterRead()
{
}

void FRigidBodyState::BeforeDelete()
{
}

void FEditedDocumentInfo::AfterRead()
{
	READ_PTR_FULL(EditedObject, UObject);
}

void FEditedDocumentInfo::BeforeDelete()
{
	DELE_PTR_FULL(EditedObject);
}

void FBPInterfaceDescription::AfterRead()
{
	READ_PTR_FULL(Interface, UClass);
}

void FBPInterfaceDescription::BeforeDelete()
{
	DELE_PTR_FULL(Interface);
}

void FBPVariableMetaDataEntry::AfterRead()
{
}

void FBPVariableMetaDataEntry::BeforeDelete()
{
}

void FBPVariableDescription::AfterRead()
{
}

void FBPVariableDescription::BeforeDelete()
{
}

void FMemberReference::AfterRead()
{
	READ_PTR_FULL(MemberParent, UObject);
}

void FMemberReference::BeforeDelete()
{
	DELE_PTR_FULL(MemberParent);
}

void FLatentActionManager::AfterRead()
{
}

void FLatentActionManager::BeforeDelete()
{
}

void FEndClothSimulationFunction::AfterRead()
{
	FTickFunction::AfterRead();

}

void FEndClothSimulationFunction::BeforeDelete()
{
	FTickFunction::BeforeDelete();

}

void FStartClothSimulationFunction::AfterRead()
{
	FTickFunction::AfterRead();

}

void FStartClothSimulationFunction::BeforeDelete()
{
	FTickFunction::BeforeDelete();

}

void FEndPhysicsTickFunction::AfterRead()
{
	FTickFunction::AfterRead();

}

void FEndPhysicsTickFunction::BeforeDelete()
{
	FTickFunction::BeforeDelete();

}

void FStartPhysicsTickFunction::AfterRead()
{
	FTickFunction::AfterRead();

}

void FStartPhysicsTickFunction::BeforeDelete()
{
	FTickFunction::BeforeDelete();

}

void FLevelViewportInfo::AfterRead()
{
}

void FLevelViewportInfo::BeforeDelete()
{
}

void FMaterialSimplificationSettings::AfterRead()
{
}

void FMaterialSimplificationSettings::BeforeDelete()
{
}

void FLevelSimplificationDetails::AfterRead()
{
}

void FLevelSimplificationDetails::BeforeDelete()
{
}

void FStreamableTextureInstance::AfterRead()
{
}

void FStreamableTextureInstance::BeforeDelete()
{
}

void FDynamicTextureInstance::AfterRead()
{
	FStreamableTextureInstance::AfterRead();

	READ_PTR_FULL(Texture, UTexture2D);
}

void FDynamicTextureInstance::BeforeDelete()
{
	FStreamableTextureInstance::BeforeDelete();

	DELE_PTR_FULL(Texture);
}

void FNameCurveKey::AfterRead()
{
}

void FNameCurveKey::BeforeDelete()
{
}

void FNameCurve::AfterRead()
{
	FIndexedCurve::AfterRead();

}

void FNameCurve::BeforeDelete()
{
	FIndexedCurve::BeforeDelete();

}

void FCollisionMergingSettings::AfterRead()
{
}

void FCollisionMergingSettings::BeforeDelete()
{
}

void FMergedCollisionActorsSimplification::AfterRead()
{
}

void FMergedCollisionActorsSimplification::BeforeDelete()
{
}

void FMeshProxySettings::AfterRead()
{
}

void FMeshProxySettings::BeforeDelete()
{
}

void FMeshMergingSettings::AfterRead()
{
}

void FMeshMergingSettings::BeforeDelete()
{
}

void FHierarchicalSimplification::AfterRead()
{
}

void FHierarchicalSimplification::BeforeDelete()
{
}

void FNavGraphEdge::AfterRead()
{
}

void FNavGraphEdge::BeforeDelete()
{
}

void FSpriteCategoryInfo::AfterRead()
{
}

void FSpriteCategoryInfo::BeforeDelete()
{
}

void FTriIndices::AfterRead()
{
}

void FTriIndices::BeforeDelete()
{
}

void FTriMeshCollisionData::AfterRead()
{
}

void FTriMeshCollisionData::BeforeDelete()
{
}

void FPreviewAttachedObjectPair::AfterRead()
{
	READ_PTR_FULL(Object, UObject);
}

void FPreviewAttachedObjectPair::BeforeDelete()
{
	DELE_PTR_FULL(Object);
}

void FPreviewAssetAttachContainer::AfterRead()
{
}

void FPreviewAssetAttachContainer::BeforeDelete()
{
}

void FMorphTargetMap::AfterRead()
{
	READ_PTR_FULL(MorphTarget, UMorphTarget);
}

void FMorphTargetMap::BeforeDelete()
{
	DELE_PTR_FULL(MorphTarget);
}

void FBoneMirrorExport::AfterRead()
{
}

void FBoneMirrorExport::BeforeDelete()
{
}

void FAnimationGroupReference::AfterRead()
{
}

void FAnimationGroupReference::BeforeDelete()
{
}

void FAnimExtractContext::AfterRead()
{
}

void FAnimExtractContext::BeforeDelete()
{
}

void FSmartNameMapping::AfterRead()
{
}

void FSmartNameMapping::BeforeDelete()
{
}

void FNameMapping::AfterRead()
{
}

void FNameMapping::BeforeDelete()
{
}

void FRigConfiguration::AfterRead()
{
	READ_PTR_FULL(Rig, URig);
}

void FRigConfiguration::BeforeDelete()
{
	DELE_PTR_FULL(Rig);
}

void FBoneReductionSetting::AfterRead()
{
}

void FBoneReductionSetting::BeforeDelete()
{
}

void FBlendFilter::AfterRead()
{
}

void FBlendFilter::BeforeDelete()
{
}

void FBlendSampleData::AfterRead()
{
}

void FBlendSampleData::BeforeDelete()
{
}

void FAnimNode_BlendSpacePlayer::AfterRead()
{
	FAnimNode_AssetPlayerBase::AfterRead();

	READ_PTR_FULL(BlendSpace, UBlendSpaceBase);
}

void FAnimNode_BlendSpacePlayer::BeforeDelete()
{
	FAnimNode_AssetPlayerBase::BeforeDelete();

	DELE_PTR_FULL(BlendSpace);
}

void FAnimNode_RotationOffsetBlendSpace::AfterRead()
{
	FAnimNode_BlendSpacePlayer::AfterRead();

}

void FAnimNode_RotationOffsetBlendSpace::BeforeDelete()
{
	FAnimNode_BlendSpacePlayer::BeforeDelete();

}

void FFontParameterValue::AfterRead()
{
	READ_PTR_FULL(FontValue, UFont);
}

void FFontParameterValue::BeforeDelete()
{
	DELE_PTR_FULL(FontValue);
}

void FBuildPromotionOpenAssetSettings::AfterRead()
{
}

void FBuildPromotionOpenAssetSettings::BeforeDelete()
{
}

void FMaterialEditorPromotionSettings::AfterRead()
{
}

void FMaterialEditorPromotionSettings::BeforeDelete()
{
}

void FBuilderPoly::AfterRead()
{
}

void FBuilderPoly::BeforeDelete()
{
}

void FTouchInputControl::AfterRead()
{
	READ_PTR_FULL(Image1, UTexture2D);
	READ_PTR_FULL(Image2, UTexture2D);
}

void FTouchInputControl::BeforeDelete()
{
	DELE_PTR_FULL(Image1);
	DELE_PTR_FULL(Image2);
}

void FVectorParameterValue::AfterRead()
{
}

void FVectorParameterValue::BeforeDelete()
{
}

void FCollectionVectorParameter::AfterRead()
{
	FCollectionParameterBase::AfterRead();

}

void FCollectionVectorParameter::BeforeDelete()
{
	FCollectionParameterBase::BeforeDelete();

}

void FAutomaticInstancingMeshComponentArray::AfterRead()
{
}

void FAutomaticInstancingMeshComponentArray::BeforeDelete()
{
}

void FCullDistanceSizePair::AfterRead()
{
}

void FCullDistanceSizePair::BeforeDelete()
{
}

void FTViewTarget::AfterRead()
{
	READ_PTR_FULL(Target, AActor);
	READ_PTR_FULL(PlayerState, APlayerState);
}

void FTViewTarget::BeforeDelete()
{
	DELE_PTR_FULL(Target);
	DELE_PTR_FULL(PlayerState);
}

void FAnimGroupInfo::AfterRead()
{
}

void FAnimGroupInfo::BeforeDelete()
{
}

void FTableRowBase::AfterRead()
{
}

void FTableRowBase::BeforeDelete()
{
}

void FDialogueContext::AfterRead()
{
	READ_PTR_FULL(Speaker, UDialogueVoice);
}

void FDialogueContext::BeforeDelete()
{
	DELE_PTR_FULL(Speaker);
}

void FGenericStruct::AfterRead()
{
}

void FGenericStruct::BeforeDelete()
{
}

void FCollisionProfileName::AfterRead()
{
}

void FCollisionProfileName::BeforeDelete()
{
}

void FTimerHandle::AfterRead()
{
}

void FTimerHandle::BeforeDelete()
{
}

void FDebugFloatHistory::AfterRead()
{
}

void FDebugFloatHistory::BeforeDelete()
{
}

void FFormatTextArgument::AfterRead()
{
}

void FFormatTextArgument::BeforeDelete()
{
}

void FBakedStateExitTransition::AfterRead()
{
}

void FBakedStateExitTransition::BeforeDelete()
{
}

void FBakedAnimationState::AfterRead()
{
}

void FBakedAnimationState::BeforeDelete()
{
}

void FAnimationStateBase::AfterRead()
{
}

void FAnimationStateBase::BeforeDelete()
{
}

void FAnimationTransitionBetweenStates::AfterRead()
{
	FAnimationStateBase::AfterRead();

	READ_PTR_FULL(CustomCurve, UCurveFloat);
}

void FAnimationTransitionBetweenStates::BeforeDelete()
{
	FAnimationStateBase::BeforeDelete();

	DELE_PTR_FULL(CustomCurve);
}

void FKShapeElem::AfterRead()
{
}

void FKShapeElem::BeforeDelete()
{
}

void FKSphereElem::AfterRead()
{
	FKShapeElem::AfterRead();

}

void FKSphereElem::BeforeDelete()
{
	FKShapeElem::BeforeDelete();

}

void FKBoxElem::AfterRead()
{
	FKShapeElem::AfterRead();

}

void FKBoxElem::BeforeDelete()
{
	FKShapeElem::BeforeDelete();

}

void FKSphylElem::AfterRead()
{
	FKShapeElem::AfterRead();

}

void FKSphylElem::BeforeDelete()
{
	FKShapeElem::BeforeDelete();

}

void FTextureLODGroup::AfterRead()
{
}

void FTextureLODGroup::BeforeDelete()
{
}

void FRigTransformConstraint::AfterRead()
{
}

void FRigTransformConstraint::BeforeDelete()
{
}

void FTransformBaseConstraint::AfterRead()
{
}

void FTransformBaseConstraint::BeforeDelete()
{
}

void FTransformBase::AfterRead()
{
}

void FTransformBase::BeforeDelete()
{
}

void FDamageEvent::AfterRead()
{
	READ_PTR_FULL(DamageTypeClass, UClass);
}

void FDamageEvent::BeforeDelete()
{
	DELE_PTR_FULL(DamageTypeClass);
}

void FRadialDamageParams::AfterRead()
{
}

void FRadialDamageParams::BeforeDelete()
{
}

void FRadialDamageEvent::AfterRead()
{
	FDamageEvent::AfterRead();

}

void FRadialDamageEvent::BeforeDelete()
{
	FDamageEvent::BeforeDelete();

}

void FPointDamageEvent::AfterRead()
{
	FDamageEvent::AfterRead();

}

void FPointDamageEvent::BeforeDelete()
{
	FDamageEvent::BeforeDelete();

}

void FAnimNode_BlendSpaceEvaluator::AfterRead()
{
	FAnimNode_BlendSpacePlayer::AfterRead();

}

void FAnimNode_BlendSpaceEvaluator::BeforeDelete()
{
	FAnimNode_BlendSpacePlayer::BeforeDelete();

}

void FAnimNode_HIKFloorContact::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKFloorContact::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKLookAt::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKLookAt::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKOffset::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKOffset::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKPin::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKPin::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKPlant::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKPlant::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKPull::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKPull::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKReach::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKReach::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKReachRotator::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKReachRotator::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKRelativePlant::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKRelativePlant::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKResist::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKResist::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKSetProperty::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKSetProperty::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKSolve::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKSolve::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FAnimNode_HIKTest::AfterRead()
{
	FAnimNode_HIKBase::AfterRead();

}

void FAnimNode_HIKTest::BeforeDelete()
{
	FAnimNode_HIKBase::BeforeDelete();

}

void FBranchFilter::AfterRead()
{
}

void FBranchFilter::BeforeDelete()
{
}

void FInputBlendPose::AfterRead()
{
}

void FInputBlendPose::BeforeDelete()
{
}

void FAnimNode_LayeredBoneBlend::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_LayeredBoneBlend::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAnimNode_MultiWayBlend::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_MultiWayBlend::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAnimNode_MeshSpaceRefPose::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_MeshSpaceRefPose::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAnimNode_RefPose::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_RefPose::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FVOscillator::AfterRead()
{
}

void FVOscillator::BeforeDelete()
{
}

void FNavigationLink::AfterRead()
{
	FNavigationLinkBase::AfterRead();

}

void FNavigationLink::BeforeDelete()
{
	FNavigationLinkBase::BeforeDelete();

}

void FCircleElement2D::AfterRead()
{
}

void FCircleElement2D::BeforeDelete()
{
}

void FBoxElement2D::AfterRead()
{
}

void FBoxElement2D::BeforeDelete()
{
}

void FConvexElement2D::AfterRead()
{
}

void FConvexElement2D::BeforeDelete()
{
}

void FAggregateGeometry2D::AfterRead()
{
}

void FAggregateGeometry2D::BeforeDelete()
{
}

void FForceFeedbackChannelDetails::AfterRead()
{
}

void FForceFeedbackChannelDetails::BeforeDelete()
{
}

void FInterpGroupActorInfo::AfterRead()
{
}

void FInterpGroupActorInfo::BeforeDelete()
{
}

void FNavigationFilterArea::AfterRead()
{
	READ_PTR_FULL(AreaClass, UClass);
}

void FNavigationFilterArea::BeforeDelete()
{
	DELE_PTR_FULL(AreaClass);
}

void FNavigationFilterFlags::AfterRead()
{
}

void FNavigationFilterFlags::BeforeDelete()
{
}

void FSupportedAreaData::AfterRead()
{
	READ_PTR_FULL(AreaClass, UClass);
}

void FSupportedAreaData::BeforeDelete()
{
	DELE_PTR_FULL(AreaClass);
}

void FImportFactorySettingValues::AfterRead()
{
}

void FImportFactorySettingValues::BeforeDelete()
{
}

void FEditorImportWorkflowDefinition::AfterRead()
{
}

void FEditorImportWorkflowDefinition::BeforeDelete()
{
}

void FInstancedNavMesh::AfterRead()
{
}

void FInstancedNavMesh::BeforeDelete()
{
}

void FFractureMaterial::AfterRead()
{
}

void FFractureMaterial::BeforeDelete()
{
}

void FDestructibleChunkParameters::AfterRead()
{
}

void FDestructibleChunkParameters::BeforeDelete()
{
}

void FAudioQualitySettings::AfterRead()
{
}

void FAudioQualitySettings::BeforeDelete()
{
}

void FParticleEvent_GenerateInfo::AfterRead()
{
}

void FParticleEvent_GenerateInfo::BeforeDelete()
{
}

void FParticleEventGPU_GenerateInfo::AfterRead()
{
}

void FParticleEventGPU_GenerateInfo::BeforeDelete()
{
}

void FRotationAboutAxisParameters::AfterRead()
{
}

void FRotationAboutAxisParameters::BeforeDelete()
{
}

void FAssetEditorOrbitCameraPosition::AfterRead()
{
}

void FAssetEditorOrbitCameraPosition::BeforeDelete()
{
}

void FMeshSectionInfoMap::AfterRead()
{
}

void FMeshSectionInfoMap::BeforeDelete()
{
}

void FMeshSectionInfo::AfterRead()
{
}

void FMeshSectionInfo::BeforeDelete()
{
}

void FPresortedBillboardsParams::AfterRead()
{
}

void FPresortedBillboardsParams::BeforeDelete()
{
}

void FMeshBuildSettings::AfterRead()
{
	READ_PTR_FULL(DistanceFieldReplacementMesh, UStaticMesh);
}

void FMeshBuildSettings::BeforeDelete()
{
	DELE_PTR_FULL(DistanceFieldReplacementMesh);
}

void FMeshReductionSettings::AfterRead()
{
}

void FMeshReductionSettings::BeforeDelete()
{
}

void FSimplygonRemeshingSettings::AfterRead()
{
}

void FSimplygonRemeshingSettings::BeforeDelete()
{
}

void FStaticMeshSourceModel::AfterRead()
{
}

void FStaticMeshSourceModel::BeforeDelete()
{
}

void FStaticMeshOptimizationSettings::AfterRead()
{
}

void FStaticMeshOptimizationSettings::BeforeDelete()
{
}

void FTexturePlatformData::AfterRead()
{
}

void FTexturePlatformData::BeforeDelete()
{
}

void FTextureSource::AfterRead()
{
}

void FTextureSource::BeforeDelete()
{
}

void FClusterNode::AfterRead()
{
}

void FClusterNode::BeforeDelete()
{
}

void FMobileInstancedStaticMeshLOD::AfterRead()
{
}

void FMobileInstancedStaticMeshLOD::BeforeDelete()
{
}

void FCompressedTrack::AfterRead()
{
}

void FCompressedTrack::BeforeDelete()
{
}

void FCurveTrack::AfterRead()
{
}

void FCurveTrack::BeforeDelete()
{
}

void FCameraCutInfo::AfterRead()
{
}

void FCameraCutInfo::BeforeDelete()
{
}

void FHIKBoneTransform::AfterRead()
{
}

void FHIKBoneTransform::BeforeDelete()
{
}

void FSubtitleCue::AfterRead()
{
}

void FSubtitleCue::BeforeDelete()
{
}

void FLocalizedSubtitle::AfterRead()
{
}

void FLocalizedSubtitle::BeforeDelete()
{
}

void FNavDataConfig::AfterRead()
{
	FNavAgentProperties::AfterRead();

	READ_PTR_FULL(NavigationDataClass, UClass);
}

void FNavDataConfig::BeforeDelete()
{
	FNavAgentProperties::BeforeDelete();

	DELE_PTR_FULL(NavigationDataClass);
}

void FTextSizingParameters::AfterRead()
{
	READ_PTR_FULL(DrawFont, UFont);
}

void FTextSizingParameters::BeforeDelete()
{
	DELE_PTR_FULL(DrawFont);
}

void FCanvasIcon::AfterRead()
{
	READ_PTR_FULL(Texture, UTexture);
}

void FCanvasIcon::BeforeDelete()
{
	DELE_PTR_FULL(Texture);
}

void FSkeletalMeshLODInfo::AfterRead()
{
}

void FSkeletalMeshLODInfo::BeforeDelete()
{
}

void FAnimNode_Root::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_Root::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FClothingAssetData::AfterRead()
{
}

void FClothingAssetData::BeforeDelete()
{
}

void FFunctionExpressionInput::AfterRead()
{
	READ_PTR_FULL(ExpressionInput, UMaterialExpressionFunctionInput);
}

void FFunctionExpressionInput::BeforeDelete()
{
	DELE_PTR_FULL(ExpressionInput);
}

void FNetObjectPtr::AfterRead()
{
}

void FNetObjectPtr::BeforeDelete()
{
}

void FNetSubObjectPtr::AfterRead()
{
}

void FNetSubObjectPtr::BeforeDelete()
{
}

void FPerBoneBlendWeight::AfterRead()
{
}

void FPerBoneBlendWeight::BeforeDelete()
{
}

void FPerBoneBlendWeights::AfterRead()
{
}

void FPerBoneBlendWeights::BeforeDelete()
{
}

void FSlotAnimationTrack::AfterRead()
{
}

void FSlotAnimationTrack::BeforeDelete()
{
}

void FDelegateArray::AfterRead()
{
}

void FDelegateArray::BeforeDelete()
{
}

void FNetActorPtr::AfterRead()
{
}

void FNetActorPtr::BeforeDelete()
{
}

void FPacketDiscardStats::AfterRead()
{
}

void FPacketDiscardStats::BeforeDelete()
{
}

void FRuntimeVectorCurve::AfterRead()
{
	READ_PTR_FULL(ExternalCurve, UCurveVector);
}

void FRuntimeVectorCurve::BeforeDelete()
{
	DELE_PTR_FULL(ExternalCurve);
}

void FFeatureFlag::AfterRead()
{
}

void FFeatureFlag::BeforeDelete()
{
}

void FDepthFieldGlowInfo::AfterRead()
{
}

void FDepthFieldGlowInfo::BeforeDelete()
{
}

void FFontRenderInfo::AfterRead()
{
}

void FFontRenderInfo::BeforeDelete()
{
}

void FComponentReference::AfterRead()
{
	READ_PTR_FULL(OtherActor, AActor);
}

void FComponentReference::BeforeDelete()
{
	DELE_PTR_FULL(OtherActor);
}

void FVectorCurve::AfterRead()
{
	FAnimCurveBase::AfterRead();

}

void FVectorCurve::BeforeDelete()
{
	FAnimCurveBase::BeforeDelete();

}

void FTransformCurve::AfterRead()
{
	FAnimCurveBase::AfterRead();

}

void FTransformCurve::BeforeDelete()
{
	FAnimCurveBase::BeforeDelete();

}

void FSkeletalMeshComponentPreClothTickFunction::AfterRead()
{
	FTickFunction::AfterRead();

}

void FSkeletalMeshComponentPreClothTickFunction::BeforeDelete()
{
	FTickFunction::BeforeDelete();

}

void FRootMotionExtractionStep::AfterRead()
{
	READ_PTR_FULL(AnimSequence, UAnimSequence);
}

void FRootMotionExtractionStep::BeforeDelete()
{
	DELE_PTR_FULL(AnimSequence);
}

void FAnimationTransitionRule::AfterRead()
{
}

void FAnimationTransitionRule::BeforeDelete()
{
}

void FAnimationState::AfterRead()
{
	FAnimationStateBase::AfterRead();

}

void FAnimationState::BeforeDelete()
{
	FAnimationStateBase::BeforeDelete();

}

void FSlotEvaluationPose::AfterRead()
{
}

void FSlotEvaluationPose::BeforeDelete()
{
}

void FFFTWaterComponentParticleParams::AfterRead()
{
}

void FFFTWaterComponentParticleParams::BeforeDelete()
{
}

void FFFTWaterComponentParams::AfterRead()
{
	READ_PTR_FULL(FoamColourTex, UTexture);
}

void FFFTWaterComponentParams::BeforeDelete()
{
	DELE_PTR_FULL(FoamColourTex);
}

void FNameIndexPair::AfterRead()
{
}

void FNameIndexPair::BeforeDelete()
{
}

void FFlatWaterMeshTextureOverride::AfterRead()
{
	FNameIndexPair::AfterRead();

	READ_PTR_FULL(Texture, UTexture);
}

void FFlatWaterMeshTextureOverride::BeforeDelete()
{
	FNameIndexPair::BeforeDelete();

	DELE_PTR_FULL(Texture);
}

void FInstancedCoverageMeshLOD::AfterRead()
{
}

void FInstancedCoverageMeshLOD::BeforeDelete()
{
}

void FCanvasUVTri::AfterRead()
{
}

void FCanvasUVTri::BeforeDelete()
{
}

void FMaterialSpriteElement::AfterRead()
{
	READ_PTR_FULL(Material, UMaterialInterface);
	READ_PTR_FULL(DistanceToOpacityCurve, UCurveFloat);
	READ_PTR_FULL(DistanceToSizeCurve, UCurveFloat);
}

void FMaterialSpriteElement::BeforeDelete()
{
	DELE_PTR_FULL(Material);
	DELE_PTR_FULL(DistanceToOpacityCurve);
	DELE_PTR_FULL(DistanceToSizeCurve);
}

void FCollisionResponseTemplate::AfterRead()
{
}

void FCollisionResponseTemplate::BeforeDelete()
{
}

void FCustomChannelSetup::AfterRead()
{
}

void FCustomChannelSetup::BeforeDelete()
{
}

void FCustomProfile::AfterRead()
{
}

void FCustomProfile::BeforeDelete()
{
}

void FRedirector::AfterRead()
{
}

void FRedirector::BeforeDelete()
{
}

void FDestructibleDamageParameters::AfterRead()
{
}

void FDestructibleDamageParameters::BeforeDelete()
{
}

void FDestructibleAdvancedParameters::AfterRead()
{
}

void FDestructibleAdvancedParameters::BeforeDelete()
{
}

void FDestructibleSpecialHierarchyDepths::AfterRead()
{
}

void FDestructibleSpecialHierarchyDepths::BeforeDelete()
{
}

void FDestructibleDepthParameters::AfterRead()
{
}

void FDestructibleDepthParameters::BeforeDelete()
{
}

void FDestructibleParametersFlag::AfterRead()
{
}

void FDestructibleParametersFlag::BeforeDelete()
{
}

void FDestructibleDebrisParameters::AfterRead()
{
}

void FDestructibleDebrisParameters::BeforeDelete()
{
}

void FDestructibleParameters::AfterRead()
{
}

void FDestructibleParameters::BeforeDelete()
{
}

void FModulatorContinuousParams::AfterRead()
{
}

void FModulatorContinuousParams::BeforeDelete()
{
}

void FMergedCollisionComponentStaticMeshInstanceData::AfterRead()
{
	READ_PTR_FULL(StaticMesh, UStaticMesh);
}

void FMergedCollisionComponentStaticMeshInstanceData::BeforeDelete()
{
	DELE_PTR_FULL(StaticMesh);
}

void FFractureEffect::AfterRead()
{
	READ_PTR_FULL(ParticleSystem, UParticleSystem);
	READ_PTR_FULL(Sound, USoundBase);
}

void FFractureEffect::BeforeDelete()
{
	DELE_PTR_FULL(ParticleSystem);
	DELE_PTR_FULL(Sound);
}

void FAnimNode_UseCachedPose::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_UseCachedPose::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAnimNode_ConvertComponentToLocalSpace::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_ConvertComponentToLocalSpace::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FDummySpacerCameraTypes::AfterRead()
{
}

void FDummySpacerCameraTypes::BeforeDelete()
{
}

void FNetTimeStampCalculator::AfterRead()
{
}

void FNetTimeStampCalculator::BeforeDelete()
{
}

void FStreamableManager::AfterRead()
{
}

void FStreamableManager::BeforeDelete()
{
}

void FServerMigrationTelemetryFailedData::AfterRead()
{
}

void FServerMigrationTelemetryFailedData::BeforeDelete()
{
}

void FServerMigrationTelemetryActorData::AfterRead()
{
}

void FServerMigrationTelemetryActorData::BeforeDelete()
{
}

void FServerMigrationTelemetrySucceededData::AfterRead()
{
}

void FServerMigrationTelemetrySucceededData::BeforeDelete()
{
}

void FReplicatedPhysicsState::AfterRead()
{
	READ_PTR_FULL(MovementBase, UPrimitiveComponent);
	READ_PTR_FULL(AttachParent, USceneComponent);
}

void FReplicatedPhysicsState::BeforeDelete()
{
	DELE_PTR_FULL(MovementBase);
	DELE_PTR_FULL(AttachParent);
}

void FRepTransform::AfterRead()
{
}

void FRepTransform::BeforeDelete()
{
}

void FReplicatedTransformState::AfterRead()
{
	READ_PTR_FULL(MovementBase, USceneComponent);
	READ_PTR_FULL(AttachParent, USceneComponent);
}

void FReplicatedTransformState::BeforeDelete()
{
	DELE_PTR_FULL(MovementBase);
	DELE_PTR_FULL(AttachParent);
}

void FSkelMeshMergeMorphTarget::AfterRead()
{
}

void FSkelMeshMergeMorphTarget::BeforeDelete()
{
}

void FSplineMeshParams::AfterRead()
{
}

void FSplineMeshParams::BeforeDelete()
{
}

void FEngineShowFlagsSetting::AfterRead()
{
}

void FEngineShowFlagsSetting::BeforeDelete()
{
}

void FTimelineEventEntry::AfterRead()
{
}

void FTimelineEventEntry::BeforeDelete()
{
}

void FTimelineVectorTrack::AfterRead()
{
	READ_PTR_FULL(VectorCurve, UCurveVector);
	READ_PTR_FULL(VectorProperty, UStructProperty);
}

void FTimelineVectorTrack::BeforeDelete()
{
	DELE_PTR_FULL(VectorCurve);
	DELE_PTR_FULL(VectorProperty);
}

void FTimelineFloatTrack::AfterRead()
{
	READ_PTR_FULL(FloatCurve, UCurveFloat);
	READ_PTR_FULL(FloatProperty, UFloatProperty);
}

void FTimelineFloatTrack::BeforeDelete()
{
	DELE_PTR_FULL(FloatCurve);
	DELE_PTR_FULL(FloatProperty);
}

void FTimelineLinearColorTrack::AfterRead()
{
	READ_PTR_FULL(LinearColorCurve, UCurveLinearColor);
	READ_PTR_FULL(LinearColorProperty, UStructProperty);
}

void FTimelineLinearColorTrack::BeforeDelete()
{
	DELE_PTR_FULL(LinearColorCurve);
	DELE_PTR_FULL(LinearColorProperty);
}

void FTimeline::AfterRead()
{
	READ_PTR_FULL(DirectionProperty, UByteProperty);
}

void FTimeline::BeforeDelete()
{
	DELE_PTR_FULL(DirectionProperty);
}

void FTrackToSkeletonMap::AfterRead()
{
}

void FTrackToSkeletonMap::BeforeDelete()
{
}

void FTranslationTrack::AfterRead()
{
}

void FTranslationTrack::BeforeDelete()
{
}

void FRotationTrack::AfterRead()
{
}

void FRotationTrack::BeforeDelete()
{
}

void FScaleTrack::AfterRead()
{
}

void FScaleTrack::BeforeDelete()
{
}

void FCompressedOffsetData::AfterRead()
{
}

void FCompressedOffsetData::BeforeDelete()
{
}

void FBlendParameter::AfterRead()
{
}

void FBlendParameter::BeforeDelete()
{
}

void FInterpolationParameter::AfterRead()
{
}

void FInterpolationParameter::BeforeDelete()
{
}

void FPerBoneInterpolation::AfterRead()
{
}

void FPerBoneInterpolation::BeforeDelete()
{
}

void FEditorElement::AfterRead()
{
}

void FEditorElement::BeforeDelete()
{
}

void FAnimSetMeshLinkup::AfterRead()
{
}

void FAnimSetMeshLinkup::BeforeDelete()
{
}

void FEditorMapPerformanceTestDefinition::AfterRead()
{
}

void FEditorMapPerformanceTestDefinition::BeforeDelete()
{
}

void FDirectoryPath::AfterRead()
{
}

void FDirectoryPath::BeforeDelete()
{
}

void FBuildPromotionNewProjectSettings::AfterRead()
{
}

void FBuildPromotionNewProjectSettings::BeforeDelete()
{
}

void FParticleEditorPromotionSettings::AfterRead()
{
}

void FParticleEditorPromotionSettings::BeforeDelete()
{
}

void FLaunchOnTestSettings::AfterRead()
{
}

void FLaunchOnTestSettings::BeforeDelete()
{
}

void FNavAvoidanceData::AfterRead()
{
}

void FNavAvoidanceData::BeforeDelete()
{
}

void FBlueprintComponentDelegateBinding::AfterRead()
{
}

void FBlueprintComponentDelegateBinding::BeforeDelete()
{
}

void FPOV::AfterRead()
{
}

void FPOV::BeforeDelete()
{
}

void FAnimUpdateRateParameters::AfterRead()
{
}

void FAnimUpdateRateParameters::BeforeDelete()
{
}

void FAnimSlotDesc::AfterRead()
{
}

void FAnimSlotDesc::BeforeDelete()
{
}

void FAnimSlotInfo::AfterRead()
{
}

void FAnimSlotInfo::BeforeDelete()
{
}

void FMTDResult::AfterRead()
{
}

void FMTDResult::BeforeDelete()
{
}

void FOverlapResult::AfterRead()
{
}

void FOverlapResult::BeforeDelete()
{
}

void FSwarmDebugOptions::AfterRead()
{
}

void FSwarmDebugOptions::BeforeDelete()
{
}

void FLightmassDebugOptions::AfterRead()
{
}

void FLightmassDebugOptions::BeforeDelete()
{
}

void FAnimNode_SaveCachedPose::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_SaveCachedPose::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAnimNode_SequenceEvaluator::AfterRead()
{
	FAnimNode_AssetPlayerBase::AfterRead();

	READ_PTR_FULL(Sequence, UAnimSequenceBase);
}

void FAnimNode_SequenceEvaluator::BeforeDelete()
{
	FAnimNode_AssetPlayerBase::BeforeDelete();

	DELE_PTR_FULL(Sequence);
}

void FAnimNode_SequencePlayer::AfterRead()
{
	FAnimNode_AssetPlayerBase::AfterRead();

	READ_PTR_FULL(Sequence, UAnimSequenceBase);
}

void FAnimNode_SequencePlayer::BeforeDelete()
{
	FAnimNode_AssetPlayerBase::BeforeDelete();

	DELE_PTR_FULL(Sequence);
}

void FAnimNode_Slot::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_Slot::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAnimNode_StateMachine::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_StateMachine::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAnimationPotentialTransition::AfterRead()
{
}

void FAnimationPotentialTransition::BeforeDelete()
{
}

void FAnimationActiveTransitionEntry::AfterRead()
{
}

void FAnimationActiveTransitionEntry::BeforeDelete()
{
}

void FAnimNode_TransitionPoseEvaluator::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_TransitionPoseEvaluator::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAnimNode_TransitionResult::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_TransitionResult::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FAnimNode_ConvertLocalToComponentSpace::AfterRead()
{
	FAnimNode_Base::AfterRead();

}

void FAnimNode_ConvertLocalToComponentSpace::BeforeDelete()
{
	FAnimNode_Base::BeforeDelete();

}

void FBuildPromotionImportWorkflowSettings::AfterRead()
{
}

void FBuildPromotionImportWorkflowSettings::BeforeDelete()
{
}

void FBuildPromotionBlueprintSettings::AfterRead()
{
}

void FBuildPromotionBlueprintSettings::BeforeDelete()
{
}

void FBuildPromotionTestSettings::AfterRead()
{
}

void FBuildPromotionTestSettings::BeforeDelete()
{
}

void FEditorImportExportTestDefinition::AfterRead()
{
}

void FEditorImportExportTestDefinition::BeforeDelete()
{
}

void FSubsurfaceProfileStruct::AfterRead()
{
}

void FSubsurfaceProfileStruct::BeforeDelete()
{
}

void FTTTrackBase::AfterRead()
{
}

void FTTTrackBase::BeforeDelete()
{
}

void FTTEventTrack::AfterRead()
{
	FTTTrackBase::AfterRead();

	READ_PTR_FULL(CurveKeys, UCurveFloat);
}

void FTTEventTrack::BeforeDelete()
{
	FTTTrackBase::BeforeDelete();

	DELE_PTR_FULL(CurveKeys);
}

void FTTFloatTrack::AfterRead()
{
	FTTTrackBase::AfterRead();

	READ_PTR_FULL(CurveFloat, UCurveFloat);
}

void FTTFloatTrack::BeforeDelete()
{
	FTTTrackBase::BeforeDelete();

	DELE_PTR_FULL(CurveFloat);
}

void FTTVectorTrack::AfterRead()
{
	FTTTrackBase::AfterRead();

	READ_PTR_FULL(CurveVector, UCurveVector);
}

void FTTVectorTrack::BeforeDelete()
{
	FTTTrackBase::BeforeDelete();

	DELE_PTR_FULL(CurveVector);
}

void FTTLinearColorTrack::AfterRead()
{
	FTTTrackBase::AfterRead();

	READ_PTR_FULL(CurveLinearColor, UCurveLinearColor);
}

void FTTLinearColorTrack::BeforeDelete()
{
	FTTTrackBase::BeforeDelete();

	DELE_PTR_FULL(CurveLinearColor);
}

void FExternalToolDefinition::AfterRead()
{
}

void FExternalToolDefinition::BeforeDelete()
{
}

void FGPUSpriteLocalVectorFieldInfo::AfterRead()
{
	READ_PTR_FULL(Field, UVectorField);
}

void FGPUSpriteLocalVectorFieldInfo::BeforeDelete()
{
	DELE_PTR_FULL(Field);
}

void FFloatDistribution::AfterRead()
{
}

void FFloatDistribution::BeforeDelete()
{
}

void FRawDistributionVector::AfterRead()
{
	FRawDistribution::AfterRead();

	READ_PTR_FULL(Distribution, UDistributionVector);
}

void FRawDistributionVector::BeforeDelete()
{
	FRawDistribution::BeforeDelete();

	DELE_PTR_FULL(Distribution);
}

void FGPUSpriteEmitterInfo::AfterRead()
{
	READ_PTR_FULL(RequiredModule, UParticleModuleRequired);
	READ_PTR_FULL(SpawnModule, UParticleModuleSpawn);
	READ_PTR_FULL(SpawnPerUnitModule, UParticleModuleSpawnPerUnit);
	READ_PTR_FULL(SpawnRepeatPerPointModule, UParticleModuleSpawnRepeatPerPoint);
	READ_PTR_FULL(ParticleComputeData, UParticleComputeShaderData);
	READ_PTR_FULL(ParametersOverVelocity, UParticleModuleParametersOverVelocity);
	READ_PTR_FULL(ParametersOverCustom, UParticleModuleParametersOverCustom);
}

void FGPUSpriteEmitterInfo::BeforeDelete()
{
	DELE_PTR_FULL(RequiredModule);
	DELE_PTR_FULL(SpawnModule);
	DELE_PTR_FULL(SpawnPerUnitModule);
	DELE_PTR_FULL(SpawnRepeatPerPointModule);
	DELE_PTR_FULL(ParticleComputeData);
	DELE_PTR_FULL(ParametersOverVelocity);
	DELE_PTR_FULL(ParametersOverCustom);
}

void FGPUSpriteResourceData::AfterRead()
{
}

void FGPUSpriteResourceData::BeforeDelete()
{
}

void FBakedAnimationStateMachine::AfterRead()
{
}

void FBakedAnimationStateMachine::BeforeDelete()
{
}

void FKConvexElem::AfterRead()
{
	FKShapeElem::AfterRead();

}

void FKConvexElem::BeforeDelete()
{
	FKShapeElem::BeforeDelete();

}

void FKAggregateGeom::AfterRead()
{
}

void FKAggregateGeom::BeforeDelete()
{
}

void FHIKBoneMapping::AfterRead()
{
}

void FHIKBoneMapping::BeforeDelete()
{
}

void FInputAxisConfigEntry::AfterRead()
{
}

void FInputAxisConfigEntry::BeforeDelete()
{
}

void FParticleRandomSeedInfo::AfterRead()
{
}

void FParticleRandomSeedInfo::BeforeDelete()
{
}

void FCustomInput::AfterRead()
{
}

void FCustomInput::BeforeDelete()
{
}

void FBeamModifierOptions::AfterRead()
{
}

void FBeamModifierOptions::BeforeDelete()
{
}

void FTextureRenderData::AfterRead()
{
	READ_PTR_FULL(RenderTexture, UTexture);
}

void FTextureRenderData::BeforeDelete()
{
	DELE_PTR_FULL(RenderTexture);
}

void FPurchaseInfo::AfterRead()
{
}

void FPurchaseInfo::BeforeDelete()
{
}

void FNode::AfterRead()
{
}

void FNode::BeforeDelete()
{
}

void FPhysicalSurfaceName::AfterRead()
{
}

void FPhysicalSurfaceName::BeforeDelete()
{
}

void FDominanceGroupPair::AfterRead()
{
}

void FDominanceGroupPair::BeforeDelete()
{
}

void FDominanceGroupName::AfterRead()
{
}

void FDominanceGroupName::BeforeDelete()
{
}

void FRawAnimSequenceTrack::AfterRead()
{
}

void FRawAnimSequenceTrack::BeforeDelete()
{
}

void FAnimSequenceTrackContainer::AfterRead()
{
}

void FAnimSequenceTrackContainer::BeforeDelete()
{
}

void FGridBlendSample::AfterRead()
{
}

void FGridBlendSample::BeforeDelete()
{
}

void FAssetImportInfo::AfterRead()
{
}

void FAssetImportInfo::BeforeDelete()
{
}

void FDialogueContextMapping::AfterRead()
{
	READ_PTR_FULL(SoundWave, USoundWave);
	READ_PTR_FULL(Proxy, UDialogueSoundWaveProxy);
}

void FDialogueContextMapping::BeforeDelete()
{
	DELE_PTR_FULL(SoundWave);
	DELE_PTR_FULL(Proxy);
}

void FLocationBoneSocketInfo::AfterRead()
{
}

void FLocationBoneSocketInfo::BeforeDelete()
{
}

void FBlueprintInstancedActorDelegateBinding::AfterRead()
{
}

void FBlueprintInstancedActorDelegateBinding::BeforeDelete()
{
}

void FFontImportOptionsData::AfterRead()
{
}

void FFontImportOptionsData::BeforeDelete()
{
}

void FFontCharacter::AfterRead()
{
}

void FFontCharacter::BeforeDelete()
{
}

void FToggleTrackKey::AfterRead()
{
}

void FToggleTrackKey::BeforeDelete()
{
}

void FSoundTrackKey::AfterRead()
{
	READ_PTR_FULL(Sound, USoundBase);
}

void FSoundTrackKey::BeforeDelete()
{
	DELE_PTR_FULL(Sound);
}

void FVisibilityTrackKey::AfterRead()
{
}

void FVisibilityTrackKey::BeforeDelete()
{
}

void FPrimitiveMaterialRef::AfterRead()
{
	READ_PTR_FULL(Primitive, UPrimitiveComponent);
	READ_PTR_FULL(Decal, UDecalComponent);
}

void FPrimitiveMaterialRef::BeforeDelete()
{
	DELE_PTR_FULL(Primitive);
	DELE_PTR_FULL(Decal);
}

void FLayerActorStats::AfterRead()
{
	READ_PTR_FULL(Type, UClass);
}

void FLayerActorStats::BeforeDelete()
{
	DELE_PTR_FULL(Type);
}

void FLightmassPrimitiveSettings::AfterRead()
{
}

void FLightmassPrimitiveSettings::BeforeDelete()
{
}

void FWrappedStringElement::AfterRead()
{
}

void FWrappedStringElement::BeforeDelete()
{
}

void FFunctionExpressionOutput::AfterRead()
{
	READ_PTR_FULL(ExpressionOutput, UMaterialExpressionFunctionOutput);
}

void FFunctionExpressionOutput::BeforeDelete()
{
	DELE_PTR_FULL(ExpressionOutput);
}

void FVector4Distribution::AfterRead()
{
}

void FVector4Distribution::BeforeDelete()
{
}

void FPlatformInterfaceData::AfterRead()
{
	READ_PTR_FULL(ObjectValue, UObject);
}

void FPlatformInterfaceData::BeforeDelete()
{
	DELE_PTR_FULL(ObjectValue);
}

void FPlatformInterfaceDelegateResult::AfterRead()
{
}

void FPlatformInterfaceDelegateResult::BeforeDelete()
{
}

void FFastArraySerializerItem::AfterRead()
{
}

void FFastArraySerializerItem::BeforeDelete()
{
}

void FFastArraySerializer::AfterRead()
{
}

void FFastArraySerializer::BeforeDelete()
{
}

void FNavCollisionCylinder::AfterRead()
{
}

void FNavCollisionCylinder::BeforeDelete()
{
}

void FVelocityConeGroupParams::AfterRead()
{
}

void FVelocityConeGroupParams::BeforeDelete()
{
}

void FAnimNotifyTrack::AfterRead()
{
}

void FAnimNotifyTrack::BeforeDelete()
{
}

void FAnimParentNodeAssetOverride::AfterRead()
{
	READ_PTR_FULL(NewAsset, UAnimationAsset);
}

void FAnimParentNodeAssetOverride::BeforeDelete()
{
	DELE_PTR_FULL(NewAsset);
}

void FDataTableCategoryHandle::AfterRead()
{
	READ_PTR_FULL(DataTable, UDataTable);
}

void FDataTableCategoryHandle::BeforeDelete()
{
	DELE_PTR_FULL(DataTable);
}

void FDataTableRowHandle::AfterRead()
{
	READ_PTR_FULL(DataTable, UDataTable);
}

void FDataTableRowHandle::BeforeDelete()
{
	DELE_PTR_FULL(DataTable);
}

void FBlueprintDebugData::AfterRead()
{
}

void FBlueprintDebugData::BeforeDelete()
{
}

void FPointerToUberGraphFrame::AfterRead()
{
}

void FPointerToUberGraphFrame::BeforeDelete()
{
}

void FDebuggingInfoForSingleFunction::AfterRead()
{
}

void FDebuggingInfoForSingleFunction::BeforeDelete()
{
}

void FNodeToCodeAssociation::AfterRead()
{
}

void FNodeToCodeAssociation::BeforeDelete()
{
}

void FAnimBlueprintDebugData::AfterRead()
{
}

void FAnimBlueprintDebugData::BeforeDelete()
{
}

void FAnimationFrameSnapshot::AfterRead()
{
}

void FAnimationFrameSnapshot::BeforeDelete()
{
}

void FStateMachineDebugData::AfterRead()
{
}

void FStateMachineDebugData::BeforeDelete()
{
}

void FSoundGroup::AfterRead()
{
}

void FSoundGroup::BeforeDelete()
{
}

void FSoundClassProperties::AfterRead()
{
}

void FSoundClassProperties::BeforeDelete()
{
}

void FPassiveSoundMixModifier::AfterRead()
{
	READ_PTR_FULL(SoundMix, USoundMix);
}

void FPassiveSoundMixModifier::BeforeDelete()
{
	DELE_PTR_FULL(SoundMix);
}

void FAudioEQEffect::AfterRead()
{
}

void FAudioEQEffect::BeforeDelete()
{
}

void FSoundClassAdjuster::AfterRead()
{
	READ_PTR_FULL(SoundClassObject, USoundClass);
}

void FSoundClassAdjuster::BeforeDelete()
{
	DELE_PTR_FULL(SoundClassObject);
}

void FVectorDistribution::AfterRead()
{
}

void FVectorDistribution::BeforeDelete()
{
}

void FDialogueWaveParameter::AfterRead()
{
	READ_PTR_FULL(DialogueWave, UDialogueWave);
}

void FDialogueWaveParameter::BeforeDelete()
{
	DELE_PTR_FULL(DialogueWave);
}

void FDistanceDatum::AfterRead()
{
}

void FDistanceDatum::BeforeDelete()
{
}

void FStringCurve::AfterRead()
{
	FIndexedCurve::AfterRead();

}

void FStringCurve::BeforeDelete()
{
	FIndexedCurve::BeforeDelete();

}

void FExposureSettings::AfterRead()
{
}

void FExposureSettings::BeforeDelete()
{
}

void FTickPrerequisite::AfterRead()
{
}

void FTickPrerequisite::BeforeDelete()
{
}

// Function:
//		Offset -> 0x02A3ADD0
//		Name   -> Function Engine.ActorComponent.ToggleActive
//		Flags  -> (Native, Public, BlueprintCallable)
void UActorComponent::ToggleActive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ToggleActive");

	UActorComponent_ToggleActive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39E30
//		Name   -> Function Engine.ActorComponent.SetTickGroup
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ETickingGroup>                  NewTickGroup                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UActorComponent::SetTickGroup(TEnumAsByte<Engine_ETickingGroup> NewTickGroup)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetTickGroup");

	UActorComponent_SetTickGroup_Params params {};
	params.NewTickGroup = NewTickGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39F40
//		Name   -> Function Engine.ActorComponent.SetTickableWhenPaused
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bTickableWhenPaused                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UActorComponent::SetTickableWhenPaused(bool bTickableWhenPaused)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetTickableWhenPaused");

	UActorComponent_SetTickableWhenPaused_Params params {};
	params.bTickableWhenPaused = bTickableWhenPaused;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A396A0
//		Name   -> Function Engine.ActorComponent.SetIsReplicated
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ShouldReplicate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UActorComponent::SetIsReplicated(bool ShouldReplicate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetIsReplicated");

	UActorComponent_SetIsReplicated_Params params {};
	params.ShouldReplicate = ShouldReplicate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38F00
//		Name   -> Function Engine.ActorComponent.SetComponentTickEnabled
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UActorComponent::SetComponentTickEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetComponentTickEnabled");

	UActorComponent_SetComponentTickEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A385E0
//		Name   -> Function Engine.ActorComponent.SetActive
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewActive                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bReset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UActorComponent::SetActive(bool bNewActive, bool bReset)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetActive");

	UActorComponent_SetActive_Params params {};
	params.bNewActive = bNewActive;
	params.bReset = bReset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37630
//		Name   -> Function Engine.ActorComponent.RemoveTickPrerequisiteComponent
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UActorComponent*                             PrerequisiteComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UActorComponent::RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.RemoveTickPrerequisiteComponent");

	UActorComponent_RemoveTickPrerequisiteComponent_Params params {};
	params.PrerequisiteComponent = PrerequisiteComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37510
//		Name   -> Function Engine.ActorComponent.RemoveTickPrerequisiteActor
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      PrerequisiteActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UActorComponent::RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.RemoveTickPrerequisiteActor");

	UActorComponent_RemoveTickPrerequisiteActor_Params params {};
	params.PrerequisiteActor = PrerequisiteActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.ActorComponent.ReceiveTick
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UActorComponent::ReceiveTick(float DeltaSeconds)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveTick");

	UActorComponent_ReceiveTick_Params params {};
	params.DeltaSeconds = DeltaSeconds;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.ActorComponent.ReceiveEndPlay
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TEnumAsByte<Engine_EEndPlayReason>                 EndPlayReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UActorComponent::ReceiveEndPlay(TEnumAsByte<Engine_EEndPlayReason> EndPlayReason)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveEndPlay");

	UActorComponent_ReceiveEndPlay_Params params {};
	params.EndPlayReason = EndPlayReason;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.ActorComponent.ReceiveBeginPlay
//		Flags  -> (Event, Public, BlueprintEvent)
void UActorComponent::ReceiveBeginPlay()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveBeginPlay");

	UActorComponent_ReceiveBeginPlay_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36420
//		Name   -> Function Engine.ActorComponent.OnRep_IsActive
//		Flags  -> (Native, Public)
void UActorComponent::OnRep_IsActive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.OnRep_IsActive");

	UActorComponent_OnRep_IsActive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A34250
//		Name   -> Function Engine.ActorComponent.K2_DestroyComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UActorComponent::K2_DestroyComponent(class UObject* Object)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.K2_DestroyComponent");

	UActorComponent_K2_DestroyComponent_Params params {};
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A31FD0
//		Name   -> Function Engine.ActorComponent.IsComponentTickEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UActorComponent::IsComponentTickEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsComponentTickEnabled");

	UActorComponent_IsComponentTickEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31F70
//		Name   -> Function Engine.ActorComponent.IsBeingDestroyed
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UActorComponent::IsBeingDestroyed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsBeingDestroyed");

	UActorComponent_IsBeingDestroyed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31EB0
//		Name   -> Function Engine.ActorComponent.IsActive
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UActorComponent::IsActive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsActive");

	UActorComponent_IsActive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A317F0
//		Name   -> Function Engine.ActorComponent.GetTargetNetDormancy
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_EComponentNetDormancy>          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
TEnumAsByte<Engine_EComponentNetDormancy> UActorComponent::GetTargetNetDormancy()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.GetTargetNetDormancy");

	UActorComponent_GetTargetNetDormancy_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A312A0
//		Name   -> Function Engine.ActorComponent.GetOwner
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* UActorComponent::GetOwner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.GetOwner");

	UActorComponent_GetOwner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E420
//		Name   -> Function Engine.ActorComponent.FlushNetDormancy
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UActorComponent::FlushNetDormancy()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.FlushNetDormancy");

	UActorComponent_FlushNetDormancy_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2DA50
//		Name   -> Function Engine.ActorComponent.Deactivate
//		Flags  -> (Native, Public, BlueprintCallable)
void UActorComponent::Deactivate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.Deactivate");

	UActorComponent_Deactivate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2D8C0
//		Name   -> Function Engine.ActorComponent.ComponentHasTag
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UActorComponent::ComponentHasTag(const struct FName& Tag)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ComponentHasTag");

	UActorComponent_ComponentHasTag_Params params {};
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2A8A0
//		Name   -> Function Engine.ActorComponent.AddTickPrerequisiteComponent
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UActorComponent*                             PrerequisiteComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UActorComponent::AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddTickPrerequisiteComponent");

	UActorComponent_AddTickPrerequisiteComponent_Params params {};
	params.PrerequisiteComponent = PrerequisiteComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2A780
//		Name   -> Function Engine.ActorComponent.AddTickPrerequisiteActor
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      PrerequisiteActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UActorComponent::AddTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddTickPrerequisiteActor");

	UActorComponent_AddTickPrerequisiteActor_Params params {};
	params.PrerequisiteActor = PrerequisiteActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A29FA0
//		Name   -> Function Engine.ActorComponent.Activate
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bReset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UActorComponent::Activate(bool bReset)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.Activate");

	UActorComponent_Activate_Params params {};
	params.bReset = bReset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UActorComponent::AfterRead()
{
	UObject::AfterRead();

}

void UActorComponent::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.UserConstructionScript
//		Flags  -> (Event, Public, BlueprintEvent)
void AActor::UserConstructionScript()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.UserConstructionScript");

	AActor_UserConstructionScript_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3ADB0
//		Name   -> Function Engine.Actor.TearOff
//		Flags  -> (Native, Public, BlueprintCallable)
void AActor::TearOff()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.TearOff");

	AActor_TearOff_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A4E0
//		Name   -> Function Engine.Actor.SnapRootComponentTo
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      InParentActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::SnapRootComponentTo(class AActor* InParentActor, const struct FName& InSocketName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SnapRootComponentTo");

	AActor_SnapRootComponentTo_Params params {};
	params.InParentActor = InParentActor;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39DB0
//		Name   -> Function Engine.Actor.SetTickGroup
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ETickingGroup>                  NewTickGroup                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::SetTickGroup(TEnumAsByte<Engine_ETickingGroup> NewTickGroup)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetTickGroup");

	AActor_SetTickGroup_Params params {};
	params.NewTickGroup = NewTickGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39EB0
//		Name   -> Function Engine.Actor.SetTickableWhenPaused
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bTickableWhenPaused                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::SetTickableWhenPaused(bool bTickableWhenPaused)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetTickableWhenPaused");

	AActor_SetTickableWhenPaused_Params params {};
	params.bTickableWhenPaused = bTickableWhenPaused;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39C20
//		Name   -> Function Engine.Actor.SetReplicates
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bInReplicates                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::SetReplicates(bool bInReplicates)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetReplicates");

	AActor_SetReplicates_Params params {};
	params.bInReplicates = bInReplicates;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39B90
//		Name   -> Function Engine.Actor.SetReplicateMovement
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bInReplicateMovement                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::SetReplicateMovement(bool bInReplicateMovement)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetReplicateMovement");

	AActor_SetReplicateMovement_Params params {};
	params.bInReplicateMovement = bInReplicateMovement;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39A00
//		Name   -> Function Engine.Actor.SetOwner
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      NewOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::SetOwner(class AActor* NewOwner)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetOwner");

	AActor_SetOwner_Params params {};
	params.NewOwner = NewOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39730
//		Name   -> Function Engine.Actor.SetLifeSpan
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InLifespan                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::SetLifeSpan(float InLifespan)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetLifeSpan");

	AActor_SetLifeSpan_Params params {};
	params.InLifespan = InLifespan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39520
//		Name   -> Function Engine.Actor.SetIgnoreNetTransformUpdates
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bInIgnoreNetTransformUpdates                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::SetIgnoreNetTransformUpdates(bool bInIgnoreNetTransformUpdates)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetIgnoreNetTransformUpdates");

	AActor_SetIgnoreNetTransformUpdates_Params params {};
	params.bInIgnoreNetTransformUpdates = bInIgnoreNetTransformUpdates;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38990
//		Name   -> Function Engine.Actor.SetActorTickEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::SetActorTickEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorTickEnabled");

	AActor_SetActorTickEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38900
//		Name   -> Function Engine.Actor.SetActorScale3D
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewScale3D                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::SetActorScale3D(const struct FVector& NewScale3D)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorScale3D");

	AActor_SetActorScale3D_Params params {};
	params.NewScale3D = NewScale3D;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38860
//		Name   -> Function Engine.Actor.SetActorRotation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::SetActorRotation(const struct FRotator& NewRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorRotation");

	AActor_SetActorRotation_Params params {};
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A387D0
//		Name   -> Function Engine.Actor.SetActorRelativeScale3D
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewRelativeScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::SetActorRelativeScale3D(const struct FVector& NewRelativeScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorRelativeScale3D");

	AActor_SetActorRelativeScale3D_Params params {};
	params.NewRelativeScale = NewRelativeScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38740
//		Name   -> Function Engine.Actor.SetActorHiddenInGame
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewHidden                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::SetActorHiddenInGame(bool bNewHidden)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorHiddenInGame");

	AActor_SetActorHiddenInGame_Params params {};
	params.bNewHidden = bNewHidden;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A386B0
//		Name   -> Function Engine.Actor.SetActorEnableCollision
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewActorEnableCollision                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::SetActorEnableCollision(bool bNewActorEnableCollision)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorEnableCollision");

	AActor_SetActorEnableCollision_Params params {};
	params.bNewActorEnableCollision = bNewActorEnableCollision;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A375A0
//		Name   -> Function Engine.Actor.RemoveTickPrerequisiteComponent
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UActorComponent*                             PrerequisiteComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.RemoveTickPrerequisiteComponent");

	AActor_RemoveTickPrerequisiteComponent_Params params {};
	params.PrerequisiteComponent = PrerequisiteComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37480
//		Name   -> Function Engine.Actor.RemoveTickPrerequisiteActor
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      PrerequisiteActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.RemoveTickPrerequisiteActor");

	AActor_RemoveTickPrerequisiteActor_Params params {};
	params.PrerequisiteActor = PrerequisiteActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveTick
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceiveTick(float DeltaSeconds)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveTick");

	AActor_ReceiveTick_Params params {};
	params.DeltaSeconds = DeltaSeconds;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveRadialDamage
//		Flags  -> (BlueprintAuthorityOnly, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
//		float                                              DamageReceived                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceiveRadialDamage(float DamageReceived, class UDamageType* DamageType, const struct FVector& Origin, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveRadialDamage");

	AActor_ReceiveRadialDamage_Params params {};
	params.DamageReceived = DamageReceived;
	params.DamageType = DamageType;
	params.Origin = Origin;
	params.HitInfo = HitInfo;
	params.InstigatedBy = InstigatedBy;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceivePointDamage
//		Flags  -> (BlueprintAuthorityOnly, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
//		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     HitNormal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ShotFromDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceivePointDamage(float Damage, class UDamageType* DamageType, const struct FVector& HitLocation, const struct FVector& HitNormal, class UPrimitiveComponent* HitComponent, const struct FName& BoneName, const struct FVector& ShotFromDirection, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceivePointDamage");

	AActor_ReceivePointDamage_Params params {};
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;
	params.HitComponent = HitComponent;
	params.BoneName = BoneName;
	params.ShotFromDirection = ShotFromDirection;
	params.InstigatedBy = InstigatedBy;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37070
//		Name   -> Function Engine.Actor.ReceiveHit
//		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
//		class UPrimitiveComponent*                         MyComp                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSelfMoved                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     HitNormal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
void AActor::ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveHit");

	AActor_ReceiveHit_Params params {};
	params.MyComp = MyComp;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.bSelfMoved = bSelfMoved;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveEndPlay
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TEnumAsByte<Engine_EEndPlayReason>                 EndPlayReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceiveEndPlay(TEnumAsByte<Engine_EEndPlayReason> EndPlayReason)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveEndPlay");

	AActor_ReceiveEndPlay_Params params {};
	params.EndPlayReason = EndPlayReason;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveDestroyed
//		Flags  -> (Event, Public, BlueprintEvent)
void AActor::ReceiveDestroyed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveDestroyed");

	AActor_ReceiveDestroyed_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveBeginPlay
//		Flags  -> (Event, Public, BlueprintEvent)
void AActor::ReceiveBeginPlay()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveBeginPlay");

	AActor_ReceiveBeginPlay_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveAnyDamage
//		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
//		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceiveAnyDamage(float Damage, class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveAnyDamage");

	AActor_ReceiveAnyDamage_Params params {};
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.InstigatedBy = InstigatedBy;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveActorOnReleased
//		Flags  -> (Event, Public, BlueprintEvent)
void AActor::ReceiveActorOnReleased()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnReleased");

	AActor_ReceiveActorOnReleased_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveActorOnInputTouchLeave
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TEnumAsByte<InputCore_ETouchIndex>                 FingerIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceiveActorOnInputTouchLeave(TEnumAsByte<InputCore_ETouchIndex> FingerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchLeave");

	AActor_ReceiveActorOnInputTouchLeave_Params params {};
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveActorOnInputTouchEnter
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TEnumAsByte<InputCore_ETouchIndex>                 FingerIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceiveActorOnInputTouchEnter(TEnumAsByte<InputCore_ETouchIndex> FingerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchEnter");

	AActor_ReceiveActorOnInputTouchEnter_Params params {};
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveActorOnInputTouchEnd
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TEnumAsByte<InputCore_ETouchIndex>                 FingerIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceiveActorOnInputTouchEnd(TEnumAsByte<InputCore_ETouchIndex> FingerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchEnd");

	AActor_ReceiveActorOnInputTouchEnd_Params params {};
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveActorOnInputTouchBegin
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TEnumAsByte<InputCore_ETouchIndex>                 FingerIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceiveActorOnInputTouchBegin(TEnumAsByte<InputCore_ETouchIndex> FingerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchBegin");

	AActor_ReceiveActorOnInputTouchBegin_Params params {};
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveActorOnClicked
//		Flags  -> (Event, Public, BlueprintEvent)
void AActor::ReceiveActorOnClicked()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnClicked");

	AActor_ReceiveActorOnClicked_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveActorEndOverlap
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceiveActorEndOverlap(class AActor* OtherActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorEndOverlap");

	AActor_ReceiveActorEndOverlap_Params params {};
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveActorEndCursorOver
//		Flags  -> (Event, Public, BlueprintEvent)
void AActor::ReceiveActorEndCursorOver()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorEndCursorOver");

	AActor_ReceiveActorEndCursorOver_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveActorBeginOverlap
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::ReceiveActorBeginOverlap(class AActor* OtherActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorBeginOverlap");

	AActor_ReceiveActorBeginOverlap_Params params {};
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.ReceiveActorBeginCursorOver
//		Flags  -> (Event, Public, BlueprintEvent)
void AActor::ReceiveActorBeginCursorOver()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorBeginCursorOver");

	AActor_ReceiveActorBeginCursorOver_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A364C0
//		Name   -> Function Engine.Actor.OnRep_Role
//		Flags  -> (Native, Public)
void AActor::OnRep_Role()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_Role");

	AActor_OnRep_Role_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36480
//		Name   -> Function Engine.Actor.OnRep_ReplicateMovement
//		Flags  -> (Native, Public)
void AActor::OnRep_ReplicateMovement()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_ReplicateMovement");

	AActor_OnRep_ReplicateMovement_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A364A0
//		Name   -> Function Engine.Actor.OnRep_ReplicatedMovement
//		Flags  -> (Native, Public)
void AActor::OnRep_ReplicatedMovement()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_ReplicatedMovement");

	AActor_OnRep_ReplicatedMovement_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36400
//		Name   -> Function Engine.Actor.OnRep_Instigator
//		Flags  -> (Native, Public)
void AActor::OnRep_Instigator()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_Instigator");

	AActor_OnRep_Instigator_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A363E0
//		Name   -> Function Engine.Actor.OnRep_AttachmentReplication
//		Flags  -> (Native, Public)
void AActor::OnRep_AttachmentReplication()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_AttachmentReplication");

	AActor_OnRep_AttachmentReplication_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.Actor.OnEndPlayDynamicMulticastEvent__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate)
// Parameters:
//		class AActor*                                      EndPlayActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::OnEndPlayDynamicMulticastEvent__DelegateSignature(class AActor* EndPlayActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.Actor.OnEndPlayDynamicMulticastEvent__DelegateSignature");

	AActor_OnEndPlayDynamicMulticastEvent__DelegateSignature_Params params {};
	params.EndPlayActor = EndPlayActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.Actor.OnDestroyedDynamicMulticastEvent__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate)
// Parameters:
//		class AActor*                                      DeletedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::OnDestroyedDynamicMulticastEvent__DelegateSignature(class AActor* DeletedActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.Actor.OnDestroyedDynamicMulticastEvent__DelegateSignature");

	AActor_OnDestroyedDynamicMulticastEvent__DelegateSignature_Params params {};
	params.DeletedActor = DeletedActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36250
//		Name   -> Function Engine.Actor.MakeNoise
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		float                                              Loudness                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class APawn*                                       NoiseInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NoiseLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              MaxRange                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::MakeNoise(float Loudness, class APawn* NoiseInstigator, const struct FVector& NoiseLocation, float MaxRange, const struct FName& Tag)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.MakeNoise");

	AActor_MakeNoise_Params params {};
	params.Loudness = Loudness;
	params.NoiseInstigator = NoiseInstigator;
	params.NoiseLocation = NoiseLocation;
	params.MaxRange = MaxRange;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A361C0
//		Name   -> Function Engine.Actor.MakeMIDForMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          Parent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInstanceDynamic*                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInstanceDynamic* AActor::MakeMIDForMaterial(class UMaterialInterface* Parent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.MakeMIDForMaterial");

	AActor_MakeMIDForMaterial_Params params {};
	params.Parent = Parent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A35E20
//		Name   -> Function Engine.Actor.K2_TeleportTo
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     DestLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    DestRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::K2_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_TeleportTo");

	AActor_K2_TeleportTo_Params params {};
	params.DestLocation = DestLocation;
	params.DestRotation = DestRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A34DC0
//		Name   -> Function Engine.Actor.K2_SetActorTransform
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  NewTransform                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::K2_SetActorTransform(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorTransform");

	AActor_K2_SetActorTransform_Params params {};
	params.NewTransform = NewTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A34BC0
//		Name   -> Function Engine.Actor.K2_SetActorRelativeTransform
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  NewRelativeTransform                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::K2_SetActorRelativeTransform(const struct FTransform& NewRelativeTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeTransform");

	AActor_K2_SetActorRelativeTransform_Params params {};
	params.NewRelativeTransform = NewRelativeTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A34A10
//		Name   -> Function Engine.Actor.K2_SetActorRelativeRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    NewRelativeRotation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference, AdvancedDisplay)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void AActor::K2_SetActorRelativeRotation(const struct FRotator& NewRelativeRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeRotation");

	AActor_K2_SetActorRelativeRotation_Params params {};
	params.NewRelativeRotation = NewRelativeRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A34860
//		Name   -> Function Engine.Actor.K2_SetActorRelativeLocation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewRelativeLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::K2_SetActorRelativeLocation(const struct FVector& NewRelativeLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeLocation");

	AActor_K2_SetActorRelativeLocation_Params params {};
	params.NewRelativeLocation = NewRelativeLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A34680
//		Name   -> Function Engine.Actor.K2_SetActorLocationAndRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::K2_SetActorLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorLocationAndRotation");

	AActor_K2_SetActorLocationAndRotation_Params params {};
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A344D0
//		Name   -> Function Engine.Actor.K2_SetActorLocation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::K2_SetActorLocation(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorLocation");

	AActor_K2_SetActorLocation_Params params {};
	params.NewLocation = NewLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.K2_OnReset
//		Flags  -> (Event, Public, BlueprintEvent)
void AActor::K2_OnReset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnReset");

	AActor_K2_OnReset_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.K2_OnEndViewTarget
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class APlayerController*                           PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::K2_OnEndViewTarget(class APlayerController* PC)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnEndViewTarget");

	AActor_K2_OnEndViewTarget_Params params {};
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Actor.K2_OnBecomeViewTarget
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class APlayerController*                           PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::K2_OnBecomeViewTarget(class APlayerController* PC)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnBecomeViewTarget");

	AActor_K2_OnBecomeViewTarget_Params params {};
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A344A0
//		Name   -> Function Engine.Actor.K2_GetRootComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class USceneComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class USceneComponent* AActor::K2_GetRootComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetRootComponent");

	AActor_K2_GetRootComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A34310
//		Name   -> Function Engine.Actor.K2_GetActorRotation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator AActor::K2_GetActorRotation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetActorRotation");

	AActor_K2_GetActorRotation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A342D0
//		Name   -> Function Engine.Actor.K2_GetActorLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector AActor::K2_GetActorLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetActorLocation");

	AActor_K2_GetActorLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A341D0
//		Name   -> Function Engine.Actor.K2_DestroyComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UActorComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::K2_DestroyComponent(class UActorComponent* Component)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_DestroyComponent");

	AActor_K2_DestroyComponent_Params params {};
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A341B0
//		Name   -> Function Engine.Actor.K2_DestroyActor
//		Flags  -> (Native, Public, BlueprintCallable)
void AActor::K2_DestroyActor()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_DestroyActor");

	AActor_K2_DestroyActor_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A33F10
//		Name   -> Function Engine.Actor.K2_AttachRootComponentToActor
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      InParentActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EAttachLocation>                AttachLocationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bWeldSimulatedBodies                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::K2_AttachRootComponentToActor(class AActor* InParentActor, const struct FName& InSocketName, TEnumAsByte<Engine_EAttachLocation> AttachLocationType, bool bWeldSimulatedBodies)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachRootComponentToActor");

	AActor_K2_AttachRootComponentToActor_Params params {};
	params.InParentActor = InParentActor;
	params.InSocketName = InSocketName;
	params.AttachLocationType = AttachLocationType;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A33DC0
//		Name   -> Function Engine.Actor.K2_AttachRootComponentTo
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USceneComponent*                             InParent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EAttachLocation>                AttachLocationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bWeldSimulatedBodies                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::K2_AttachRootComponentTo(class USceneComponent* InParent, const struct FName& InSocketName, TEnumAsByte<Engine_EAttachLocation> AttachLocationType, bool bWeldSimulatedBodies)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachRootComponentTo");

	AActor_K2_AttachRootComponentTo_Params params {};
	params.InParent = InParent;
	params.InSocketName = InSocketName;
	params.AttachLocationType = AttachLocationType;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A32DA0
//		Name   -> Function Engine.Actor.K2_AddActorWorldTransform
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  DeltaTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::K2_AddActorWorldTransform(const struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldTransform");

	AActor_K2_AddActorWorldTransform_Params params {};
	params.DeltaTransform = DeltaTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A32BF0
//		Name   -> Function Engine.Actor.K2_AddActorWorldRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    DeltaRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference, AdvancedDisplay)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void AActor::K2_AddActorWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldRotation");

	AActor_K2_AddActorWorldRotation_Params params {};
	params.DeltaRotation = DeltaRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A32A40
//		Name   -> Function Engine.Actor.K2_AddActorWorldOffset
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     DeltaLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::K2_AddActorWorldOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldOffset");

	AActor_K2_AddActorWorldOffset_Params params {};
	params.DeltaLocation = DeltaLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A32840
//		Name   -> Function Engine.Actor.K2_AddActorLocalTransform
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  NewTransform                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::K2_AddActorLocalTransform(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalTransform");

	AActor_K2_AddActorLocalTransform_Params params {};
	params.NewTransform = NewTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A32690
//		Name   -> Function Engine.Actor.K2_AddActorLocalRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    DeltaRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference, AdvancedDisplay)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void AActor::K2_AddActorLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalRotation");

	AActor_K2_AddActorLocalRotation_Params params {};
	params.DeltaRotation = DeltaRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A324E0
//		Name   -> Function Engine.Actor.K2_AddActorLocalOffset
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     DeltaLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::K2_AddActorLocalOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalOffset");

	AActor_K2_AddActorLocalOffset_Params params {};
	params.DeltaLocation = DeltaLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A322F0
//		Name   -> Function Engine.Actor.IsOverlappingActor
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::IsOverlappingActor(class AActor* Other)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsOverlappingActor");

	AActor_IsOverlappingActor_Params params {};
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31FA0
//		Name   -> Function Engine.Actor.IsChildActor
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::IsChildActor()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsChildActor");

	AActor_IsChildActor_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31F10
//		Name   -> Function Engine.Actor.IsActorTickEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::IsActorTickEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsActorTickEnabled");

	AActor_IsActorTickEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31EE0
//		Name   -> Function Engine.Actor.IsActorBeingDestroyed
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::IsActorBeingDestroyed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsActorBeingDestroyed");

	AActor_IsActorBeingDestroyed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31E80
//		Name   -> Function Engine.Actor.HasNetOwner
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::HasNetOwner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.HasNetOwner");

	AActor_HasNetOwner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31E20
//		Name   -> Function Engine.Actor.HasAuthority
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::HasAuthority()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.HasAuthority");

	AActor_HasAuthority_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31C70
//		Name   -> Function Engine.Actor.GetVerticalDistanceTo
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      OtherActor                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float AActor::GetVerticalDistanceTo(class AActor* OtherActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetVerticalDistanceTo");

	AActor_GetVerticalDistanceTo_Params params {};
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31C30
//		Name   -> Function Engine.Actor.GetVelocity
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector AActor::GetVelocity()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetVelocity");

	AActor_GetVelocity_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31AB0
//		Name   -> Function Engine.Actor.GetTransform
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform AActor::GetTransform()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetTransform");

	AActor_GetTransform_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31820
//		Name   -> Function Engine.Actor.GetTickableWhenPaused
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::GetTickableWhenPaused()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetTickableWhenPaused");

	AActor_GetTickableWhenPaused_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31400
//		Name   -> Function Engine.Actor.GetPxActorCapacityForPhysXAggregate
//		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
unsigned char AActor::GetPxActorCapacityForPhysXAggregate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetPxActorCapacityForPhysXAggregate");

	AActor_GetPxActorCapacityForPhysXAggregate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A312F0
//		Name   -> Function Engine.Actor.GetParentActor
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* AActor::GetParentActor()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetParentActor");

	AActor_GetParentActor_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31280
//		Name   -> Function Engine.Actor.GetOwner
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* AActor::GetOwner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOwner");

	AActor_GetOwner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A311D0
//		Name   -> Function Engine.Actor.GetOverlappingComponents
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<class UPrimitiveComponent*>                 OverlappingComponents                                      (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
void AActor::GetOverlappingComponents(TArray<class UPrimitiveComponent*>* OverlappingComponents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOverlappingComponents");

	AActor_GetOverlappingComponents_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OverlappingComponents != nullptr)
		*OverlappingComponents = params.OverlappingComponents;

}


// Function:
//		Offset -> 0x02A310D0
//		Name   -> Function Engine.Actor.GetOverlappingActors
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<class AActor*>                              OverlappingActors                                          (Parm, OutParm, ZeroConstructor)
//		class UClass*                                      ClassFilter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::GetOverlappingActors(TArray<class AActor*>* OverlappingActors, class UClass* ClassFilter)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOverlappingActors");

	AActor_GetOverlappingActors_Params params {};
	params.ClassFilter = ClassFilter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OverlappingActors != nullptr)
		*OverlappingActors = params.OverlappingActors;

}


// Function:
//		Offset -> 0x02A30F70
//		Name   -> Function Engine.Actor.GetLifeSpan
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float AActor::GetLifeSpan()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetLifeSpan");

	AActor_GetLifeSpan_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A30EE0
//		Name   -> Function Engine.Actor.GetInterfaceImplementer
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      InterfaceClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class UObject*                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UObject* AActor::GetInterfaceImplementer(class UClass* InterfaceClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInterfaceImplementer");

	AActor_GetInterfaceImplementer_Params params {};
	params.InterfaceClass = InterfaceClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A30EB0
//		Name   -> Function Engine.Actor.GetInstigatorController
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AController*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AController* AActor::GetInstigatorController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInstigatorController");

	AActor_GetInstigatorController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A30E80
//		Name   -> Function Engine.Actor.GetInstigator
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APawn*                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APawn* AActor::GetInstigator()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInstigator");

	AActor_GetInstigator_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A30C40
//		Name   -> Function Engine.Actor.GetInputVectorAxisValue
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        InputAxisKey                                               (ConstParm, Parm)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector AActor::GetInputVectorAxisValue(const struct FKey& InputAxisKey)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputVectorAxisValue");

	AActor_GetInputVectorAxisValue_Params params {};
	params.InputAxisKey = InputAxisKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A306B0
//		Name   -> Function Engine.Actor.GetInputAxisValue
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       InputAxisName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float AActor::GetInputAxisValue(const struct FName& InputAxisName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputAxisValue");

	AActor_GetInputAxisValue_Params params {};
	params.InputAxisName = InputAxisName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A305B0
//		Name   -> Function Engine.Actor.GetInputAxisKeyValue
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        InputAxisKey                                               (ConstParm, Parm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float AActor::GetInputAxisKeyValue(const struct FKey& InputAxisKey)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputAxisKeyValue");

	AActor_GetInputAxisKeyValue_Params params {};
	params.InputAxisKey = InputAxisKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A302F0
//		Name   -> Function Engine.Actor.GetHorizontalDotProductTo
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      OtherActor                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float AActor::GetHorizontalDotProductTo(class AActor* OtherActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetHorizontalDotProductTo");

	AActor_GetHorizontalDotProductTo_Params params {};
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A30250
//		Name   -> Function Engine.Actor.GetHorizontalDistanceTo
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      OtherActor                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float AActor::GetHorizontalDistanceTo(class AActor* OtherActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetHorizontalDistanceTo");

	AActor_GetHorizontalDistanceTo_Params params {};
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F6D0
//		Name   -> Function Engine.Actor.GetDotProductTo
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      OtherActor                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float AActor::GetDotProductTo(class AActor* OtherActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetDotProductTo");

	AActor_GetDotProductTo_Params params {};
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F630
//		Name   -> Function Engine.Actor.GetDistanceTo
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      OtherActor                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float AActor::GetDistanceTo(class AActor* OtherActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetDistanceTo");

	AActor_GetDistanceTo_Params params {};
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2EF70
//		Name   -> Function Engine.Actor.GetComponentsByTag
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UClass*                                      ComponentClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		struct FName                                       Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class UActorComponent*>                     ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference)
TArray<class UActorComponent*> AActor::GetComponentsByTag(class UClass* ComponentClass, const struct FName& Tag)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentsByTag");

	AActor_GetComponentsByTag_Params params {};
	params.ComponentClass = ComponentClass;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2EE80
//		Name   -> Function Engine.Actor.GetComponentsByClass
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UClass*                                      ComponentClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		TArray<class UActorComponent*>                     ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference)
TArray<class UActorComponent*> AActor::GetComponentsByClass(class UClass* ComponentClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentsByClass");

	AActor_GetComponentsByClass_Params params {};
	params.ComponentClass = ComponentClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2ED40
//		Name   -> Function Engine.Actor.GetComponentInterfacesByClass
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<class UActorComponent*>                     OutInterfaces                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		class UClass*                                      InterfaceClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void AActor::GetComponentInterfacesByClass(TArray<class UActorComponent*>* OutInterfaces, class UClass* InterfaceClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentInterfacesByClass");

	AActor_GetComponentInterfacesByClass_Params params {};
	params.InterfaceClass = InterfaceClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutInterfaces != nullptr)
		*OutInterfaces = params.OutInterfaces;

}


// Function:
//		Offset -> 0x02A2ECB0
//		Name   -> Function Engine.Actor.GetComponentInterfaceByClass
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      InterfaceClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class UActorComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UActorComponent* AActor::GetComponentInterfaceByClass(class UClass* InterfaceClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentInterfaceByClass");

	AActor_GetComponentInterfaceByClass_Params params {};
	params.InterfaceClass = InterfaceClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2EC10
//		Name   -> Function Engine.Actor.GetComponentByClass
//		Flags  -> (Native, Public)
// Parameters:
//		class UClass*                                      ComponentClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class UActorComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UActorComponent* AActor::GetComponentByClass(class UClass* ComponentClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentByClass");

	AActor_GetComponentByClass_Params params {};
	params.ComponentClass = ComponentClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E900
//		Name   -> Function Engine.Actor.GetAttachParentActor
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* AActor::GetAttachParentActor()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachParentActor");

	AActor_GetAttachParentActor_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E7F0
//		Name   -> Function Engine.Actor.GetActorUpVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector AActor::GetActorUpVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorUpVector");

	AActor_GetActorUpVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E7C0
//		Name   -> Function Engine.Actor.GetActorTimeDilation
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float AActor::GetActorTimeDilation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorTimeDilation");

	AActor_GetActorTimeDilation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E780
//		Name   -> Function Engine.Actor.GetActorScale3D
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector AActor::GetActorScale3D()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorScale3D");

	AActor_GetActorScale3D_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E740
//		Name   -> Function Engine.Actor.GetActorRightVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector AActor::GetActorRightVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorRightVector");

	AActor_GetActorRightVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E700
//		Name   -> Function Engine.Actor.GetActorRelativeScale3D
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector AActor::GetActorRelativeScale3D()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorRelativeScale3D");

	AActor_GetActorRelativeScale3D_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E6C0
//		Name   -> Function Engine.Actor.GetActorForwardVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector AActor::GetActorForwardVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorForwardVector");

	AActor_GetActorForwardVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E5D0
//		Name   -> Function Engine.Actor.GetActorEyesViewPoint
//		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::GetActorEyesViewPoint(struct FVector* OutLocation, struct FRotator* OutRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorEyesViewPoint");

	AActor_GetActorEyesViewPoint_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutLocation != nullptr)
		*OutLocation = params.OutLocation;
	if (OutRotation != nullptr)
		*OutRotation = params.OutRotation;

}


// Function:
//		Offset -> 0x02A2E5A0
//		Name   -> Function Engine.Actor.GetActorEnableCollision
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::GetActorEnableCollision()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorEnableCollision");

	AActor_GetActorEnableCollision_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E470
//		Name   -> Function Engine.Actor.GetActorBounds
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               bOnlyCollidingComponents                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Origin                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     BoxExtent                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::GetActorBounds(bool bOnlyCollidingComponents, struct FVector* Origin, struct FVector* BoxExtent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorBounds");

	AActor_GetActorBounds_Params params {};
	params.bOnlyCollidingComponents = bOnlyCollidingComponents;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Origin != nullptr)
		*Origin = params.Origin;
	if (BoxExtent != nullptr)
		*BoxExtent = params.BoxExtent;

}


// Function:
//		Offset -> 0x02A2E450
//		Name   -> Function Engine.Actor.ForceNetUpdate
//		Flags  -> (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void AActor::ForceNetUpdate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ForceNetUpdate");

	AActor_ForceNetUpdate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2E3F0
//		Name   -> Function Engine.Actor.FlushNetDormancy
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::FlushNetDormancy()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.FlushNetDormancy");

	AActor_FlushNetDormancy_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E0C0
//		Name   -> Function Engine.Actor.EnableInput
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::EnableInput(class APlayerController* PlayerController)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.EnableInput");

	AActor_EnableInput_Params params {};
	params.PlayerController = PlayerController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2DF70
//		Name   -> Function Engine.Actor.DisableInput
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::DisableInput(class APlayerController* PlayerController)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.DisableInput");

	AActor_DisableInput_Params params {};
	params.PlayerController = PlayerController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2DEE0
//		Name   -> Function Engine.Actor.DetachRootComponentFromParent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bMaintainWorldPosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::DetachRootComponentFromParent(bool bMaintainWorldPosition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.DetachRootComponentFromParent");

	AActor_DetachRootComponentFromParent_Params params {};
	params.bMaintainWorldPosition = bMaintainWorldPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2AB80
//		Name   -> Function Engine.Actor.AttachRootComponentToNoReplication
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USceneComponent*                             InParent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EAttachLocation>                AttachLocationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bWeldSimulatedBodies                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::AttachRootComponentToNoReplication(class USceneComponent* InParent, const struct FName& InSocketName, TEnumAsByte<Engine_EAttachLocation> AttachLocationType, bool bWeldSimulatedBodies)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.AttachRootComponentToNoReplication");

	AActor_AttachRootComponentToNoReplication_Params params {};
	params.InParent = InParent;
	params.InSocketName = InSocketName;
	params.AttachLocationType = AttachLocationType;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2AA70
//		Name   -> Function Engine.Actor.AttachActorToActorNoReplication
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      InParentActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bWeldSimulatedBodies                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AActor::AttachActorToActorNoReplication(class AActor* InParentActor, const struct FName& InSocketName, bool bWeldSimulatedBodies)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.AttachActorToActorNoReplication");

	AActor_AttachActorToActorNoReplication_Params params {};
	params.InParentActor = InParentActor;
	params.InSocketName = InSocketName;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2A810
//		Name   -> Function Engine.Actor.AddTickPrerequisiteComponent
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UActorComponent*                             PrerequisiteComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddTickPrerequisiteComponent");

	AActor_AddTickPrerequisiteComponent_Params params {};
	params.PrerequisiteComponent = PrerequisiteComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2A6F0
//		Name   -> Function Engine.Actor.AddTickPrerequisiteActor
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      PrerequisiteActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AActor::AddTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddTickPrerequisiteActor");

	AActor_AddTickPrerequisiteActor_Params params {};
	params.PrerequisiteActor = PrerequisiteActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2A1F0
//		Name   -> Function Engine.Actor.AddComponent
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       TemplateName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bManualAttachment                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FTransform                                  RelativeTransform                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		class UObject*                                     ComponentTemplateContext                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UActorComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UActorComponent* AActor::AddComponent(const struct FName& TemplateName, bool bManualAttachment, const struct FTransform& RelativeTransform, class UObject* ComponentTemplateContext)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddComponent");

	AActor_AddComponent_Params params {};
	params.TemplateName = TemplateName;
	params.bManualAttachment = bManualAttachment;
	params.RelativeTransform = RelativeTransform;
	params.ComponentTemplateContext = ComponentTemplateContext;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2A0C0
//		Name   -> Function Engine.Actor.ActorHasTag
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AActor::ActorHasTag(const struct FName& Tag)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorHasTag");

	AActor_ActorHasTag_Params params {};
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void AActor::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(Owner, AActor);
	READ_PTR_FULL(InputComponent, UInputComponent);
	READ_PTR_FULL(Instigator, APawn);
	READ_PTR_FULL(RootComponent, USceneComponent);
}

void AActor::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(Owner);
	DELE_PTR_FULL(InputComponent);
	DELE_PTR_FULL(Instigator);
	DELE_PTR_FULL(RootComponent);
}

void UDataAsset::AfterRead()
{
	UObject::AfterRead();

}

void UDataAsset::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UBlueprintFunctionLibrary::AfterRead()
{
	UObject::AfterRead();

}

void UBlueprintFunctionLibrary::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02A3AE80
//		Name   -> Function Engine.SceneComponent.ToggleVisibility
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::ToggleVisibility(bool bPropagateToChildren)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.ToggleVisibility");

	USceneComponent_ToggleVisibility_Params params {};
	params.bPropagateToChildren = bPropagateToChildren;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A5A0
//		Name   -> Function Engine.SceneComponent.SnapTo
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USceneComponent*                             InParent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USceneComponent::SnapTo(class USceneComponent* InParent, const struct FName& InSocketName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SnapTo");

	USceneComponent_SnapTo_Params params {};
	params.InParent = InParent;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A450
//		Name   -> Function Engine.SceneComponent.SharesBasis
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class USceneComponent*                             Other                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USceneComponent::SharesBasis(class USceneComponent* Other)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SharesBasis");

	USceneComponent_SharesBasis_Params params {};
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A3A3C0
//		Name   -> Function Engine.SceneComponent.SetWorldScale3D
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewScale                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::SetWorldScale3D(const struct FVector& NewScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetWorldScale3D");

	USceneComponent_SetWorldScale3D_Params params {};
	params.NewScale = NewScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A1E0
//		Name   -> Function Engine.SceneComponent.SetVisibility
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewVisibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::SetVisibility(bool bNewVisibility, bool bPropagateToChildren)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetVisibility");

	USceneComponent_SetVisibility_Params params {};
	params.bNewVisibility = bNewVisibility;
	params.bPropagateToChildren = bPropagateToChildren;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39B00
//		Name   -> Function Engine.SceneComponent.SetRelativeScale3D
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewScale3D                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::SetRelativeScale3D(const struct FVector& NewScale3D)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetRelativeScale3D");

	USceneComponent_SetRelativeScale3D_Params params {};
	params.NewScale3D = NewScale3D;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39330
//		Name   -> Function Engine.SceneComponent.SetHiddenInGame
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               NewHidden                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::SetHiddenInGame(bool NewHidden, bool bPropagateToChildren)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetHiddenInGame");

	USceneComponent_SetHiddenInGame_Params params {};
	params.NewHidden = NewHidden;
	params.bPropagateToChildren = bPropagateToChildren;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A384C0
//		Name   -> Function Engine.SceneComponent.SetAbsolute
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewAbsoluteLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bNewAbsoluteRotation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bNewAbsoluteScale                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::SetAbsolute(bool bNewAbsoluteLocation, bool bNewAbsoluteRotation, bool bNewAbsoluteScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetAbsolute");

	USceneComponent_SetAbsolute_Params params {};
	params.bNewAbsoluteLocation = bNewAbsoluteLocation;
	params.bNewAbsoluteRotation = bNewAbsoluteRotation;
	params.bNewAbsoluteScale = bNewAbsoluteScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37720
//		Name   -> Function Engine.SceneComponent.ResetRelativeTransform
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USceneComponent::ResetRelativeTransform()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.ResetRelativeTransform");

	USceneComponent_ResetRelativeTransform_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36500
//		Name   -> Function Engine.SceneComponent.OnRep_Visibility
//		Flags  -> (Final, Native, Private)
// Parameters:
//		bool                                               OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::OnRep_Visibility(bool OldValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_Visibility");

	USceneComponent_OnRep_Visibility_Params params {};
	params.OldValue = OldValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A364E0
//		Name   -> Function Engine.SceneComponent.OnRep_Transform
//		Flags  -> (Final, Native, Private)
void USceneComponent::OnRep_Transform()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_Transform");

	USceneComponent_OnRep_Transform_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A35F10
//		Name   -> Function Engine.SceneComponent.K2_TryGetCachedSocketVelocity
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       SocketName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     OutVelocity                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USceneComponent::K2_TryGetCachedSocketVelocity(const struct FName& SocketName, struct FVector* OutVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_TryGetCachedSocketVelocity");

	USceneComponent_K2_TryGetCachedSocketVelocity_Params params {};
	params.SocketName = SocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutVelocity != nullptr)
		*OutVelocity = params.OutVelocity;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A35C20
//		Name   -> Function Engine.SceneComponent.K2_SetWorldTransform
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  NewTransform                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_SetWorldTransform(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldTransform");

	USceneComponent_K2_SetWorldTransform_Params params {};
	params.NewTransform = NewTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A35A70
//		Name   -> Function Engine.SceneComponent.K2_SetWorldRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference, AdvancedDisplay)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void USceneComponent::K2_SetWorldRotation(const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldRotation");

	USceneComponent_K2_SetWorldRotation_Params params {};
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A358A0
//		Name   -> Function Engine.SceneComponent.K2_SetWorldLocationAndRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_SetWorldLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldLocationAndRotation");

	USceneComponent_K2_SetWorldLocationAndRotation_Params params {};
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A356F0
//		Name   -> Function Engine.SceneComponent.K2_SetWorldLocation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_SetWorldLocation(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldLocation");

	USceneComponent_K2_SetWorldLocation_Params params {};
	params.NewLocation = NewLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A354F0
//		Name   -> Function Engine.SceneComponent.K2_SetRelativeTransform
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  NewTransform                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_SetRelativeTransform(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeTransform");

	USceneComponent_K2_SetRelativeTransform_Params params {};
	params.NewTransform = NewTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A35340
//		Name   -> Function Engine.SceneComponent.K2_SetRelativeRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference, AdvancedDisplay)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void USceneComponent::K2_SetRelativeRotation(const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeRotation");

	USceneComponent_K2_SetRelativeRotation_Params params {};
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A35170
//		Name   -> Function Engine.SceneComponent.K2_SetRelativeLocationAndRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_SetRelativeLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeLocationAndRotation");

	USceneComponent_K2_SetRelativeLocationAndRotation_Params params {};
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A34FC0
//		Name   -> Function Engine.SceneComponent.K2_SetRelativeLocation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_SetRelativeLocation(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeLocation");

	USceneComponent_K2_SetRelativeLocation_Params params {};
	params.NewLocation = NewLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A34410
//		Name   -> Function Engine.SceneComponent.K2_GetComponentToWorld
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform USceneComponent::K2_GetComponentToWorld()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentToWorld");

	USceneComponent_K2_GetComponentToWorld_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A343D0
//		Name   -> Function Engine.SceneComponent.K2_GetComponentScale
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USceneComponent::K2_GetComponentScale()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentScale");

	USceneComponent_K2_GetComponentScale_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A34390
//		Name   -> Function Engine.SceneComponent.K2_GetComponentRotation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator USceneComponent::K2_GetComponentRotation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentRotation");

	USceneComponent_K2_GetComponentRotation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A34350
//		Name   -> Function Engine.SceneComponent.K2_GetComponentLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USceneComponent::K2_GetComponentLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentLocation");

	USceneComponent_K2_GetComponentLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A34060
//		Name   -> Function Engine.SceneComponent.K2_AttachTo
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USceneComponent*                             InParent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EAttachLocation>                AttachType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bWeldSimulatedBodies                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_AttachTo(class USceneComponent* InParent, const struct FName& InSocketName, TEnumAsByte<Engine_EAttachLocation> AttachType, bool bWeldSimulatedBodies)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AttachTo");

	USceneComponent_K2_AttachTo_Params params {};
	params.InParent = InParent;
	params.InSocketName = InSocketName;
	params.AttachType = AttachType;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A33BC0
//		Name   -> Function Engine.SceneComponent.K2_AddWorldTransform
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  DeltaTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_AddWorldTransform(const struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldTransform");

	USceneComponent_K2_AddWorldTransform_Params params {};
	params.DeltaTransform = DeltaTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A33A10
//		Name   -> Function Engine.SceneComponent.K2_AddWorldRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    DeltaRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference, AdvancedDisplay)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void USceneComponent::K2_AddWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldRotation");

	USceneComponent_K2_AddWorldRotation_Params params {};
	params.DeltaRotation = DeltaRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A33860
//		Name   -> Function Engine.SceneComponent.K2_AddWorldOffset
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     DeltaLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_AddWorldOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldOffset");

	USceneComponent_K2_AddWorldOffset_Params params {};
	params.DeltaLocation = DeltaLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A336B0
//		Name   -> Function Engine.SceneComponent.K2_AddRelativeRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    DeltaRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference, AdvancedDisplay)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void USceneComponent::K2_AddRelativeRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddRelativeRotation");

	USceneComponent_K2_AddRelativeRotation_Params params {};
	params.DeltaRotation = DeltaRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A33500
//		Name   -> Function Engine.SceneComponent.K2_AddRelativeLocation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     DeltaLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_AddRelativeLocation(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddRelativeLocation");

	USceneComponent_K2_AddRelativeLocation_Params params {};
	params.DeltaLocation = DeltaLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A33300
//		Name   -> Function Engine.SceneComponent.K2_AddLocalTransform
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  DeltaTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_AddLocalTransform(const struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalTransform");

	USceneComponent_K2_AddLocalTransform_Params params {};
	params.DeltaTransform = DeltaTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A33150
//		Name   -> Function Engine.SceneComponent.K2_AddLocalRotation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    DeltaRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference, AdvancedDisplay)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void USceneComponent::K2_AddLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalRotation");

	USceneComponent_K2_AddLocalRotation_Params params {};
	params.DeltaRotation = DeltaRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A32FA0
//		Name   -> Function Engine.SceneComponent.K2_AddLocalOffset
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     DeltaLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepHitResult                                             (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::K2_AddLocalOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalOffset");

	USceneComponent_K2_AddLocalOffset_Params params {};
	params.DeltaLocation = DeltaLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

}


// Function:
//		Offset -> 0x02A324B0
//		Name   -> Function Engine.SceneComponent.IsVisible
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USceneComponent::IsVisible()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsVisible");

	USceneComponent_IsVisible_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A32410
//		Name   -> Function Engine.SceneComponent.IsSimulatingPhysics
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USceneComponent::IsSimulatingPhysics(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsSimulatingPhysics");

	USceneComponent_IsSimulatingPhysics_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31F40
//		Name   -> Function Engine.SceneComponent.IsAnySimulatingPhysics
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USceneComponent::IsAnySimulatingPhysics()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsAnySimulatingPhysics");

	USceneComponent_IsAnySimulatingPhysics_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31B10
//		Name   -> Function Engine.SceneComponent.GetUpVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USceneComponent::GetUpVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetUpVector");

	USceneComponent_GetUpVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A316D0
//		Name   -> Function Engine.SceneComponent.GetSocketTransform
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ERelativeTransformSpace>        TransformSpace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform USceneComponent::GetSocketTransform(const struct FName& InSocketName, TEnumAsByte<Engine_ERelativeTransformSpace> TransformSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketTransform");

	USceneComponent_GetSocketTransform_Params params {};
	params.InSocketName = InSocketName;
	params.TransformSpace = TransformSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31620
//		Name   -> Function Engine.SceneComponent.GetSocketRotation
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator USceneComponent::GetSocketRotation(const struct FName& InSocketName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketRotation");

	USceneComponent_GetSocketRotation_Params params {};
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31580
//		Name   -> Function Engine.SceneComponent.GetSocketQuaternion
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FQuat                                       ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FQuat USceneComponent::GetSocketQuaternion(const struct FName& InSocketName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketQuaternion");

	USceneComponent_GetSocketQuaternion_Params params {};
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A314D0
//		Name   -> Function Engine.SceneComponent.GetSocketLocation
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USceneComponent::GetSocketLocation(const struct FName& InSocketName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketLocation");

	USceneComponent_GetSocketLocation_Params params {};
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31490
//		Name   -> Function Engine.SceneComponent.GetRightVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USceneComponent::GetRightVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetRightVector");

	USceneComponent_GetRightVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31430
//		Name   -> Function Engine.SceneComponent.GetRelativeTransform
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform USceneComponent::GetRelativeTransform()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetRelativeTransform");

	USceneComponent_GetRelativeTransform_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A313D0
//		Name   -> Function Engine.SceneComponent.GetPhysicsVolume
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APhysicsVolume*                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APhysicsVolume* USceneComponent::GetPhysicsVolume()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetPhysicsVolume");

	USceneComponent_GetPhysicsVolume_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31320
//		Name   -> Function Engine.SceneComponent.GetParentComponents
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<class USceneComponent*>                     Parents                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
void USceneComponent::GetParentComponents(TArray<class USceneComponent*>* Parents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetParentComponents");

	USceneComponent_GetParentComponents_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Parents != nullptr)
		*Parents = params.Parents;

}


// Function:
//		Offset -> 0x02A310A0
//		Name   -> Function Engine.SceneComponent.GetNumChildrenComponents
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int USceneComponent::GetNumChildrenComponents()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetNumChildrenComponents");

	USceneComponent_GetNumChildrenComponents_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F880
//		Name   -> Function Engine.SceneComponent.GetForwardVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USceneComponent::GetForwardVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetForwardVector");

	USceneComponent_GetForwardVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2EE40
//		Name   -> Function Engine.SceneComponent.GetComponentVelocity
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USceneComponent::GetComponentVelocity()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetComponentVelocity");

	USceneComponent_GetComponentVelocity_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2EAF0
//		Name   -> Function Engine.SceneComponent.GetChildrenComponents
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               bIncludeAllDescendants                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class USceneComponent*>                     Children                                                   (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
void USceneComponent::GetChildrenComponents(bool bIncludeAllDescendants, TArray<class USceneComponent*>* Children)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetChildrenComponents");

	USceneComponent_GetChildrenComponents_Params params {};
	params.bIncludeAllDescendants = bIncludeAllDescendants;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Children != nullptr)
		*Children = params.Children;

}


// Function:
//		Offset -> 0x02A2EA60
//		Name   -> Function Engine.SceneComponent.GetChildComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ChildIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USceneComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class USceneComponent* USceneComponent::GetChildComponent(int ChildIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetChildComponent");

	USceneComponent_GetChildComponent_Params params {};
	params.ChildIndex = ChildIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E930
//		Name   -> Function Engine.SceneComponent.GetAttachSocketName
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName USceneComponent::GetAttachSocketName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAttachSocketName");

	USceneComponent_GetAttachSocketName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E8D0
//		Name   -> Function Engine.SceneComponent.GetAttachParent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class USceneComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class USceneComponent* USceneComponent::GetAttachParent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAttachParent");

	USceneComponent_GetAttachParent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E950
//		Name   -> Function Engine.SceneComponent.GetAttachedBasisTransform
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform USceneComponent::GetAttachedBasisTransform()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAttachedBasisTransform");

	USceneComponent_GetAttachedBasisTransform_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E830
//		Name   -> Function Engine.SceneComponent.GetAllSocketNames
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<struct FName>                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FName> USceneComponent::GetAllSocketNames()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAllSocketNames");

	USceneComponent_GetAllSocketNames_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E000
//		Name   -> Function Engine.SceneComponent.DoesSocketExist
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USceneComponent::DoesSocketExist(const struct FName& InSocketName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.DoesSocketExist");

	USceneComponent_DoesSocketExist_Params params {};
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2DE10
//		Name   -> Function Engine.SceneComponent.DetachFromParent
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bMaintainWorldPosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bCallModify                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USceneComponent::DetachFromParent(bool bMaintainWorldPosition, bool bCallModify)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.DetachFromParent");

	USceneComponent_DetachFromParent_Params params {};
	params.bMaintainWorldPosition = bMaintainWorldPosition;
	params.bCallModify = bCallModify;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void USceneComponent::AfterRead()
{
	UActorComponent::AfterRead();

	READ_PTR_FULL(AttachParent, USceneComponent);
}

void USceneComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

	DELE_PTR_FULL(AttachParent);
}

// Function:
//		Offset -> 0x02B40770
//		Name   -> Function Engine.Pawn.SpawnDefaultController
//		Flags  -> (Native, Public, BlueprintCallable)
void APawn::SpawnDefaultController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.SpawnDefaultController");

	APawn_SpawnDefaultController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B3C0
//		Name   -> Function Engine.Pawn.SetCanAffectNavigationGeneration
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APawn::SetCanAffectNavigationGeneration(bool bNewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.SetCanAffectNavigationGeneration");

	APawn_SetCanAffectNavigationGeneration_Params params {};
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Pawn.ReceiveUnpossessed
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class AController*                                 OldController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APawn::ReceiveUnpossessed(class AController* OldController)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ReceiveUnpossessed");

	APawn_ReceiveUnpossessed_Params params {};
	params.OldController = OldController;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Pawn.ReceivePossessed
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class AController*                                 NewController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APawn::ReceivePossessed(class AController* NewController)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ReceivePossessed");

	APawn_ReceivePossessed_Params params {};
	params.NewController = NewController;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B386E0
//		Name   -> Function Engine.Pawn.PawnMakeNoise
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		float                                              Loudness                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NoiseLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUseNoiseMakerLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class AActor*                                      NoiseMaker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APawn::PawnMakeNoise(float Loudness, const struct FVector& NoiseLocation, bool bUseNoiseMakerLocation, class AActor* NoiseMaker)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.PawnMakeNoise");

	APawn_PawnMakeNoise_Params params {};
	params.Loudness = Loudness;
	params.NoiseLocation = NoiseLocation;
	params.bUseNoiseMakerLocation = bUseNoiseMakerLocation;
	params.NoiseMaker = NoiseMaker;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B382C0
//		Name   -> Function Engine.Pawn.OnRep_PlayerState
//		Flags  -> (Native, Public)
void APawn::OnRep_PlayerState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.OnRep_PlayerState");

	APawn_OnRep_PlayerState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38200
//		Name   -> Function Engine.Pawn.OnRep_Controller
//		Flags  -> (Native, Public)
void APawn::OnRep_Controller()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.OnRep_Controller");

	APawn_OnRep_Controller_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37960
//		Name   -> Function Engine.Pawn.LaunchPawn
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     LaunchVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bXYOverride                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bZOverride                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APawn::LaunchPawn(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.LaunchPawn");

	APawn_LaunchPawn_Params params {};
	params.LaunchVelocity = LaunchVelocity;
	params.bXYOverride = bXYOverride;
	params.bZOverride = bZOverride;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B373D0
//		Name   -> Function Engine.Pawn.K2_GetMovementInputVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector APawn::K2_GetMovementInputVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.K2_GetMovementInputVector");

	APawn_K2_GetMovementInputVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36E80
//		Name   -> Function Engine.Pawn.IsMoveInputIgnored
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APawn::IsMoveInputIgnored()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsMoveInputIgnored");

	APawn_IsMoveInputIgnored_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36E20
//		Name   -> Function Engine.Pawn.IsLocallyControlled
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APawn::IsLocallyControlled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsLocallyControlled");

	APawn_IsLocallyControlled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36C40
//		Name   -> Function Engine.Pawn.IsControlled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APawn::IsControlled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsControlled");

	APawn_IsControlled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33CE0
//		Name   -> Function Engine.Pawn.GetPendingMovementInputVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector APawn::GetPendingMovementInputVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetPendingMovementInputVector");

	APawn_GetPendingMovementInputVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33150
//		Name   -> Function Engine.Pawn.GetNavAgentLocation
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector APawn::GetNavAgentLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetNavAgentLocation");

	APawn_GetNavAgentLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33080
//		Name   -> Function Engine.Pawn.GetMovementComponent
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UPawnMovementComponent*                      ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UPawnMovementComponent* APawn::GetMovementComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetMovementComponent");

	APawn_GetMovementComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33000
//		Name   -> Function Engine.Pawn.GetMovementBaseActor
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APawn*                                       Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* APawn::STATIC_GetMovementBaseActor(class APawn* Pawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetMovementBaseActor");

	APawn_GetMovementBaseActor_Params params {};
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32650
//		Name   -> Function Engine.Pawn.GetLastMovementInputVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector APawn::GetLastMovementInputVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetLastMovementInputVector");

	APawn_GetLastMovementInputVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31E20
//		Name   -> Function Engine.Pawn.GetControlRotation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator APawn::GetControlRotation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetControlRotation");

	APawn_GetControlRotation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31E60
//		Name   -> Function Engine.Pawn.GetController
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AController*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AController* APawn::GetController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetController");

	APawn_GetController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31840
//		Name   -> Function Engine.Pawn.GetBaseAimRotation
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator APawn::GetBaseAimRotation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetBaseAimRotation");

	APawn_GetBaseAimRotation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F8B0
//		Name   -> Function Engine.Pawn.DetachFromControllerPendingDestroy
//		Flags  -> (Native, Public, BlueprintCallable)
void APawn::DetachFromControllerPendingDestroy()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.DetachFromControllerPendingDestroy");

	APawn_DetachFromControllerPendingDestroy_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2F1A0
//		Name   -> Function Engine.Pawn.ConsumeMovementInputVector
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector APawn::ConsumeMovementInputVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ConsumeMovementInputVector");

	APawn_ConsumeMovementInputVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2E060
//		Name   -> Function Engine.Pawn.AddMovementInput
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     WorldDirection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ScaleValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APawn::AddMovementInput(const struct FVector& WorldDirection, float ScaleValue, bool bForce)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddMovementInput");

	APawn_AddMovementInput_Params params {};
	params.WorldDirection = WorldDirection;
	params.ScaleValue = ScaleValue;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2D2D0
//		Name   -> Function Engine.Pawn.AddControllerYawInput
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APawn::AddControllerYawInput(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerYawInput");

	APawn_AddControllerYawInput_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2D250
//		Name   -> Function Engine.Pawn.AddControllerRollInput
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APawn::AddControllerRollInput(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerRollInput");

	APawn_AddControllerRollInput_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2D1D0
//		Name   -> Function Engine.Pawn.AddControllerPitchInput
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APawn::AddControllerPitchInput(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerPitchInput");

	APawn_AddControllerPitchInput_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void APawn::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(AIControllerClass, UClass);
	READ_PTR_FULL(PlayerState, APlayerState);
	READ_PTR_FULL(LastHitBy, AController);
	READ_PTR_FULL(Controller, AController);
}

void APawn::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(AIControllerClass);
	DELE_PTR_FULL(PlayerState);
	DELE_PTR_FULL(LastHitBy);
	DELE_PTR_FULL(Controller);
}

// Function:
//		Offset -> 0x02B40FD0
//		Name   -> Function Engine.Character.UnCrouch
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bClientSimulation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ACharacter::UnCrouch(bool bClientSimulation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.UnCrouch");

	ACharacter_UnCrouch_Params params {};
	params.bClientSimulation = bClientSimulation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40990
//		Name   -> Function Engine.Character.StopJumping
//		Flags  -> (Native, Public, BlueprintCallable)
void ACharacter::StopJumping()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.StopJumping");

	ACharacter_StopJumping_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40900
//		Name   -> Function Engine.Character.StopAnimMontage
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ACharacter::StopAnimMontage(class UAnimMontage* AnimMontage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.StopAnimMontage");

	ACharacter_StopAnimMontage_Params params {};
	params.AnimMontage = AnimMontage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F4C0
//		Name   -> Function Engine.Character.SetReplicateMovement
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bInReplicateMovement                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ACharacter::SetReplicateMovement(bool bInReplicateMovement)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.SetReplicateMovement");

	ACharacter_SetReplicateMovement_Params params {};
	params.bInReplicateMovement = bInReplicateMovement;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38A60
//		Name   -> Function Engine.Character.PlayAnimMontage
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       StartSectionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float ACharacter::PlayAnimMontage(class UAnimMontage* AnimMontage, float InPlayRate, const struct FName& StartSectionName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.PlayAnimMontage");

	ACharacter_PlayAnimMontage_Params params {};
	params.AnimMontage = AnimMontage;
	params.InPlayRate = InPlayRate;
	params.StartSectionName = StartSectionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B38520
//		Name   -> Function Engine.Character.OnWalkingOffLedge
//		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
//		struct FVector                                     PreviousFloorImpactNormal                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     PreviousFloorContactNormal                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     PreviousLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              TimeDelta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ACharacter::OnWalkingOffLedge(const struct FVector& PreviousFloorImpactNormal, const struct FVector& PreviousFloorContactNormal, const struct FVector& PreviousLocation, float TimeDelta)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.OnWalkingOffLedge");

	ACharacter_OnWalkingOffLedge_Params params {};
	params.PreviousFloorImpactNormal = PreviousFloorImpactNormal;
	params.PreviousFloorContactNormal = PreviousFloorContactNormal;
	params.PreviousLocation = PreviousLocation;
	params.TimeDelta = TimeDelta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B383A0
//		Name   -> Function Engine.Character.OnRep_RootMotion
//		Flags  -> (Final, Native, Public)
void ACharacter::OnRep_RootMotion()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_RootMotion");

	ACharacter_OnRep_RootMotion_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B382E0
//		Name   -> Function Engine.Character.OnRep_ReplicatedBasedMovement
//		Flags  -> (Native, Public)
void ACharacter::OnRep_ReplicatedBasedMovement()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_ReplicatedBasedMovement");

	ACharacter_OnRep_ReplicatedBasedMovement_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38260
//		Name   -> Function Engine.Character.OnRep_IsCrouched
//		Flags  -> (Native, Public)
void ACharacter::OnRep_IsCrouched()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_IsCrouched");

	ACharacter_OnRep_IsCrouched_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Character.OnLaunched
//		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
//		struct FVector                                     LaunchVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bXYOverride                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bZOverride                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ACharacter::OnLaunched(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.OnLaunched");

	ACharacter_OnLaunched_Params params {};
	params.LaunchVelocity = LaunchVelocity;
	params.bXYOverride = bXYOverride;
	params.bZOverride = bZOverride;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Character.OnLanded
//		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
void ACharacter::OnLanded(const struct FHitResult& Hit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.OnLanded");

	ACharacter_OnLanded_Params params {};
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B380D0
//		Name   -> Function Engine.Character.OnJumped
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void ACharacter::OnJumped()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.OnJumped");

	ACharacter_OnJumped_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37840
//		Name   -> Function Engine.Character.LaunchCharacter
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     LaunchVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bXYOverride                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bZOverride                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ACharacter::LaunchCharacter(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.LaunchCharacter");

	ACharacter_LaunchCharacter_Params params {};
	params.LaunchVelocity = LaunchVelocity;
	params.bXYOverride = bXYOverride;
	params.bZOverride = bZOverride;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Character.K2_UpdateCustomMovement
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ACharacter::K2_UpdateCustomMovement(float DeltaTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_UpdateCustomMovement");

	ACharacter_K2_UpdateCustomMovement_Params params {};
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Character.K2_OnStartCrouch
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              HalfHeightAdjust                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScaledHalfHeightAdjust                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ACharacter::K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnStartCrouch");

	ACharacter_K2_OnStartCrouch_Params params {};
	params.HalfHeightAdjust = HalfHeightAdjust;
	params.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Character.K2_OnMovementModeChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TEnumAsByte<Engine_EMovementMode>                  PrevMovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EMovementMode>                  NewMovementMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      PrevCustomMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      NewCustomMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ACharacter::K2_OnMovementModeChanged(TEnumAsByte<Engine_EMovementMode> PrevMovementMode, TEnumAsByte<Engine_EMovementMode> NewMovementMode, unsigned char PrevCustomMode, unsigned char NewCustomMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnMovementModeChanged");

	ACharacter_K2_OnMovementModeChanged_Params params {};
	params.PrevMovementMode = PrevMovementMode;
	params.NewMovementMode = NewMovementMode;
	params.PrevCustomMode = PrevCustomMode;
	params.NewCustomMode = NewCustomMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Character.K2_OnEndCrouch
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              HalfHeightAdjust                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScaledHalfHeightAdjust                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ACharacter::K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnEndCrouch");

	ACharacter_K2_OnEndCrouch_Params params {};
	params.HalfHeightAdjust = HalfHeightAdjust;
	params.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37260
//		Name   -> Function Engine.Character.Jump
//		Flags  -> (Native, Public, BlueprintCallable)
void ACharacter::Jump()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.Jump");

	ACharacter_Jump_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37110
//		Name   -> Function Engine.Character.IsPlayingRootMotion
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ACharacter::IsPlayingRootMotion()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.IsPlayingRootMotion");

	ACharacter_IsPlayingRootMotion_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B370E0
//		Name   -> Function Engine.Character.IsPlayingNetworkedRootMotionMontage
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ACharacter::IsPlayingNetworkedRootMotionMontage()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.IsPlayingNetworkedRootMotionMontage");

	ACharacter_IsPlayingNetworkedRootMotionMontage_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36DF0
//		Name   -> Function Engine.Character.IsJumpProvidingForce
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ACharacter::IsJumpProvidingForce()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.IsJumpProvidingForce");

	ACharacter_IsJumpProvidingForce_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31E90
//		Name   -> Function Engine.Character.GetCurrentMontage
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimMontage*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UAnimMontage* ACharacter::GetCurrentMontage()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.GetCurrentMontage");

	ACharacter_GetCurrentMontage_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F650
//		Name   -> Function Engine.Character.Crouch
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bClientSimulation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ACharacter::Crouch(bool bClientSimulation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.Crouch");

	ACharacter_Crouch_Params params {};
	params.bClientSimulation = bClientSimulation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2EF30
//		Name   -> Function Engine.Character.ClientCheatWalk
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void ACharacter::ClientCheatWalk()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatWalk");

	ACharacter_ClientCheatWalk_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2EF10
//		Name   -> Function Engine.Character.ClientCheatGhost
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void ACharacter::ClientCheatGhost()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatGhost");

	ACharacter_ClientCheatGhost_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2EEF0
//		Name   -> Function Engine.Character.ClientCheatFly
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void ACharacter::ClientCheatFly()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatFly");

	ACharacter_ClientCheatFly_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2EB40
//		Name   -> Function Engine.Character.CanJumpInternal
//		Flags  -> (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ACharacter::CanJumpInternal()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.CanJumpInternal");

	ACharacter_CanJumpInternal_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2EB10
//		Name   -> Function Engine.Character.CanJump
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ACharacter::CanJump()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Character.CanJump");

	ACharacter_CanJump_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void ACharacter::AfterRead()
{
	APawn::AfterRead();

	READ_PTR_FULL(Mesh, USkeletalMeshComponent);
	READ_PTR_FULL(CharacterMovement, UCharacterMovementComponent);
	READ_PTR_FULL(CapsuleComponent, UCapsuleComponent);
}

void ACharacter::BeforeDelete()
{
	APawn::BeforeDelete();

	DELE_PTR_FULL(Mesh);
	DELE_PTR_FULL(CharacterMovement);
	DELE_PTR_FULL(CapsuleComponent);
}

// Function:
//		Offset -> 0x02C4D440
//		Name   -> Function Engine.AnimInstance.UnlockAIResources
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bUnlockMovement                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               UnlockAILogic                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAnimInstance::UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.UnlockAIResources");

	UAnimInstance_UnlockAIResources_Params params {};
	params.bUnlockMovement = bUnlockMovement;
	params.UnlockAILogic = UnlockAILogic;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4D2F0
//		Name   -> Function Engine.AnimInstance.TryGetPawnOwner
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APawn*                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APawn* UAnimInstance::TryGetPawnOwner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.TryGetPawnOwner");

	UAnimInstance_TryGetPawnOwner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4D170
//		Name   -> Function Engine.AnimInstance.StopSlotAnimation
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InBlendOutTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       SlotNodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::StopSlotAnimation(float InBlendOutTime, const struct FName& SlotNodeName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.StopSlotAnimation");

	UAnimInstance_StopSlotAnimation_Params params {};
	params.InBlendOutTime = InBlendOutTime;
	params.SlotNodeName = SlotNodeName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48A30
//		Name   -> Function Engine.AnimInstance.SetMorphTarget
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       MorphTargetName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::SetMorphTarget(const struct FName& MorphTargetName, float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetMorphTarget");

	UAnimInstance_SetMorphTarget_Params params {};
	params.MorphTargetName = MorphTargetName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C42AA0
//		Name   -> Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimSequenceBase*                           Asset                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       SlotNodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendInTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendOutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                LoopCount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendOutTriggerTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UAnimMontage*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UAnimMontage* UAnimInstance::PlaySlotAnimationAsDynamicMontage(class UAnimSequenceBase* Asset, const struct FName& SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int LoopCount, float BlendOutTriggerTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage");

	UAnimInstance_PlaySlotAnimationAsDynamicMontage_Params params {};
	params.Asset = Asset;
	params.SlotNodeName = SlotNodeName;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.InPlayRate = InPlayRate;
	params.LoopCount = LoopCount;
	params.BlendOutTriggerTime = BlendOutTriggerTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C428E0
//		Name   -> Function Engine.AnimInstance.PlaySlotAnimation
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimSequenceBase*                           Asset                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       SlotNodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendInTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendOutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                LoopCount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::PlaySlotAnimation(class UAnimSequenceBase* Asset, const struct FName& SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int LoopCount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.PlaySlotAnimation");

	UAnimInstance_PlaySlotAnimation_Params params {};
	params.Asset = Asset;
	params.SlotNodeName = SlotNodeName;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.InPlayRate = InPlayRate;
	params.LoopCount = LoopCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C41D20
//		Name   -> Function Engine.AnimInstance.Montage_Stop
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InBlendOutTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::Montage_Stop(float InBlendOutTime, class UAnimMontage* Montage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Stop");

	UAnimInstance_Montage_Stop_Params params {};
	params.InBlendOutTime = InBlendOutTime;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41C50
//		Name   -> Function Engine.AnimInstance.Montage_SetPlayRate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              NewPlayRate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::Montage_SetPlayRate(class UAnimMontage* Montage, float NewPlayRate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetPlayRate");

	UAnimInstance_Montage_SetPlayRate_Params params {};
	params.Montage = Montage;
	params.NewPlayRate = NewPlayRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41B50
//		Name   -> Function Engine.AnimInstance.Montage_SetNextSection
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       SectionNameToChange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       NextSection                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::Montage_SetNextSection(const struct FName& SectionNameToChange, const struct FName& NextSection, class UAnimMontage* Montage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetNextSection");

	UAnimInstance_Montage_SetNextSection_Params params {};
	params.SectionNameToChange = SectionNameToChange;
	params.NextSection = NextSection;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41AD0
//		Name   -> Function Engine.AnimInstance.Montage_Resume
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimMontage*                                Montage                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::Montage_Resume(class UAnimMontage* Montage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Resume");

	UAnimInstance_Montage_Resume_Params params {};
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41A00
//		Name   -> Function Engine.AnimInstance.Montage_Play
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimMontage*                                MontageToPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::Montage_Play(class UAnimMontage* MontageToPlay, float InPlayRate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Play");

	UAnimInstance_Montage_Play_Params params {};
	params.MontageToPlay = MontageToPlay;
	params.InPlayRate = InPlayRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C41980
//		Name   -> Function Engine.AnimInstance.Montage_Pause
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::Montage_Pause(class UAnimMontage* Montage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Pause");

	UAnimInstance_Montage_Pause_Params params {};
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C418C0
//		Name   -> Function Engine.AnimInstance.Montage_JumpToSectionsEnd
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       SectionName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::Montage_JumpToSectionsEnd(const struct FName& SectionName, class UAnimMontage* Montage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_JumpToSectionsEnd");

	UAnimInstance_Montage_JumpToSectionsEnd_Params params {};
	params.SectionName = SectionName;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41800
//		Name   -> Function Engine.AnimInstance.Montage_JumpToSection
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       SectionName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::Montage_JumpToSection(const struct FName& SectionName, class UAnimMontage* Montage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_JumpToSection");

	UAnimInstance_Montage_JumpToSection_Params params {};
	params.SectionName = SectionName;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41770
//		Name   -> Function Engine.AnimInstance.Montage_IsPlaying
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UAnimInstance::Montage_IsPlaying(class UAnimMontage* Montage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_IsPlaying");

	UAnimInstance_Montage_IsPlaying_Params params {};
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C416E0
//		Name   -> Function Engine.AnimInstance.Montage_IsActive
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UAnimInstance::Montage_IsActive(class UAnimMontage* Montage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_IsActive");

	UAnimInstance_Montage_IsActive_Params params {};
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C41650
//		Name   -> Function Engine.AnimInstance.Montage_GetCurrentSection
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName UAnimInstance::Montage_GetCurrentSection(class UAnimMontage* Montage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetCurrentSection");

	UAnimInstance_Montage_GetCurrentSection_Params params {};
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C41460
//		Name   -> Function Engine.AnimInstance.LockAIResources
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bLockMovement                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               LockAILogic                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAnimInstance::LockAIResources(bool bLockMovement, bool LockAILogic)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.LockAIResources");

	UAnimInstance_LockAIResources_Params params {};
	params.bLockMovement = bLockMovement;
	params.LockAILogic = LockAILogic;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40DE0
//		Name   -> Function Engine.AnimInstance.IsPlayingSlotAnimation
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UAnimSequenceBase*                           Asset                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       SlotNodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UAnimInstance::IsPlayingSlotAnimation(class UAnimSequenceBase* Asset, const struct FName& SlotNodeName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsPlayingSlotAnimation");

	UAnimInstance_IsPlayingSlotAnimation_Params params {};
	params.Asset = Asset;
	params.SlotNodeName = SlotNodeName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40180
//		Name   -> Function Engine.AnimInstance.GetSyncGroupPosition
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetSyncGroupPosition(const struct FName& Name)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetSyncGroupPosition");

	UAnimInstance_GetSyncGroupPosition_Params params {};
	params.Name = Name;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FEB0
//		Name   -> Function Engine.AnimInstance.GetStateWeight
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StateIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetStateWeight(int MachineIndex, int StateIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetStateWeight");

	UAnimInstance_GetStateWeight_Params params {};
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F8D0
//		Name   -> Function Engine.AnimInstance.GetRelevantAnimTimeRemainingFraction
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StateIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetRelevantAnimTimeRemainingFraction(int MachineIndex, int StateIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeRemainingFraction");

	UAnimInstance_GetRelevantAnimTimeRemainingFraction_Params params {};
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F810
//		Name   -> Function Engine.AnimInstance.GetRelevantAnimTimeRemaining
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StateIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetRelevantAnimTimeRemaining(int MachineIndex, int StateIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeRemaining");

	UAnimInstance_GetRelevantAnimTimeRemaining_Params params {};
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F750
//		Name   -> Function Engine.AnimInstance.GetRelevantAnimTimeFraction
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StateIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetRelevantAnimTimeFraction(int MachineIndex, int StateIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeFraction");

	UAnimInstance_GetRelevantAnimTimeFraction_Params params {};
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F690
//		Name   -> Function Engine.AnimInstance.GetRelevantAnimTime
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StateIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetRelevantAnimTime(int MachineIndex, int StateIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTime");

	UAnimInstance_GetRelevantAnimTime_Params params {};
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F5D0
//		Name   -> Function Engine.AnimInstance.GetRelevantAnimLength
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StateIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetRelevantAnimLength(int MachineIndex, int StateIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimLength");

	UAnimInstance_GetRelevantAnimLength_Params params {};
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F0A0
//		Name   -> Function Engine.AnimInstance.GetOwningComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class USkeletalMeshComponent*                      ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class USkeletalMeshComponent* UAnimInstance::GetOwningComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetOwningComponent");

	UAnimInstance_GetOwningComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3EFE0
//		Name   -> Function Engine.AnimInstance.GetOwningActor
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* UAnimInstance::GetOwningActor()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetOwningActor");

	UAnimInstance_GetOwningActor_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3EBB0
//		Name   -> Function Engine.AnimInstance.GetMaxPlayingAnimTimeRemaining
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StateIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetMaxPlayingAnimTimeRemaining(int MachineIndex, int StateIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetMaxPlayingAnimTimeRemaining");

	UAnimInstance_GetMaxPlayingAnimTimeRemaining_Params params {};
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3EAB0
//		Name   -> Function Engine.AnimInstance.GetMaxAnimTimeRemaining
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StateIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetMaxAnimTimeRemaining(int MachineIndex, int StateIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetMaxAnimTimeRemaining");

	UAnimInstance_GetMaxAnimTimeRemaining_Params params {};
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3E450
//		Name   -> Function Engine.AnimInstance.GetInstanceTransitionTimeElapsedFraction
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                TransitionIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetInstanceTransitionTimeElapsedFraction(int MachineIndex, int TransitionIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionTimeElapsedFraction");

	UAnimInstance_GetInstanceTransitionTimeElapsedFraction_Params params {};
	params.MachineIndex = MachineIndex;
	params.TransitionIndex = TransitionIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3E390
//		Name   -> Function Engine.AnimInstance.GetInstanceTransitionTimeElapsed
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                TransitionIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetInstanceTransitionTimeElapsed(int MachineIndex, int TransitionIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionTimeElapsed");

	UAnimInstance_GetInstanceTransitionTimeElapsed_Params params {};
	params.MachineIndex = MachineIndex;
	params.TransitionIndex = TransitionIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3E2D0
//		Name   -> Function Engine.AnimInstance.GetInstanceTransitionCrossfadeDuration
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                TransitionIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetInstanceTransitionCrossfadeDuration(int MachineIndex, int TransitionIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionCrossfadeDuration");

	UAnimInstance_GetInstanceTransitionCrossfadeDuration_Params params {};
	params.MachineIndex = MachineIndex;
	params.TransitionIndex = TransitionIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3E0A0
//		Name   -> Function Engine.AnimInstance.GetInstanceStateWeight
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StateIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetInstanceStateWeight(int MachineIndex, int StateIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceStateWeight");

	UAnimInstance_GetInstanceStateWeight_Params params {};
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3E010
//		Name   -> Function Engine.AnimInstance.GetInstanceCurrentStateElapsedTime
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetInstanceCurrentStateElapsedTime(int MachineIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceCurrentStateElapsedTime");

	UAnimInstance_GetInstanceCurrentStateElapsedTime_Params params {};
	params.MachineIndex = MachineIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DF50
//		Name   -> Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEndFraction
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                AssetPlayerIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetInstanceAssetPlayerTimeFromEndFraction(int AssetPlayerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEndFraction");

	UAnimInstance_GetInstanceAssetPlayerTimeFromEndFraction_Params params {};
	params.AssetPlayerIndex = AssetPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DEC0
//		Name   -> Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEnd
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                AssetPlayerIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetInstanceAssetPlayerTimeFromEnd(int AssetPlayerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEnd");

	UAnimInstance_GetInstanceAssetPlayerTimeFromEnd_Params params {};
	params.AssetPlayerIndex = AssetPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DE30
//		Name   -> Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFraction
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                AssetPlayerIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetInstanceAssetPlayerTimeFraction(int AssetPlayerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFraction");

	UAnimInstance_GetInstanceAssetPlayerTimeFraction_Params params {};
	params.AssetPlayerIndex = AssetPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DDA0
//		Name   -> Function Engine.AnimInstance.GetInstanceAssetPlayerTime
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                AssetPlayerIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetInstanceAssetPlayerTime(int AssetPlayerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTime");

	UAnimInstance_GetInstanceAssetPlayerTime_Params params {};
	params.AssetPlayerIndex = AssetPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DD10
//		Name   -> Function Engine.AnimInstance.GetInstanceAssetPlayerLength
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                AssetPlayerIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetInstanceAssetPlayerLength(int AssetPlayerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerLength");

	UAnimInstance_GetInstanceAssetPlayerLength_Params params {};
	params.AssetPlayerIndex = AssetPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D620
//		Name   -> Function Engine.AnimInstance.GetCurveValue
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       CurveName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetCurveValue(const struct FName& CurveName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurveValue");

	UAnimInstance_GetCurveValue_Params params {};
	params.CurveName = CurveName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D590
//		Name   -> Function Engine.AnimInstance.GetCurrentStateName
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName UAnimInstance::GetCurrentStateName(int MachineIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurrentStateName");

	UAnimInstance_GetCurrentStateName_Params params {};
	params.MachineIndex = MachineIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D500
//		Name   -> Function Engine.AnimInstance.GetCurrentStateElapsedTime
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetCurrentStateElapsedTime(int MachineIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurrentStateElapsedTime");

	UAnimInstance_GetCurrentStateElapsedTime_Params params {};
	params.MachineIndex = MachineIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3C830
//		Name   -> Function Engine.AnimInstance.GetAnimAssetPlayerTimeFromEndFraction
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UAnimationAsset*                             AnimAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              CurrentTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::STATIC_GetAnimAssetPlayerTimeFromEndFraction(class UAnimationAsset* AnimAsset, float CurrentTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAnimAssetPlayerTimeFromEndFraction");

	UAnimInstance_GetAnimAssetPlayerTimeFromEndFraction_Params params {};
	params.AnimAsset = AnimAsset;
	params.CurrentTime = CurrentTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3C760
//		Name   -> Function Engine.AnimInstance.GetAnimAssetPlayerTimeFromEnd
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UAnimationAsset*                             AnimAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              CurrentTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::GetAnimAssetPlayerTimeFromEnd(class UAnimationAsset* AnimAsset, float CurrentTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAnimAssetPlayerTimeFromEnd");

	UAnimInstance_GetAnimAssetPlayerTimeFromEnd_Params params {};
	params.AnimAsset = AnimAsset;
	params.CurrentTime = CurrentTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3C690
//		Name   -> Function Engine.AnimInstance.GetAnimAssetPlayerTimeFraction
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UAnimationAsset*                             AnimAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              CurrentTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::STATIC_GetAnimAssetPlayerTimeFraction(class UAnimationAsset* AnimAsset, float CurrentTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAnimAssetPlayerTimeFraction");

	UAnimInstance_GetAnimAssetPlayerTimeFraction_Params params {};
	params.AnimAsset = AnimAsset;
	params.CurrentTime = CurrentTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3C600
//		Name   -> Function Engine.AnimInstance.GetAnimAssetPlayerLength
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UAnimationAsset*                             AnimAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::STATIC_GetAnimAssetPlayerLength(class UAnimationAsset* AnimAsset)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAnimAssetPlayerLength");

	UAnimInstance_GetAnimAssetPlayerLength_Params params {};
	params.AnimAsset = AnimAsset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3A8D0
//		Name   -> Function Engine.AnimInstance.ClearMorphTargets
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UAnimInstance::ClearMorphTargets()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.ClearMorphTargets");

	UAnimInstance_ClearMorphTargets_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3A5D0
//		Name   -> Function Engine.AnimInstance.CalculateDirection
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Velocity                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    BaseRotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimInstance::CalculateDirection(const struct FVector& Velocity, const struct FRotator& BaseRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.CalculateDirection");

	UAnimInstance_CalculateDirection_Params params {};
	params.Velocity = Velocity;
	params.BaseRotation = BaseRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.AnimInstance.BlueprintUpdateAnimation
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              DeltaTimeX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::BlueprintUpdateAnimation(float DeltaTimeX)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintUpdateAnimation");

	UAnimInstance_BlueprintUpdateAnimation_Params params {};
	params.DeltaTimeX = DeltaTimeX;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.AnimInstance.BlueprintUninitializeAnimation
//		Flags  -> (Event, Public, BlueprintEvent)
void UAnimInstance::BlueprintUninitializeAnimation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintUninitializeAnimation");

	UAnimInstance_BlueprintUninitializeAnimation_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.AnimInstance.BlueprintPostEvaluateAnimation
//		Flags  -> (Event, Public, BlueprintEvent)
void UAnimInstance::BlueprintPostEvaluateAnimation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintPostEvaluateAnimation");

	UAnimInstance_BlueprintPostEvaluateAnimation_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.AnimInstance.BlueprintInitializeAnimation
//		Flags  -> (Event, Public, BlueprintEvent)
void UAnimInstance::BlueprintInitializeAnimation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintInitializeAnimation");

	UAnimInstance_BlueprintInitializeAnimation_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C38500
//		Name   -> Function Engine.AnimInstance.AnimNotify_Sound
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class UAnimNotify*                                 Notify                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimInstance::AnimNotify_Sound(class UAnimNotify* Notify)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.AnimNotify_Sound");

	UAnimInstance_AnimNotify_Sound_Params params {};
	params.Notify = Notify;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UAnimInstance::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(CurrentSkeleton, USkeleton);
}

void UAnimInstance::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(CurrentSkeleton);
}

// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.AnimNotify.Received_Notify
//		Flags  -> (Event, Public, BlueprintEvent, Const)
// Parameters:
//		class USkeletalMeshComponent*                      MeshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UAnimSequenceBase*                           Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UAnimNotify::Received_Notify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimNotify.Received_Notify");

	UAnimNotify_Received_Notify_Params params {};
	params.MeshComp = MeshComp;
	params.Animation = Animation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3ED30
//		Name   -> Function Engine.AnimNotify.GetNotifyName
//		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UAnimNotify::GetNotifyName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimNotify.GetNotifyName");

	UAnimNotify_GetNotifyName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UAnimNotify::AfterRead()
{
	UObject::AfterRead();

}

void UAnimNotify::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.AnimNotifyState.Received_NotifyTick
//		Flags  -> (Event, Public, BlueprintEvent, Const)
// Parameters:
//		class USkeletalMeshComponent*                      MeshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UAnimSequenceBase*                           Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              FrameDeltaTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UAnimNotifyState::Received_NotifyTick(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float FrameDeltaTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyTick");

	UAnimNotifyState_Received_NotifyTick_Params params {};
	params.MeshComp = MeshComp;
	params.Animation = Animation;
	params.FrameDeltaTime = FrameDeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.AnimNotifyState.Received_NotifyEnd
//		Flags  -> (Event, Public, BlueprintEvent, Const)
// Parameters:
//		class USkeletalMeshComponent*                      MeshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UAnimSequenceBase*                           Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UAnimNotifyState::Received_NotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyEnd");

	UAnimNotifyState_Received_NotifyEnd_Params params {};
	params.MeshComp = MeshComp;
	params.Animation = Animation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.AnimNotifyState.Received_NotifyBegin
//		Flags  -> (Event, Public, BlueprintEvent, Const)
// Parameters:
//		class USkeletalMeshComponent*                      MeshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UAnimSequenceBase*                           Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TotalDuration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UAnimNotifyState::Received_NotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyBegin");

	UAnimNotifyState_Received_NotifyBegin_Params params {};
	params.MeshComp = MeshComp;
	params.Animation = Animation;
	params.TotalDuration = TotalDuration;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3EDD0
//		Name   -> Function Engine.AnimNotifyState.GetNotifyName
//		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UAnimNotifyState::GetNotifyName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.GetNotifyName");

	UAnimNotifyState_GetNotifyName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UAnimNotifyState::AfterRead()
{
	UObject::AfterRead();

}

void UAnimNotifyState::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UAnimNotifyState_TimedParticleEffect::AfterRead()
{
	UAnimNotifyState::AfterRead();

	READ_PTR_FULL(PSTemplate, UParticleSystem);
}

void UAnimNotifyState_TimedParticleEffect::BeforeDelete()
{
	UAnimNotifyState::BeforeDelete();

	DELE_PTR_FULL(PSTemplate);
}

void UParticleModule::AfterRead()
{
	UObject::AfterRead();

}

void UParticleModule::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UParticleModuleSizeBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleSizeBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleSize::AfterRead()
{
	UParticleModuleSizeBase::AfterRead();

}

void UParticleModuleSize::BeforeDelete()
{
	UParticleModuleSizeBase::BeforeDelete();

}

void UParticleModuleSize_Seeded::AfterRead()
{
	UParticleModuleSize::AfterRead();

}

void UParticleModuleSize_Seeded::BeforeDelete()
{
	UParticleModuleSize::BeforeDelete();

}

void UParticleModuleSizeMultiplyLife::AfterRead()
{
	UParticleModuleSizeBase::AfterRead();

}

void UParticleModuleSizeMultiplyLife::BeforeDelete()
{
	UParticleModuleSizeBase::BeforeDelete();

}

// Function:
//		Offset -> 0x02C43330
//		Name   -> Function Engine.CameraComponent.ProjectWorldLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     WorldLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FIntPoint                                   ViewDimensions                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UCameraComponent::ProjectWorldLocation(const struct FVector& WorldLocation, const struct FIntPoint& ViewDimensions)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.ProjectWorldLocation");

	UCameraComponent_ProjectWorldLocation_Params params {};
	params.WorldLocation = WorldLocation;
	params.ViewDimensions = ViewDimensions;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D1F0
//		Name   -> Function Engine.CameraComponent.GetCameraView
//		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FMinimalViewInfo                            DesiredView                                                (Parm, OutParm)
void UCameraComponent::GetCameraView(float DeltaTime, struct FMinimalViewInfo* DesiredView)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.GetCameraView");

	UCameraComponent_GetCameraView_Params params {};
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (DesiredView != nullptr)
		*DesiredView = params.DesiredView;

}


// Function:
//		Offset -> 0x02C38000
//		Name   -> Function Engine.CameraComponent.AddOrUpdateBlendable
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InWeight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCameraComponent::AddOrUpdateBlendable(float InWeight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.AddOrUpdateBlendable");

	UCameraComponent_AddOrUpdateBlendable_Params params {};
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UCameraComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UCameraComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02B409B0
//		Name   -> Function Engine.MovementComponent.StopMovementImmediately
//		Flags  -> (Native, Public, BlueprintCallable)
void UMovementComponent::StopMovementImmediately()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.StopMovementImmediately");

	UMovementComponent_StopMovementImmediately_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40750
//		Name   -> Function Engine.MovementComponent.SnapUpdatedComponentToPlane
//		Flags  -> (Native, Public, BlueprintCallable)
void UMovementComponent::SnapUpdatedComponentToPlane()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SnapUpdatedComponentToPlane");

	UMovementComponent_SnapUpdatedComponentToPlane_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3FFD0
//		Name   -> Function Engine.MovementComponent.SetUpdatedComponent
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class USceneComponent*                             NewUpdatedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UMovementComponent::SetUpdatedComponent(class USceneComponent* NewUpdatedComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetUpdatedComponent");

	UMovementComponent_SetUpdatedComponent_Params params {};
	params.NewUpdatedComponent = NewUpdatedComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F070
//		Name   -> Function Engine.MovementComponent.SetPlaneConstraintOrigin
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     PlaneOrigin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UMovementComponent::SetPlaneConstraintOrigin(const struct FVector& PlaneOrigin)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintOrigin");

	UMovementComponent_SetPlaneConstraintOrigin_Params params {};
	params.PlaneOrigin = PlaneOrigin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3EFE0
//		Name   -> Function Engine.MovementComponent.SetPlaneConstraintNormal
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     PlaneNormal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UMovementComponent::SetPlaneConstraintNormal(const struct FVector& PlaneNormal)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintNormal");

	UMovementComponent_SetPlaneConstraintNormal_Params params {};
	params.PlaneNormal = PlaneNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3EF00
//		Name   -> Function Engine.MovementComponent.SetPlaneConstraintFromVectors
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Forward                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Up                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UMovementComponent::SetPlaneConstraintFromVectors(const struct FVector& Forward, const struct FVector& Up)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintFromVectors");

	UMovementComponent_SetPlaneConstraintFromVectors_Params params {};
	params.Forward = Forward;
	params.Up = Up;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3EE70
//		Name   -> Function Engine.MovementComponent.SetPlaneConstraintEnabled
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UMovementComponent::SetPlaneConstraintEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintEnabled");

	UMovementComponent_SetPlaneConstraintEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3EDF0
//		Name   -> Function Engine.MovementComponent.SetPlaneConstraintAxisSetting
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EPlaneConstraintAxisSetting>    NewAxisSetting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UMovementComponent::SetPlaneConstraintAxisSetting(TEnumAsByte<Engine_EPlaneConstraintAxisSetting> NewAxisSetting)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintAxisSetting");

	UMovementComponent_SetPlaneConstraintAxisSetting_Params params {};
	params.NewAxisSetting = NewAxisSetting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38850
//		Name   -> Function Engine.MovementComponent.PhysicsVolumeChanged
//		Flags  -> (Native, Public)
// Parameters:
//		class APhysicsVolume*                              NewVolume                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UMovementComponent::PhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.PhysicsVolumeChanged");

	UMovementComponent_PhysicsVolumeChanged_Params params {};
	params.NewVolume = NewVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37660
//		Name   -> Function Engine.MovementComponent.K2_MoveUpdatedComponent
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Delta                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bTeleport                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UMovementComponent::K2_MoveUpdatedComponent(const struct FVector& Delta, const struct FRotator& NewRotation, struct FHitResult* OutHit, bool bSweep, bool bTeleport)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_MoveUpdatedComponent");

	UMovementComponent_K2_MoveUpdatedComponent_Params params {};
	params.Delta = Delta;
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B37390
//		Name   -> Function Engine.MovementComponent.K2_GetModifiedMaxSpeed
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UMovementComponent::K2_GetModifiedMaxSpeed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_GetModifiedMaxSpeed");

	UMovementComponent_K2_GetModifiedMaxSpeed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B37350
//		Name   -> Function Engine.MovementComponent.K2_GetMaxSpeedModifier
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UMovementComponent::K2_GetMaxSpeedModifier()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_GetMaxSpeedModifier");

	UMovementComponent_K2_GetMaxSpeedModifier_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36CD0
//		Name   -> Function Engine.MovementComponent.IsExceedingMaxSpeed
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              MaxSpeed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UMovementComponent::IsExceedingMaxSpeed(float MaxSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.IsExceedingMaxSpeed");

	UMovementComponent_IsExceedingMaxSpeed_Params params {};
	params.MaxSpeed = MaxSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34010
//		Name   -> Function Engine.MovementComponent.GetPlaneConstraintOrigin
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor)
struct FVector UMovementComponent::GetPlaneConstraintOrigin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintOrigin");

	UMovementComponent_GetPlaneConstraintOrigin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33FD0
//		Name   -> Function Engine.MovementComponent.GetPlaneConstraintNormal
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor)
struct FVector UMovementComponent::GetPlaneConstraintNormal()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintNormal");

	UMovementComponent_GetPlaneConstraintNormal_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33FB0
//		Name   -> Function Engine.MovementComponent.GetPlaneConstraintAxisSetting
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_EPlaneConstraintAxisSetting>    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
TEnumAsByte<Engine_EPlaneConstraintAxisSetting> UMovementComponent::GetPlaneConstraintAxisSetting()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintAxisSetting");

	UMovementComponent_GetPlaneConstraintAxisSetting_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33F80
//		Name   -> Function Engine.MovementComponent.GetPhysicsVolume
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APhysicsVolume*                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APhysicsVolume* UMovementComponent::GetPhysicsVolume()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPhysicsVolume");

	UMovementComponent_GetPhysicsVolume_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32F20
//		Name   -> Function Engine.MovementComponent.GetMaxSpeed
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UMovementComponent::GetMaxSpeed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetMaxSpeed");

	UMovementComponent_GetMaxSpeed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32490
//		Name   -> Function Engine.MovementComponent.GetGravityZ
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UMovementComponent::GetGravityZ()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetGravityZ");

	UMovementComponent_GetGravityZ_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F0B0
//		Name   -> Function Engine.MovementComponent.ConstrainNormalToPlane
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     Normal                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UMovementComponent::ConstrainNormalToPlane(const struct FVector& Normal)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainNormalToPlane");

	UMovementComponent_ConstrainNormalToPlane_Params params {};
	params.Normal = Normal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F000
//		Name   -> Function Engine.MovementComponent.ConstrainLocationToPlane
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UMovementComponent::ConstrainLocationToPlane(const struct FVector& Location)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainLocationToPlane");

	UMovementComponent_ConstrainLocationToPlane_Params params {};
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2EF50
//		Name   -> Function Engine.MovementComponent.ConstrainDirectionToPlane
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UMovementComponent::ConstrainDirectionToPlane(const struct FVector& Direction)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainDirectionToPlane");

	UMovementComponent_ConstrainDirectionToPlane_Params params {};
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UMovementComponent::AfterRead()
{
	UActorComponent::AfterRead();

	READ_PTR_FULL(UpdatedComponent, USceneComponent);
	READ_PTR_FULL(UpdatedPrimitive, UPrimitiveComponent);
}

void UMovementComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

	DELE_PTR_FULL(UpdatedComponent);
	DELE_PTR_FULL(UpdatedPrimitive);
}

// Function:
//		Offset -> 0x02B409D0
//		Name   -> Function Engine.NavMovementComponent.StopMovementKeepPathing
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UNavMovementComponent::StopMovementKeepPathing()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.StopMovementKeepPathing");

	UNavMovementComponent_StopMovementKeepPathing_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B408E0
//		Name   -> Function Engine.NavMovementComponent.StopActiveMovement
//		Flags  -> (Native, Public, BlueprintCallable)
void UNavMovementComponent::StopActiveMovement()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.StopActiveMovement");

	UNavMovementComponent_StopActiveMovement_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37230
//		Name   -> Function Engine.NavMovementComponent.IsSwimming
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavMovementComponent::IsSwimming()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsSwimming");

	UNavMovementComponent_IsSwimming_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36EE0
//		Name   -> Function Engine.NavMovementComponent.IsMovingOnGround
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavMovementComponent::IsMovingOnGround()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsMovingOnGround");

	UNavMovementComponent_IsMovingOnGround_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36D90
//		Name   -> Function Engine.NavMovementComponent.IsFlying
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavMovementComponent::IsFlying()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsFlying");

	UNavMovementComponent_IsFlying_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36D60
//		Name   -> Function Engine.NavMovementComponent.IsFalling
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavMovementComponent::IsFalling()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsFalling");

	UNavMovementComponent_IsFalling_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36C70
//		Name   -> Function Engine.NavMovementComponent.IsCrouching
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavMovementComponent::IsCrouching()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsCrouching");

	UNavMovementComponent_IsCrouching_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31460
//		Name   -> Function Engine.NavMovementComponent.GetActorFeetLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UNavMovementComponent::GetActorFeetLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.GetActorFeetLocation");

	UNavMovementComponent_GetActorFeetLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UNavMovementComponent::AfterRead()
{
	UMovementComponent::AfterRead();

}

void UNavMovementComponent::BeforeDelete()
{
	UMovementComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02B37310
//		Name   -> Function Engine.PawnMovementComponent.K2_GetInputVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPawnMovementComponent::K2_GetInputVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.K2_GetInputVector");

	UPawnMovementComponent_K2_GetInputVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36EB0
//		Name   -> Function Engine.PawnMovementComponent.IsMoveInputIgnored
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UPawnMovementComponent::IsMoveInputIgnored()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.IsMoveInputIgnored");

	UPawnMovementComponent_IsMoveInputIgnored_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33CA0
//		Name   -> Function Engine.PawnMovementComponent.GetPendingInputVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPawnMovementComponent::GetPendingInputVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetPendingInputVector");

	UPawnMovementComponent_GetPendingInputVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33C70
//		Name   -> Function Engine.PawnMovementComponent.GetPawnOwner
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APawn*                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APawn* UPawnMovementComponent::GetPawnOwner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetPawnOwner");

	UPawnMovementComponent_GetPawnOwner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32610
//		Name   -> Function Engine.PawnMovementComponent.GetLastInputVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPawnMovementComponent::GetLastInputVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetLastInputVector");

	UPawnMovementComponent_GetLastInputVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F160
//		Name   -> Function Engine.PawnMovementComponent.ConsumeInputVector
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPawnMovementComponent::ConsumeInputVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.ConsumeInputVector");

	UPawnMovementComponent_ConsumeInputVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2DEE0
//		Name   -> Function Engine.PawnMovementComponent.AddInputVector
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     WorldVector                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPawnMovementComponent::AddInputVector(const struct FVector& WorldVector, bool bForce)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.AddInputVector");

	UPawnMovementComponent_AddInputVector_Params params {};
	params.WorldVector = WorldVector;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UPawnMovementComponent::AfterRead()
{
	UNavMovementComponent::AfterRead();

	READ_PTR_FULL(PawnOwner, APawn);
}

void UPawnMovementComponent::BeforeDelete()
{
	UNavMovementComponent::BeforeDelete();

	DELE_PTR_FULL(PawnOwner);
}

// Function:
//		Offset -> 0x02C4D7E0
//		Name   -> Function Engine.CharacterMovementComponent.UpdateMaxNavMeshProjectionIntervalAndModifier
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              DesiredMaxNavMeshProjectionInterval                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::UpdateMaxNavMeshProjectionIntervalAndModifier(float DesiredMaxNavMeshProjectionInterval)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.UpdateMaxNavMeshProjectionIntervalAndModifier");

	UCharacterMovementComponent_UpdateMaxNavMeshProjectionIntervalAndModifier_Params params {};
	params.DesiredMaxNavMeshProjectionInterval = DesiredMaxNavMeshProjectionInterval;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4B3A0
//		Name   -> Function Engine.CharacterMovementComponent.SetWalkableFloorZ
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InWalkableFloorZ                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::SetWalkableFloorZ(float InWalkableFloorZ)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetWalkableFloorZ");

	UCharacterMovementComponent_SetWalkableFloorZ_Params params {};
	params.InWalkableFloorZ = InWalkableFloorZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4B320
//		Name   -> Function Engine.CharacterMovementComponent.SetWalkableFloorAngle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InWalkableFloorAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::SetWalkableFloorAngle(float InWalkableFloorAngle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetWalkableFloorAngle");

	UCharacterMovementComponent_SetWalkableFloorAngle_Params params {};
	params.InWalkableFloorAngle = InWalkableFloorAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48D20
//		Name   -> Function Engine.CharacterMovementComponent.SetNavMeshProjectionInterval
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InNavMeshProjectionInterval                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::SetNavMeshProjectionInterval(float InNavMeshProjectionInterval)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetNavMeshProjectionInterval");

	UCharacterMovementComponent_SetNavMeshProjectionInterval_Params params {};
	params.InNavMeshProjectionInterval = InNavMeshProjectionInterval;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48B00
//		Name   -> Function Engine.CharacterMovementComponent.SetMovementMode
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EMovementMode>                  NewMovementMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      NewCustomMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::SetMovementMode(TEnumAsByte<Engine_EMovementMode> NewMovementMode, unsigned char NewCustomMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetMovementMode");

	UCharacterMovementComponent_SetMovementMode_Params params {};
	params.NewMovementMode = NewMovementMode;
	params.NewCustomMode = NewCustomMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47EC0
//		Name   -> Function Engine.CharacterMovementComponent.SetGroupsToIgnore
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                GroupFlags                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::SetGroupsToIgnore(int GroupFlags)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToIgnore");

	UCharacterMovementComponent_SetGroupsToIgnore_Params params {};
	params.GroupFlags = GroupFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47E40
//		Name   -> Function Engine.CharacterMovementComponent.SetGroupsToAvoid
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                GroupFlags                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::SetGroupsToAvoid(int GroupFlags)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToAvoid");

	UCharacterMovementComponent_SetGroupsToAvoid_Params params {};
	params.GroupFlags = GroupFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44F00
//		Name   -> Function Engine.CharacterMovementComponent.SetAvoidanceGroup
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                GroupFlags                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::SetAvoidanceGroup(int GroupFlags)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceGroup");

	UCharacterMovementComponent_SetAvoidanceGroup_Params params {};
	params.GroupFlags = GroupFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44E70
//		Name   -> Function Engine.CharacterMovementComponent.SetAvoidanceEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCharacterMovementComponent::SetAvoidanceEnabled(bool bEnable)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceEnabled");

	UCharacterMovementComponent_SetAvoidanceEnabled_Params params {};
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44760
//		Name   -> Function Engine.CharacterMovementComponent.ServerMoveOld
//		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		float                                              OldTimeStamp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector_NetQuantize10                       OldAccel                                                   (Parm)
//		class UPrimitiveComponent*                         ClientMovementBase                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ClientBaseBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      OldMoveFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::ServerMoveOld(float OldTimeStamp, const struct FVector_NetQuantize10& OldAccel, class UPrimitiveComponent* ClientMovementBase, const struct FName& ClientBaseBoneName, unsigned char OldMoveFlags)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMoveOld");

	UCharacterMovementComponent_ServerMoveOld_Params params {};
	params.OldTimeStamp = OldTimeStamp;
	params.OldAccel = OldAccel;
	params.ClientMovementBase = ClientMovementBase;
	params.ClientBaseBoneName = ClientBaseBoneName;
	params.OldMoveFlags = OldMoveFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44300
//		Name   -> Function Engine.CharacterMovementComponent.ServerMoveDualHybridRootMotion
//		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		float                                              TimeStamp0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector_NetQuantize10                       InAccel0                                                   (Parm)
//		unsigned char                                      PendingFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		uint32_t                                           View0                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector_NetQuantize10                       InAccel                                                    (Parm)
//		struct FVector_NetQuantize100                      ClientLoc                                                  (Parm)
//		unsigned char                                      NewFlags                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UPrimitiveComponent*                         ClientMovementBase                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ClientBaseBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ClientMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::ServerMoveDualHybridRootMotion(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, unsigned char PendingFlags, uint32_t View0, float TimeStamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const struct FName& ClientBaseBoneName, unsigned char ClientMovementMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMoveDualHybridRootMotion");

	UCharacterMovementComponent_ServerMoveDualHybridRootMotion_Params params {};
	params.TimeStamp0 = TimeStamp0;
	params.InAccel0 = InAccel0;
	params.PendingFlags = PendingFlags;
	params.View0 = View0;
	params.TimeStamp = TimeStamp;
	params.InAccel = InAccel;
	params.ClientLoc = ClientLoc;
	params.NewFlags = NewFlags;
	params.ClientRoll = ClientRoll;
	params.View = View;
	params.ClientMovementBase = ClientMovementBase;
	params.ClientBaseBoneName = ClientBaseBoneName;
	params.ClientMovementMode = ClientMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C43EA0
//		Name   -> Function Engine.CharacterMovementComponent.ServerMoveDual
//		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		float                                              TimeStamp0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector_NetQuantize10                       InAccel0                                                   (Parm)
//		unsigned char                                      PendingFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		uint32_t                                           View0                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector_NetQuantize10                       InAccel                                                    (Parm)
//		struct FVector_NetQuantize100                      ClientLoc                                                  (Parm)
//		unsigned char                                      NewFlags                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UPrimitiveComponent*                         ClientMovementBase                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ClientBaseBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ClientMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::ServerMoveDual(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, unsigned char PendingFlags, uint32_t View0, float TimeStamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const struct FName& ClientBaseBoneName, unsigned char ClientMovementMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMoveDual");

	UCharacterMovementComponent_ServerMoveDual_Params params {};
	params.TimeStamp0 = TimeStamp0;
	params.InAccel0 = InAccel0;
	params.PendingFlags = PendingFlags;
	params.View0 = View0;
	params.TimeStamp = TimeStamp;
	params.InAccel = InAccel;
	params.ClientLoc = ClientLoc;
	params.NewFlags = NewFlags;
	params.ClientRoll = ClientRoll;
	params.View = View;
	params.ClientMovementBase = ClientMovementBase;
	params.ClientBaseBoneName = ClientBaseBoneName;
	params.ClientMovementMode = ClientMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C43B80
//		Name   -> Function Engine.CharacterMovementComponent.ServerMove
//		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector_NetQuantize10                       InAccel                                                    (Parm)
//		struct FVector_NetQuantize100                      ClientLoc                                                  (Parm)
//		unsigned char                                      CompressedMoveFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UPrimitiveComponent*                         ClientMovementBase                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ClientBaseBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ClientMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::ServerMove(float TimeStamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char CompressedMoveFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const struct FName& ClientBaseBoneName, unsigned char ClientMovementMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMove");

	UCharacterMovementComponent_ServerMove_Params params {};
	params.TimeStamp = TimeStamp;
	params.InAccel = InAccel;
	params.ClientLoc = ClientLoc;
	params.CompressedMoveFlags = CompressedMoveFlags;
	params.ClientRoll = ClientRoll;
	params.View = View;
	params.ClientMovementBase = ClientMovementBase;
	params.ClientBaseBoneName = ClientBaseBoneName;
	params.ClientMovementMode = ClientMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41040
//		Name   -> Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCharacterMovementComponent::K2_GetWalkableFloorZ()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ");

	UCharacterMovementComponent_K2_GetWalkableFloorZ_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C41010
//		Name   -> Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCharacterMovementComponent::K2_GetWalkableFloorAngle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle");

	UCharacterMovementComponent_K2_GetWalkableFloorAngle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40FD0
//		Name   -> Function Engine.CharacterMovementComponent.K2_GetModifiedMaxAcceleration
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCharacterMovementComponent::K2_GetModifiedMaxAcceleration()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetModifiedMaxAcceleration");

	UCharacterMovementComponent_K2_GetModifiedMaxAcceleration_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40FA0
//		Name   -> Function Engine.CharacterMovementComponent.IsWalking
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UCharacterMovementComponent::IsWalking()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsWalking");

	UCharacterMovementComponent_IsWalking_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40ED0
//		Name   -> Function Engine.CharacterMovementComponent.IsWalkable
//		Flags  -> (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UCharacterMovementComponent::IsWalkable(const struct FHitResult& Hit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsWalkable");

	UCharacterMovementComponent_IsWalkable_Params params {};
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40530
//		Name   -> Function Engine.CharacterMovementComponent.GetValidPerchRadius
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCharacterMovementComponent::GetValidPerchRadius()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetValidPerchRadius");

	UCharacterMovementComponent_GetValidPerchRadius_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F0D0
//		Name   -> Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCharacterMovementComponent::GetPerchRadiusThreshold()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold");

	UCharacterMovementComponent_GetPerchRadiusThreshold_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3ECA0
//		Name   -> Function Engine.CharacterMovementComponent.GetNavMeshProjectionInterval
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCharacterMovementComponent::GetNavMeshProjectionInterval()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetNavMeshProjectionInterval");

	UCharacterMovementComponent_GetNavMeshProjectionInterval_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3EC70
//		Name   -> Function Engine.CharacterMovementComponent.GetMovementBase
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UPrimitiveComponent*                         ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UPrimitiveComponent* UCharacterMovementComponent::GetMovementBase()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMovementBase");

	UCharacterMovementComponent_GetMovementBase_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3EB70
//		Name   -> Function Engine.CharacterMovementComponent.GetMaxJumpHeight
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCharacterMovementComponent::GetMaxJumpHeight()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxJumpHeight");

	UCharacterMovementComponent_GetMaxJumpHeight_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3EA70
//		Name   -> Function Engine.CharacterMovementComponent.GetMaxAcceleration
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCharacterMovementComponent::GetMaxAcceleration()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxAcceleration");

	UCharacterMovementComponent_GetMaxAcceleration_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DCD0
//		Name   -> Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UCharacterMovementComponent::GetImpartedMovementBaseVelocity()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity");

	UCharacterMovementComponent_GetImpartedMovementBaseVelocity_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D3A0
//		Name   -> Function Engine.CharacterMovementComponent.GetCurrentAcceleration
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UCharacterMovementComponent::GetCurrentAcceleration()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCurrentAcceleration");

	UCharacterMovementComponent_GetCurrentAcceleration_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D380
//		Name   -> Function Engine.CharacterMovementComponent.GetCharacterOwner
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class ACharacter*                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class ACharacter* UCharacterMovementComponent::GetCharacterOwner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCharacterOwner");

	UCharacterMovementComponent_GetCharacterOwner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3C5D0
//		Name   -> Function Engine.CharacterMovementComponent.GetAnalogInputModifier
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCharacterMovementComponent::GetAnalogInputModifier()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetAnalogInputModifier");

	UCharacterMovementComponent_GetAnalogInputModifier_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3B850
//		Name   -> Function Engine.CharacterMovementComponent.DisableMovement
//		Flags  -> (Native, Public, BlueprintCallable)
void UCharacterMovementComponent::DisableMovement()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.DisableMovement");

	UCharacterMovementComponent_DisableMovement_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3AF40
//		Name   -> Function Engine.CharacterMovementComponent.ClientVeryShortAdjustPosition
//		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
//		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NewLoc                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UPrimitiveComponent*                         NewBase                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       NewBaseBoneName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bHasBase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bBaseRelativePosition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		unsigned char                                      ServerMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::ClientVeryShortAdjustPosition(float TimeStamp, const struct FVector& NewLoc, class UPrimitiveComponent* NewBase, const struct FName& NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClientVeryShortAdjustPosition");

	UCharacterMovementComponent_ClientVeryShortAdjustPosition_Params params {};
	params.TimeStamp = TimeStamp;
	params.NewLoc = NewLoc;
	params.NewBase = NewBase;
	params.NewBaseBoneName = NewBaseBoneName;
	params.bHasBase = bHasBase;
	params.bBaseRelativePosition = bBaseRelativePosition;
	params.ServerMovementMode = ServerMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3AC50
//		Name   -> Function Engine.CharacterMovementComponent.ClientAdjustRootMotionPosition
//		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
//		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ServerMontageTrackPosition                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ServerLoc                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector_NetQuantizeNormal                   ServerRotation                                             (Parm)
//		float                                              ServerVelZ                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UPrimitiveComponent*                         ServerBase                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ServerBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bHasBase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bBaseRelativePosition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		unsigned char                                      ServerMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::ClientAdjustRootMotionPosition(float TimeStamp, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, const struct FName& ServerBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClientAdjustRootMotionPosition");

	UCharacterMovementComponent_ClientAdjustRootMotionPosition_Params params {};
	params.TimeStamp = TimeStamp;
	params.ServerMontageTrackPosition = ServerMontageTrackPosition;
	params.ServerLoc = ServerLoc;
	params.ServerRotation = ServerRotation;
	params.ServerVelZ = ServerVelZ;
	params.ServerBase = ServerBase;
	params.ServerBoneName = ServerBoneName;
	params.bHasBase = bHasBase;
	params.bBaseRelativePosition = bBaseRelativePosition;
	params.ServerMovementMode = ServerMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3A9E0
//		Name   -> Function Engine.CharacterMovementComponent.ClientAdjustPosition
//		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
//		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NewLoc                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     NewVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UPrimitiveComponent*                         NewBase                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       NewBaseBoneName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bHasBase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bBaseRelativePosition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		unsigned char                                      ServerMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::ClientAdjustPosition(float TimeStamp, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, const struct FName& NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClientAdjustPosition");

	UCharacterMovementComponent_ClientAdjustPosition_Params params {};
	params.TimeStamp = TimeStamp;
	params.NewLoc = NewLoc;
	params.NewVel = NewVel;
	params.NewBase = NewBase;
	params.NewBaseBoneName = NewBaseBoneName;
	params.bHasBase = bHasBase;
	params.bBaseRelativePosition = bBaseRelativePosition;
	params.ServerMovementMode = ServerMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3A960
//		Name   -> Function Engine.CharacterMovementComponent.ClientAckGoodMove
//		Flags  -> (Net, Native, Event, Public, NetClient)
// Parameters:
//		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::ClientAckGoodMove(float TimeStamp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClientAckGoodMove");

	UCharacterMovementComponent_ClientAckGoodMove_Params params {};
	params.TimeStamp = TimeStamp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3A6D0
//		Name   -> Function Engine.CharacterMovementComponent.CapsuleTouched
//		Flags  -> (Native, Protected, HasOutParms)
// Parameters:
//		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
void UCharacterMovementComponent::CapsuleTouched(class AActor* Other, class UPrimitiveComponent* OtherComp, int OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.CapsuleTouched");

	UCharacterMovementComponent_CapsuleTouched_Params params {};
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;
	params.bFromSweep = bFromSweep;
	params.SweepResult = SweepResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3A470
//		Name   -> Function Engine.CharacterMovementComponent.CalcVelocity
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Friction                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bFluid                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              BrakingDeceleration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCharacterMovementComponent::CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.CalcVelocity");

	UCharacterMovementComponent_CalcVelocity_Params params {};
	params.DeltaTime = DeltaTime;
	params.Friction = Friction;
	params.bFluid = bFluid;
	params.BrakingDeceleration = BrakingDeceleration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C37B00
//		Name   -> Function Engine.CharacterMovementComponent.AddImpulse
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bVelocityChange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCharacterMovementComponent::AddImpulse(const struct FVector& Impulse, bool bVelocityChange)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.AddImpulse");

	UCharacterMovementComponent_AddImpulse_Params params {};
	params.Impulse = Impulse;
	params.bVelocityChange = bVelocityChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C37A70
//		Name   -> Function Engine.CharacterMovementComponent.AddForce
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCharacterMovementComponent::AddForce(const struct FVector& Force)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.AddForce");

	UCharacterMovementComponent_AddForce_Params params {};
	params.Force = Force;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UCharacterMovementComponent::AfterRead()
{
	UPawnMovementComponent::AfterRead();

	READ_PTR_FULL(CharacterOwner, ACharacter);
	READ_PTR_FULL(DeferredUpdatedMoveComponent, USceneComponent);
}

void UCharacterMovementComponent::BeforeDelete()
{
	UPawnMovementComponent::BeforeDelete();

	DELE_PTR_FULL(CharacterOwner);
	DELE_PTR_FULL(DeferredUpdatedMoveComponent);
}

// Function:
//		Offset -> 0x02A3B0C0
//		Name   -> Function Engine.InputComponent.WasControllerKeyJustReleased
//		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UInputComponent::WasControllerKeyJustReleased(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.WasControllerKeyJustReleased");

	UInputComponent_WasControllerKeyJustReleased_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A3AFC0
//		Name   -> Function Engine.InputComponent.WasControllerKeyJustPressed
//		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UInputComponent::WasControllerKeyJustPressed(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.WasControllerKeyJustPressed");

	UInputComponent_WasControllerKeyJustPressed_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A32000
//		Name   -> Function Engine.InputComponent.IsControllerKeyDown
//		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UInputComponent::IsControllerKeyDown(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.IsControllerKeyDown");

	UInputComponent_IsControllerKeyDown_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31930
//		Name   -> Function Engine.InputComponent.GetTouchState
//		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LocationX                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LocationY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bIsCurrentlyPressed                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UInputComponent::GetTouchState(int FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetTouchState");

	UInputComponent_GetTouchState_Params params {};
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (LocationX != nullptr)
		*LocationX = params.LocationX;
	if (LocationY != nullptr)
		*LocationY = params.LocationY;
	if (bIsCurrentlyPressed != nullptr)
		*bIsCurrentlyPressed = params.bIsCurrentlyPressed;

}


// Function:
//		Offset -> 0x02A2F4D0
//		Name   -> Function Engine.InputComponent.GetControllerVectorKeyState
//		Flags  -> (Final, Native, Private, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UInputComponent::GetControllerVectorKeyState(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerVectorKeyState");

	UInputComponent_GetControllerVectorKeyState_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F3F0
//		Name   -> Function Engine.InputComponent.GetControllerMouseDelta
//		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              DeltaX                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              DeltaY                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UInputComponent::GetControllerMouseDelta(float* DeltaX, float* DeltaY)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerMouseDelta");

	UInputComponent_GetControllerMouseDelta_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (DeltaX != nullptr)
		*DeltaX = params.DeltaX;
	if (DeltaY != nullptr)
		*DeltaY = params.DeltaY;

}


// Function:
//		Offset -> 0x02A2F2F0
//		Name   -> Function Engine.InputComponent.GetControllerKeyTimeDown
//		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UInputComponent::GetControllerKeyTimeDown(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerKeyTimeDown");

	UInputComponent_GetControllerKeyTimeDown_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F1D0
//		Name   -> Function Engine.InputComponent.GetControllerAnalogStickState
//		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_EControllerAnalogStick>         WhichStick                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              StickX                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              StickY                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UInputComponent::GetControllerAnalogStickState(TEnumAsByte<Engine_EControllerAnalogStick> WhichStick, float* StickX, float* StickY)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerAnalogStickState");

	UInputComponent_GetControllerAnalogStickState_Params params {};
	params.WhichStick = WhichStick;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (StickX != nullptr)
		*StickX = params.StickX;
	if (StickY != nullptr)
		*StickY = params.StickY;

}


// Function:
//		Offset -> 0x02A2F0D0
//		Name   -> Function Engine.InputComponent.GetControllerAnalogKeyState
//		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UInputComponent::GetControllerAnalogKeyState(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerAnalogKeyState");

	UInputComponent_GetControllerAnalogKeyState_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UInputComponent::AfterRead()
{
	UActorComponent::AfterRead();

}

void UInputComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

}

void UDeveloperSettings::AfterRead()
{
	UObject::AfterRead();

}

void UDeveloperSettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UEngine::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(TinyFont, UFont);
	READ_PTR_FULL(SmallFont, UFont);
	READ_PTR_FULL(MediumFont, UFont);
	READ_PTR_FULL(LargeFont, UFont);
	READ_PTR_FULL(MonoFont, UFont);
	READ_PTR_FULL(SubtitleFont, UFont);
	READ_PTR_FULL(HugeFont, UFont);
	READ_PTR_FULL(ConsoleClass, UClass);
	READ_PTR_FULL(GameViewportClientClass, UClass);
	READ_PTR_FULL(LocalPlayerClass, UClass);
	READ_PTR_FULL(WorldSettingsClass, UClass);
	READ_PTR_FULL(NavigationSystemClass, UClass);
	READ_PTR_FULL(AvoidanceManagerClass, UClass);
	READ_PTR_FULL(PhysicsCollisionHandlerClass, UClass);
	READ_PTR_FULL(GameUserSettingsClass, UClass);
	READ_PTR_FULL(GameUserSettings, UGameUserSettings);
	READ_PTR_FULL(LevelScriptActorClass, UClass);
	READ_PTR_FULL(GameSingleton, UObject);
	READ_PTR_FULL(DefaultPreviewPawnClass, UClass);
	READ_PTR_FULL(DefaultTexture, UTexture2D);
	READ_PTR_FULL(DefaultDiffuseTexture, UTexture);
	READ_PTR_FULL(DefaultBSPVertexTexture, UTexture2D);
	READ_PTR_FULL(HighFrequencyNoiseTexture, UTexture2D);
	READ_PTR_FULL(DefaultBokehTexture, UTexture2D);
	READ_PTR_FULL(HDRCalibrationTexture, UTexture2D);
	READ_PTR_FULL(WireframeMaterial, UMaterial);
	READ_PTR_FULL(DebugMeshMaterial, UMaterial);
	READ_PTR_FULL(LevelColorationLitMaterial, UMaterial);
	READ_PTR_FULL(LevelColorationUnlitMaterial, UMaterial);
	READ_PTR_FULL(TriangleDensityScreenSpaceMaterial, UMaterial);
	READ_PTR_FULL(TriangleDensityWorldSpaceMaterial, UMaterial);
	READ_PTR_FULL(LightingTexelDensityMaterial, UMaterial);
	READ_PTR_FULL(ShadedLevelColorationLitMaterial, UMaterial);
	READ_PTR_FULL(ShadedLevelColorationUnlitMaterial, UMaterial);
	READ_PTR_FULL(RemoveSurfaceMaterial, UMaterial);
	READ_PTR_FULL(VertexColorMaterial, UMaterial);
	READ_PTR_FULL(VertexColorViewModeMaterial_ColorOnly, UMaterial);
	READ_PTR_FULL(VertexColorViewModeMaterial_AlphaAsColor, UMaterial);
	READ_PTR_FULL(VertexColorViewModeMaterial_RedOnly, UMaterial);
	READ_PTR_FULL(VertexColorViewModeMaterial_GreenOnly, UMaterial);
	READ_PTR_FULL(VertexColorViewModeMaterial_BlueOnly, UMaterial);
	READ_PTR_FULL(ConstraintLimitMaterial, UMaterial);
	READ_PTR_FULL(ConstraintLimitMaterialX, UMaterialInstanceDynamic);
	READ_PTR_FULL(ConstraintLimitMaterialY, UMaterialInstanceDynamic);
	READ_PTR_FULL(ConstraintLimitMaterialZ, UMaterialInstanceDynamic);
	READ_PTR_FULL(InvalidLightmapSettingsMaterial, UMaterial);
	READ_PTR_FULL(PreviewShadowsIndicatorMaterial, UMaterial);
	READ_PTR_FULL(ArrowMaterial, UMaterial);
	READ_PTR_FULL(DefaultPhysMaterial, UPhysicalMaterial);
	READ_PTR_FULL(PreIntegratedSkinBRDFTexture, UTexture2D);
	READ_PTR_FULL(MiniFontTexture, UTexture2D);
	READ_PTR_FULL(WeightMapPlaceholderTexture, UTexture);
	READ_PTR_FULL(LightMapDensityTexture, UTexture2D);
	READ_PTR_FULL(GameViewport, UGameViewportClient);
}

void UEngine::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(TinyFont);
	DELE_PTR_FULL(SmallFont);
	DELE_PTR_FULL(MediumFont);
	DELE_PTR_FULL(LargeFont);
	DELE_PTR_FULL(MonoFont);
	DELE_PTR_FULL(SubtitleFont);
	DELE_PTR_FULL(HugeFont);
	DELE_PTR_FULL(ConsoleClass);
	DELE_PTR_FULL(GameViewportClientClass);
	DELE_PTR_FULL(LocalPlayerClass);
	DELE_PTR_FULL(WorldSettingsClass);
	DELE_PTR_FULL(NavigationSystemClass);
	DELE_PTR_FULL(AvoidanceManagerClass);
	DELE_PTR_FULL(PhysicsCollisionHandlerClass);
	DELE_PTR_FULL(GameUserSettingsClass);
	DELE_PTR_FULL(GameUserSettings);
	DELE_PTR_FULL(LevelScriptActorClass);
	DELE_PTR_FULL(GameSingleton);
	DELE_PTR_FULL(DefaultPreviewPawnClass);
	DELE_PTR_FULL(DefaultTexture);
	DELE_PTR_FULL(DefaultDiffuseTexture);
	DELE_PTR_FULL(DefaultBSPVertexTexture);
	DELE_PTR_FULL(HighFrequencyNoiseTexture);
	DELE_PTR_FULL(DefaultBokehTexture);
	DELE_PTR_FULL(HDRCalibrationTexture);
	DELE_PTR_FULL(WireframeMaterial);
	DELE_PTR_FULL(DebugMeshMaterial);
	DELE_PTR_FULL(LevelColorationLitMaterial);
	DELE_PTR_FULL(LevelColorationUnlitMaterial);
	DELE_PTR_FULL(TriangleDensityScreenSpaceMaterial);
	DELE_PTR_FULL(TriangleDensityWorldSpaceMaterial);
	DELE_PTR_FULL(LightingTexelDensityMaterial);
	DELE_PTR_FULL(ShadedLevelColorationLitMaterial);
	DELE_PTR_FULL(ShadedLevelColorationUnlitMaterial);
	DELE_PTR_FULL(RemoveSurfaceMaterial);
	DELE_PTR_FULL(VertexColorMaterial);
	DELE_PTR_FULL(VertexColorViewModeMaterial_ColorOnly);
	DELE_PTR_FULL(VertexColorViewModeMaterial_AlphaAsColor);
	DELE_PTR_FULL(VertexColorViewModeMaterial_RedOnly);
	DELE_PTR_FULL(VertexColorViewModeMaterial_GreenOnly);
	DELE_PTR_FULL(VertexColorViewModeMaterial_BlueOnly);
	DELE_PTR_FULL(ConstraintLimitMaterial);
	DELE_PTR_FULL(ConstraintLimitMaterialX);
	DELE_PTR_FULL(ConstraintLimitMaterialY);
	DELE_PTR_FULL(ConstraintLimitMaterialZ);
	DELE_PTR_FULL(InvalidLightmapSettingsMaterial);
	DELE_PTR_FULL(PreviewShadowsIndicatorMaterial);
	DELE_PTR_FULL(ArrowMaterial);
	DELE_PTR_FULL(DefaultPhysMaterial);
	DELE_PTR_FULL(PreIntegratedSkinBRDFTexture);
	DELE_PTR_FULL(MiniFontTexture);
	DELE_PTR_FULL(WeightMapPlaceholderTexture);
	DELE_PTR_FULL(LightMapDensityTexture);
	DELE_PTR_FULL(GameViewport);
}

void UGameEngine::AfterRead()
{
	UEngine::AfterRead();

}

void UGameEngine::BeforeDelete()
{
	UEngine::BeforeDelete();

}

// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.GameInstance.ReceiveShutdown
//		Flags  -> (Event, Public, BlueprintEvent)
void UGameInstance::ReceiveShutdown()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.ReceiveShutdown");

	UGameInstance_ReceiveShutdown_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.GameInstance.ReceiveInit
//		Flags  -> (Event, Public, BlueprintEvent)
void UGameInstance::ReceiveInit()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.ReceiveInit");

	UGameInstance_ReceiveInit_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2DB00
//		Name   -> Function Engine.GameInstance.DebugRemovePlayer
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		int                                                ControllerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameInstance::DebugRemovePlayer(int ControllerId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.DebugRemovePlayer");

	UGameInstance_DebugRemovePlayer_Params params {};
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2DA70
//		Name   -> Function Engine.GameInstance.DebugCreatePlayer
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		int                                                ControllerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameInstance::DebugCreatePlayer(int ControllerId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.DebugCreatePlayer");

	UGameInstance_DebugCreatePlayer_Params params {};
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UGameInstance::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(OnlineSession, UOnlineSession);
}

void UGameInstance::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(OnlineSession);
}

void AInfo::AfterRead()
{
	AActor::AfterRead();

}

void AInfo::BeforeDelete()
{
	AActor::BeforeDelete();

}

// Function:
//		Offset -> 0x02B40880
//		Name   -> Function Engine.GameMode.StartPlay
//		Flags  -> (Native, Public, BlueprintCallable)
void AGameMode::StartPlay()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.StartPlay");

	AGameMode_StartPlay_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40860
//		Name   -> Function Engine.GameMode.StartMatch
//		Flags  -> (Native, Public, BlueprintCallable)
void AGameMode::StartMatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.StartMatch");

	AGameMode_StartMatch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40790
//		Name   -> Function Engine.GameMode.SpawnDefaultPawnFor
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class AController*                                 NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      StartSpot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class APawn*                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APawn* AGameMode::SpawnDefaultPawnFor(class AController* NewPlayer, class AActor* StartSpot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.SpawnDefaultPawnFor");

	AGameMode_SpawnDefaultPawnFor_Params params {};
	params.NewPlayer = NewPlayer;
	params.StartSpot = StartSpot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B40370
//		Name   -> Function Engine.GameMode.ShouldReset
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class AActor*                                      ActorToReset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AGameMode::ShouldReset(class AActor* ActorToReset)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ShouldReset");

	AGameMode_ShouldReset_Params params {};
	params.ActorToReset = ActorToReset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B3AA40
//		Name   -> Function Engine.GameMode.SetBandwidthLimit
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		float                                              AsyncIOBandwidthLimit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AGameMode::SetBandwidthLimit(float AsyncIOBandwidthLimit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.SetBandwidthLimit");

	AGameMode_SetBandwidthLimit_Params params {};
	params.AsyncIOBandwidthLimit = AsyncIOBandwidthLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39570
//		Name   -> Function Engine.GameMode.ReturnToMainMenuHost
//		Flags  -> (Native, Public, BlueprintCallable)
void AGameMode::ReturnToMainMenuHost()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ReturnToMainMenuHost");

	AGameMode_ReturnToMainMenuHost_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B394D0
//		Name   -> Function Engine.GameMode.RestartGame
//		Flags  -> (Native, Public, BlueprintCallable)
void AGameMode::RestartGame()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.RestartGame");

	AGameMode_RestartGame_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39490
//		Name   -> Function Engine.GameMode.ResetLevel
//		Flags  -> (Native, Public, BlueprintCallable)
void AGameMode::ResetLevel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ResetLevel");

	AGameMode_ResetLevel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39030
//		Name   -> Function Engine.GameMode.ReadyToStartMatch
//		Flags  -> (Native, Event, Protected, BlueprintEvent)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AGameMode::ReadyToStartMatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ReadyToStartMatch");

	AGameMode_ReadyToStartMatch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B39000
//		Name   -> Function Engine.GameMode.ReadyToEndMatch
//		Flags  -> (Native, Event, Protected, BlueprintEvent)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AGameMode::ReadyToEndMatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ReadyToEndMatch");

	AGameMode_ReadyToEndMatch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B38C60
//		Name   -> Function Engine.GameMode.PlayerCanRestart
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class APlayerController*                           Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AGameMode::PlayerCanRestart(class APlayerController* Player)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.PlayerCanRestart");

	AGameMode_PlayerCanRestart_Params params {};
	params.Player = Player;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B37D00
//		Name   -> Function Engine.GameMode.MustSpectate
//		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
//		class APlayerController*                           NewPlayerController                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AGameMode::MustSpectate(class APlayerController* NewPlayerController)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.MustSpectate");

	AGameMode_MustSpectate_Params params {};
	params.NewPlayerController = NewPlayerController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.GameMode.K2_PostLogin
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class APlayerController*                           NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AGameMode::K2_PostLogin(class APlayerController* NewPlayer)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.K2_PostLogin");

	AGameMode_K2_PostLogin_Params params {};
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.GameMode.K2_OnSwapPlayerControllers
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class APlayerController*                           OldPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class APlayerController*                           NewPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AGameMode::K2_OnSwapPlayerControllers(class APlayerController* OldPC, class APlayerController* NewPC)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.K2_OnSwapPlayerControllers");

	AGameMode_K2_OnSwapPlayerControllers_Params params {};
	params.OldPC = OldPC;
	params.NewPC = NewPC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.GameMode.K2_OnSetMatchState
//		Flags  -> (Event, Protected, BlueprintEvent)
// Parameters:
//		struct FName                                       NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AGameMode::K2_OnSetMatchState(const struct FName& NewState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.K2_OnSetMatchState");

	AGameMode_K2_OnSetMatchState_Params params {};
	params.NewState = NewState;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.GameMode.K2_OnRestartPlayer
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class AController*                                 NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AGameMode::K2_OnRestartPlayer(class AController* NewPlayer)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.K2_OnRestartPlayer");

	AGameMode_K2_OnRestartPlayer_Params params {};
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.GameMode.K2_OnLogout
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class AController*                                 ExitingController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AGameMode::K2_OnLogout(class AController* ExitingController)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.K2_OnLogout");

	AGameMode_K2_OnLogout_Params params {};
	params.ExitingController = ExitingController;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.GameMode.K2_OnChangeName
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class AController*                                 Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     NewName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               bNameChange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AGameMode::K2_OnChangeName(class AController* Other, const struct FString& NewName, bool bNameChange)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.K2_OnChangeName");

	AGameMode_K2_OnChangeName_Params params {};
	params.Other = Other;
	params.NewName = NewName;
	params.bNameChange = bNameChange;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37280
//		Name   -> Function Engine.GameMode.K2_FindPlayerStart
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class AController*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* AGameMode::K2_FindPlayerStart(class AController* Player)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.K2_FindPlayerStart");

	AGameMode_K2_FindPlayerStart_Params params {};
	params.Player = Player;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36E50
//		Name   -> Function Engine.GameMode.IsMatchInProgress
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AGameMode::IsMatchInProgress()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.IsMatchInProgress");

	AGameMode_IsMatchInProgress_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36A80
//		Name   -> Function Engine.GameMode.InitStartSpot
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class AActor*                                      StartSpot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AController*                                 NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AGameMode::InitStartSpot(class AActor* StartSpot, class AController* NewPlayer)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.InitStartSpot");

	AGameMode_InitStartSpot_Params params {};
	params.StartSpot = StartSpot;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B36850
//		Name   -> Function Engine.GameMode.HasMatchStarted
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AGameMode::HasMatchStarted()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.HasMatchStarted");

	AGameMode_HasMatchStarted_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36820
//		Name   -> Function Engine.GameMode.HasMatchEnded
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AGameMode::HasMatchEnded()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.HasMatchEnded");

	AGameMode_HasMatchEnded_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B332E0
//		Name   -> Function Engine.GameMode.GetNumPlayers
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int AGameMode::GetNumPlayers()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.GetNumPlayers");

	AGameMode_GetNumPlayers_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32DC0
//		Name   -> Function Engine.GameMode.GetMatchState
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName AGameMode::GetMatchState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.GetMatchState");

	AGameMode_GetMatchState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31FB0
//		Name   -> Function Engine.GameMode.GetDefaultPawnClassForController
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class AController*                                 InController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UClass* AGameMode::GetDefaultPawnClassForController(class AController* InController)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.GetDefaultPawnClassForController");

	AGameMode_GetDefaultPawnClassForController_Params params {};
	params.InController = InController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B310C0
//		Name   -> Function Engine.GameMode.FindPlayerStart
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class AController*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     IncomingName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* AGameMode::FindPlayerStart(class AController* Player, const struct FString& IncomingName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.FindPlayerStart");

	AGameMode_FindPlayerStart_Params params {};
	params.Player = Player;
	params.IncomingName = IncomingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B30CE0
//		Name   -> Function Engine.GameMode.EndMatch
//		Flags  -> (Native, Public, BlueprintCallable)
void AGameMode::EndMatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.EndMatch");

	AGameMode_EndMatch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2ED90
//		Name   -> Function Engine.GameMode.ChoosePlayerStart
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class AController*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* AGameMode::ChoosePlayerStart(class AController* Player)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ChoosePlayerStart");

	AGameMode_ChoosePlayerStart_Params params {};
	params.Player = Player;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2EC40
//		Name   -> Function Engine.GameMode.ChangeName
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     NewName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               bNameChange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AGameMode::ChangeName(class AController* Controller, const struct FString& NewName, bool bNameChange)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ChangeName");

	AGameMode_ChangeName_Params params {};
	params.Controller = Controller;
	params.NewName = NewName;
	params.bNameChange = bNameChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2EB70
//		Name   -> Function Engine.GameMode.CanSpectate
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class APlayerController*                           Viewer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class APlayerState*                                ViewTarget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AGameMode::CanSpectate(class APlayerController* Viewer, class APlayerState* ViewTarget)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.CanSpectate");

	AGameMode_CanSpectate_Params params {};
	params.Viewer = Viewer;
	params.ViewTarget = ViewTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2CF50
//		Name   -> Function Engine.GameMode.AbortMatch
//		Flags  -> (Native, Public, BlueprintCallable)
void AGameMode::AbortMatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameMode.AbortMatch");

	AGameMode_AbortMatch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void AGameMode::AfterRead()
{
	AInfo::AfterRead();

	READ_PTR_FULL(DefaultPawnClass, UClass);
	READ_PTR_FULL(HUDClass, UClass);
	READ_PTR_FULL(GameSession, AGameSession);
	READ_PTR_FULL(EngineMessageClass, UClass);
	READ_PTR_FULL(PlayerControllerClass, UClass);
	READ_PTR_FULL(SpectatorClass, UClass);
	READ_PTR_FULL(ReplaySpectatorPlayerControllerClass, UClass);
	READ_PTR_FULL(PlayerStateClass, UClass);
	READ_PTR_FULL(GameStateClass, UClass);
	READ_PTR_FULL(GameState, AGameState);
}

void AGameMode::BeforeDelete()
{
	AInfo::BeforeDelete();

	DELE_PTR_FULL(DefaultPawnClass);
	DELE_PTR_FULL(HUDClass);
	DELE_PTR_FULL(GameSession);
	DELE_PTR_FULL(EngineMessageClass);
	DELE_PTR_FULL(PlayerControllerClass);
	DELE_PTR_FULL(SpectatorClass);
	DELE_PTR_FULL(ReplaySpectatorPlayerControllerClass);
	DELE_PTR_FULL(PlayerStateClass);
	DELE_PTR_FULL(GameStateClass);
	DELE_PTR_FULL(GameState);
}

// Function:
//		Offset -> 0x02B41350
//		Name   -> Function Engine.PrimitiveComponent.WakeRigidBody
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::WakeRigidBody(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WakeRigidBody");

	UPrimitiveComponent_WakeRigidBody_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B41330
//		Name   -> Function Engine.PrimitiveComponent.WakeAllRigidBodies
//		Flags  -> (Native, Public, BlueprintCallable)
void UPrimitiveComponent::WakeAllRigidBodies()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WakeAllRigidBodies");

	UPrimitiveComponent_WakeAllRigidBodies_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40200
//		Name   -> Function Engine.PrimitiveComponent.SetWalkableSlopeOverride
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FWalkableSlopeOverride                      NewOverride                                                (ConstParm, Parm, OutParm, ReferenceParm)
void UPrimitiveComponent::SetWalkableSlopeOverride(const struct FWalkableSlopeOverride& NewOverride)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetWalkableSlopeOverride");

	UPrimitiveComponent_SetWalkableSlopeOverride_Params params {};
	params.NewOverride = NewOverride;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3FEC0
//		Name   -> Function Engine.PrimitiveComponent.SetTranslucentSortPriority
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                NewTranslucentSortPriority                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetTranslucentSortPriority(int NewTranslucentSortPriority)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetTranslucentSortPriority");

	UPrimitiveComponent_SetTranslucentSortPriority_Params params {};
	params.NewTranslucentSortPriority = NewTranslucentSortPriority;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F5E0
//		Name   -> Function Engine.PrimitiveComponent.SetSimulatePhysics
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bSimulate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetSimulatePhysics(bool bSimulate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetSimulatePhysics");

	UPrimitiveComponent_SetSimulatePhysics_Params params {};
	params.bSimulate = bSimulate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F430
//		Name   -> Function Engine.PrimitiveComponent.SetRenderInMainPass
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetRenderInMainPass(bool bValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetRenderInMainPass");

	UPrimitiveComponent_SetRenderInMainPass_Params params {};
	params.bValue = bValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F3A0
//		Name   -> Function Engine.PrimitiveComponent.SetRenderCustomDepth
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetRenderCustomDepth(bool bValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetRenderCustomDepth");

	UPrimitiveComponent_SetRenderCustomDepth_Params params {};
	params.bValue = bValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E8E0
//		Name   -> Function Engine.PrimitiveComponent.SetPhysMaterialOverride
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UPhysicalMaterial*                           NewPhysMaterial                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysMaterialOverride");

	UPrimitiveComponent_SetPhysMaterialOverride_Params params {};
	params.NewPhysMaterial = NewPhysMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3ECE0
//		Name   -> Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocity
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewMaxAngVel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bAddToCurrent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetPhysicsMaxAngularVelocity(float NewMaxAngVel, bool bAddToCurrent, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocity");

	UPrimitiveComponent_SetPhysicsMaxAngularVelocity_Params params {};
	params.NewMaxAngVel = NewMaxAngVel;
	params.bAddToCurrent = bAddToCurrent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3EBD0
//		Name   -> Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAddToCurrent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity");

	UPrimitiveComponent_SetPhysicsLinearVelocity_Params params {};
	params.NewVel = NewVel;
	params.bAddToCurrent = bAddToCurrent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E970
//		Name   -> Function Engine.PrimitiveComponent.SetPhysicsAngularVelocity
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewAngVel                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAddToCurrent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetPhysicsAngularVelocity(const struct FVector& NewAngVel, bool bAddToCurrent, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsAngularVelocity");

	UPrimitiveComponent_SetPhysicsAngularVelocity_Params params {};
	params.NewAngVel = NewAngVel;
	params.bAddToCurrent = bAddToCurrent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E850
//		Name   -> Function Engine.PrimitiveComponent.SetOwnerNoSee
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewOwnerNoSee                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetOwnerNoSee(bool bNewOwnerNoSee)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetOwnerNoSee");

	UPrimitiveComponent_SetOwnerNoSee_Params params {};
	params.bNewOwnerNoSee = bNewOwnerNoSee;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E740
//		Name   -> Function Engine.PrimitiveComponent.SetOnlyOwnerSee
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewOnlyOwnerSee                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetOnlyOwnerSee(bool bNewOnlyOwnerSee)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetOnlyOwnerSee");

	UPrimitiveComponent_SetOnlyOwnerSee_Params params {};
	params.bNewOnlyOwnerSee = bNewOnlyOwnerSee;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E6B0
//		Name   -> Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewNotifyRigidBodyCollision                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision");

	UPrimitiveComponent_SetNotifyRigidBodyCollision_Params params {};
	params.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E2D0
//		Name   -> Function Engine.PrimitiveComponent.SetMaterial
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetMaterial(int ElementIndex, class UMaterialInterface* Material)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMaterial");

	UPrimitiveComponent_SetMaterial_Params params {};
	params.ElementIndex = ElementIndex;
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E180
//		Name   -> Function Engine.PrimitiveComponent.SetMassScale
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InMassScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetMassScale(const struct FName& BoneName, float InMassScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMassScale");

	UPrimitiveComponent_SetMassScale_Params params {};
	params.BoneName = BoneName;
	params.InMassScale = InMassScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E080
//		Name   -> Function Engine.PrimitiveComponent.SetMassOverrideInKg
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MassInKg                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bOverrideMass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetMassOverrideInKg(const struct FName& BoneName, float MassInKg, bool bOverrideMass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMassOverrideInKg");

	UPrimitiveComponent_SetMassOverrideInKg_Params params {};
	params.BoneName = BoneName;
	params.MassInKg = MassInKg;
	params.bOverrideMass = bOverrideMass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3DF70
//		Name   -> Function Engine.PrimitiveComponent.SetLockedAxis
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EDOFMode>                       LockedAxis                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetLockedAxis(TEnumAsByte<Engine_EDOFMode> LockedAxis)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetLockedAxis");

	UPrimitiveComponent_SetLockedAxis_Params params {};
	params.LockedAxis = LockedAxis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D730
//		Name   -> Function Engine.PrimitiveComponent.SetLinearDamping
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InDamping                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetLinearDamping(float InDamping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetLinearDamping");

	UPrimitiveComponent_SetLinearDamping_Params params {};
	params.InDamping = InDamping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3CEB0
//		Name   -> Function Engine.PrimitiveComponent.SetGenerateOverlapEvents
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetGenerateOverlapEvents(bool bEnable)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetGenerateOverlapEvents");

	UPrimitiveComponent_SetGenerateOverlapEvents_Params params {};
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3CAD0
//		Name   -> Function Engine.PrimitiveComponent.SetEnableGravity
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bGravityEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetEnableGravity(bool bGravityEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetEnableGravity");

	UPrimitiveComponent_SetEnableGravity_Params params {};
	params.bGravityEnabled = bGravityEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C6B0
//		Name   -> Function Engine.PrimitiveComponent.SetCustomPrimitiveVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                Index                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetCustomPrimitiveVector(int Index, const struct FVector& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveVector");

	UPrimitiveComponent_SetCustomPrimitiveVector_Params params {};
	params.Index = Index;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C5E0
//		Name   -> Function Engine.PrimitiveComponent.SetCustomPrimitiveScalar
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Index                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetCustomPrimitiveScalar(int Index, float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveScalar");

	UPrimitiveComponent_SetCustomPrimitiveScalar_Params params {};
	params.Index = Index;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C400
//		Name   -> Function Engine.PrimitiveComponent.SetCustomDepthStencilValue
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetCustomDepthStencilValue(int Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomDepthStencilValue");

	UPrimitiveComponent_SetCustomDepthStencilValue_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C300
//		Name   -> Function Engine.PrimitiveComponent.SetCullDistance
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewCullDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetCullDistance(float NewCullDistance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCullDistance");

	UPrimitiveComponent_SetCullDistance_Params params {};
	params.NewCullDistance = NewCullDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3BF60
//		Name   -> Function Engine.PrimitiveComponent.SetConstraintMode
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EDOFMode>                       ConstraintMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetConstraintMode(TEnumAsByte<Engine_EDOFMode> ConstraintMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetConstraintMode");

	UPrimitiveComponent_SetConstraintMode_Params params {};
	params.ConstraintMode = ConstraintMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3BBB0
//		Name   -> Function Engine.PrimitiveComponent.SetCollisionResponseToChannel
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ECollisionChannel>              Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECollisionResponse>             NewResponse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetCollisionResponseToChannel(TEnumAsByte<Engine_ECollisionChannel> Channel, TEnumAsByte<Engine_ECollisionResponse> NewResponse)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseToChannel");

	UPrimitiveComponent_SetCollisionResponseToChannel_Params params {};
	params.Channel = Channel;
	params.NewResponse = NewResponse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3BB30
//		Name   -> Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ECollisionResponse>             NewResponse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetCollisionResponseToAllChannels(TEnumAsByte<Engine_ECollisionResponse> NewResponse)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels");

	UPrimitiveComponent_SetCollisionResponseToAllChannels_Params params {};
	params.NewResponse = NewResponse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3BAA0
//		Name   -> Function Engine.PrimitiveComponent.SetCollisionProfileName
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       InCollisionProfileName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetCollisionProfileName(const struct FName& InCollisionProfileName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionProfileName");

	UPrimitiveComponent_SetCollisionProfileName_Params params {};
	params.InCollisionProfileName = InCollisionProfileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3BA20
//		Name   -> Function Engine.PrimitiveComponent.SetCollisionObjectType
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ECollisionChannel>              Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetCollisionObjectType(TEnumAsByte<Engine_ECollisionChannel> Channel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionObjectType");

	UPrimitiveComponent_SetCollisionObjectType_Params params {};
	params.Channel = Channel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B9A0
//		Name   -> Function Engine.PrimitiveComponent.SetCollisionEnabled
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ECollisionEnabled>              NewType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetCollisionEnabled(TEnumAsByte<Engine_ECollisionEnabled> NewType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionEnabled");

	UPrimitiveComponent_SetCollisionEnabled_Params params {};
	params.NewType = NewType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B600
//		Name   -> Function Engine.PrimitiveComponent.SetCenterOfMass
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     CenterOfMassOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetCenterOfMass(const struct FVector& CenterOfMassOffset, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCenterOfMass");

	UPrimitiveComponent_SetCenterOfMass_Params params {};
	params.CenterOfMassOffset = CenterOfMassOffset;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B450
//		Name   -> Function Engine.PrimitiveComponent.SetCastShadow
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               NewCastShadow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetCastShadow(bool NewCastShadow)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCastShadow");

	UPrimitiveComponent_SetCastShadow_Params params {};
	params.NewCastShadow = NewCastShadow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A230
//		Name   -> Function Engine.PrimitiveComponent.SetAngularDamping
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InDamping                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetAngularDamping(float InDamping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAngularDamping");

	UPrimitiveComponent_SetAngularDamping_Params params {};
	params.InDamping = InDamping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A150
//		Name   -> Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAddToCurrent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::SetAllPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity");

	UPrimitiveComponent_SetAllPhysicsLinearVelocity_Params params {};
	params.NewVel = NewVel;
	params.bAddToCurrent = bAddToCurrent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39D30
//		Name   -> Function Engine.PrimitiveComponent.SetAllMassScale
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InMassScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::SetAllMassScale(float InMassScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllMassScale");

	UPrimitiveComponent_SetAllMassScale_Params params {};
	params.InMassScale = InMassScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B395B0
//		Name   -> Function Engine.PrimitiveComponent.ScaleByMomentOfInertia
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     InputVector                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPrimitiveComponent::ScaleByMomentOfInertia(const struct FVector& InputVector, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ScaleByMomentOfInertia");

	UPrimitiveComponent_ScaleByMomentOfInertia_Params params {};
	params.InputVector = InputVector;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B38F80
//		Name   -> Function Engine.PrimitiveComponent.PutRigidBodyToSleep
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::PutRigidBodyToSleep(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.PutRigidBodyToSleep");

	UPrimitiveComponent_PutRigidBodyToSleep_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37410
//		Name   -> Function Engine.PrimitiveComponent.K2_LineTraceComponent
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     TraceStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     TraceEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bShowTrace                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     HitLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     HitNormal                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UPrimitiveComponent::K2_LineTraceComponent(const struct FVector& TraceStart, const struct FVector& TraceEnd, bool bTraceComplex, bool bShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, struct FName* BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_LineTraceComponent");

	UPrimitiveComponent_K2_LineTraceComponent_Params params {};
	params.TraceStart = TraceStart;
	params.TraceEnd = TraceEnd;
	params.bTraceComplex = bTraceComplex;
	params.bShowTrace = bShowTrace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HitLocation != nullptr)
		*HitLocation = params.HitLocation;
	if (HitNormal != nullptr)
		*HitNormal = params.HitNormal;
	if (BoneName != nullptr)
		*BoneName = params.BoneName;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B37020
//		Name   -> Function Engine.PrimitiveComponent.IsOverlappingComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UPrimitiveComponent*                         OtherComp                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UPrimitiveComponent::IsOverlappingComponent(class UPrimitiveComponent* OtherComp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsOverlappingComponent");

	UPrimitiveComponent_IsOverlappingComponent_Params params {};
	params.OtherComp = OtherComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36F90
//		Name   -> Function Engine.PrimitiveComponent.IsOverlappingActor
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UPrimitiveComponent::IsOverlappingActor(class AActor* Other)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsOverlappingActor");

	UPrimitiveComponent_IsOverlappingActor_Params params {};
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36DC0
//		Name   -> Function Engine.PrimitiveComponent.IsGravityEnabled
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UPrimitiveComponent::IsGravityEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsGravityEnabled");

	UPrimitiveComponent_IsGravityEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36970
//		Name   -> Function Engine.PrimitiveComponent.IgnoreActorWhenMoving
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bShouldIgnore                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::IgnoreActorWhenMoving(class AActor* Actor, bool bShouldIgnore)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IgnoreActorWhenMoving");

	UPrimitiveComponent_IgnoreActorWhenMoving_Params params {};
	params.Actor = Actor;
	params.bShouldIgnore = bShouldIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B361A0
//		Name   -> Function Engine.PrimitiveComponent.GetWalkableSlopeOverride
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FWalkableSlopeOverride                      ReturnValue                                                (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm)
struct FWalkableSlopeOverride UPrimitiveComponent::GetWalkableSlopeOverride()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetWalkableSlopeOverride");

	UPrimitiveComponent_GetWalkableSlopeOverride_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33E90
//		Name   -> Function Engine.PrimitiveComponent.GetPhysicsLinearVelocityAtPoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Point                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPrimitiveComponent::GetPhysicsLinearVelocityAtPoint(const struct FVector& Point, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsLinearVelocityAtPoint");

	UPrimitiveComponent_GetPhysicsLinearVelocityAtPoint_Params params {};
	params.Point = Point;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33DF0
//		Name   -> Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPrimitiveComponent::GetPhysicsLinearVelocity(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity");

	UPrimitiveComponent_GetPhysicsLinearVelocity_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33D50
//		Name   -> Function Engine.PrimitiveComponent.GetPhysicsAngularVelocity
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPrimitiveComponent::GetPhysicsAngularVelocity(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsAngularVelocity");

	UPrimitiveComponent_GetPhysicsAngularVelocity_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33690
//		Name   -> Function Engine.PrimitiveComponent.GetOverlappingComponents
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<class UPrimitiveComponent*>                 InOverlappingComponents                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
void UPrimitiveComponent::GetOverlappingComponents(TArray<class UPrimitiveComponent*>* InOverlappingComponents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlappingComponents");

	UPrimitiveComponent_GetOverlappingComponents_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (InOverlappingComponents != nullptr)
		*InOverlappingComponents = params.InOverlappingComponents;

}


// Function:
//		Offset -> 0x02B33590
//		Name   -> Function Engine.PrimitiveComponent.GetOverlappingActors
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<class AActor*>                              OverlappingActors                                          (Parm, OutParm, ZeroConstructor)
//		class UClass*                                      ClassFilter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::GetOverlappingActors(TArray<class AActor*>* OverlappingActors, class UClass* ClassFilter)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlappingActors");

	UPrimitiveComponent_GetOverlappingActors_Params params {};
	params.ClassFilter = ClassFilter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OverlappingActors != nullptr)
		*OverlappingActors = params.OverlappingActors;

}


// Function:
//		Offset -> 0x02B33370
//		Name   -> Function Engine.PrimitiveComponent.GetOverlapInfos
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<struct FOverlapInfo>                        ReturnValue                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm)
TArray<struct FOverlapInfo> UPrimitiveComponent::GetOverlapInfos()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlapInfos");

	UPrimitiveComponent_GetOverlapInfos_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B332B0
//		Name   -> Function Engine.PrimitiveComponent.GetNumMaterials
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UPrimitiveComponent::GetNumMaterials()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetNumMaterials");

	UPrimitiveComponent_GetNumMaterials_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32DE0
//		Name   -> Function Engine.PrimitiveComponent.GetMaterial
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInterface*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInterface* UPrimitiveComponent::GetMaterial(int ElementIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMaterial");

	UPrimitiveComponent_GetMaterial_Params params {};
	params.ElementIndex = ElementIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32D20
//		Name   -> Function Engine.PrimitiveComponent.GetMassScale
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UPrimitiveComponent::GetMassScale(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMassScale");

	UPrimitiveComponent_GetMassScale_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32CE0
//		Name   -> Function Engine.PrimitiveComponent.GetMass
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UPrimitiveComponent::GetMass()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMass");

	UPrimitiveComponent_GetMass_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32710
//		Name   -> Function Engine.PrimitiveComponent.GetLinearDamping
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UPrimitiveComponent::GetLinearDamping()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetLinearDamping");

	UPrimitiveComponent_GetLinearDamping_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B324D0
//		Name   -> Function Engine.PrimitiveComponent.GetInertiaTensor
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPrimitiveComponent::GetInertiaTensor(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetInertiaTensor");

	UPrimitiveComponent_GetInertiaTensor_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31C80
//		Name   -> Function Engine.PrimitiveComponent.GetCollisionResponseToChannel
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_ECollisionChannel>              Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECollisionResponse>             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
TEnumAsByte<Engine_ECollisionResponse> UPrimitiveComponent::GetCollisionResponseToChannel(TEnumAsByte<Engine_ECollisionChannel> Channel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionResponseToChannel");

	UPrimitiveComponent_GetCollisionResponseToChannel_Params params {};
	params.Channel = Channel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31C40
//		Name   -> Function Engine.PrimitiveComponent.GetCollisionProfileName
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName UPrimitiveComponent::GetCollisionProfileName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionProfileName");

	UPrimitiveComponent_GetCollisionProfileName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31C10
//		Name   -> Function Engine.PrimitiveComponent.GetCollisionObjectType
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_ECollisionChannel>              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
TEnumAsByte<Engine_ECollisionChannel> UPrimitiveComponent::GetCollisionObjectType()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionObjectType");

	UPrimitiveComponent_GetCollisionObjectType_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31AA0
//		Name   -> Function Engine.PrimitiveComponent.GetClosestPointOnCollision
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     Point                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     OutPointOnBody                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UPrimitiveComponent::GetClosestPointOnCollision(const struct FVector& Point, struct FVector* OutPointOnBody, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetClosestPointOnCollision");

	UPrimitiveComponent_GetClosestPointOnCollision_Params params {};
	params.Point = Point;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutPointOnBody != nullptr)
		*OutPointOnBody = params.OutPointOnBody;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31A00
//		Name   -> Function Engine.PrimitiveComponent.GetCenterOfMass
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPrimitiveComponent::GetCenterOfMass(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCenterOfMass");

	UPrimitiveComponent_GetCenterOfMass_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31760
//		Name   -> Function Engine.PrimitiveComponent.GetAngularDamping
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UPrimitiveComponent::GetAngularDamping()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetAngularDamping");

	UPrimitiveComponent_GetAngularDamping_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F4B0
//		Name   -> Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInterface*                          SourceMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInstanceDynamic*                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInstanceDynamic* UPrimitiveComponent::CreateDynamicMaterialInstance(int ElementIndex, class UMaterialInterface* SourceMaterial)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance");

	UPrimitiveComponent_CreateDynamicMaterialInstance_Params params {};
	params.ElementIndex = ElementIndex;
	params.SourceMaterial = SourceMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F3B0
//		Name   -> Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInterface*                          Parent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInstanceDynamic*                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamicFromMaterial(int ElementIndex, class UMaterialInterface* Parent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial");

	UPrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial_Params params {};
	params.ElementIndex = ElementIndex;
	params.Parent = Parent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F310
//		Name   -> Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInstanceDynamic*                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamic(int ElementIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic");

	UPrimitiveComponent_CreateAndSetMaterialInstanceDynamic_Params params {};
	params.ElementIndex = ElementIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F270
//		Name   -> Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreActors
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TArray<class AActor*>                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<class AActor*> UPrimitiveComponent::CopyArrayOfMoveIgnoreActors()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreActors");

	UPrimitiveComponent_CopyArrayOfMoveIgnoreActors_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2EE50
//		Name   -> Function Engine.PrimitiveComponent.ClearMoveIgnoreActors
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                InSlack                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::ClearMoveIgnoreActors(int InSlack)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ClearMoveIgnoreActors");

	UPrimitiveComponent_ClearMoveIgnoreActors_Params params {};
	params.InSlack = InSlack;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2EA70
//		Name   -> Function Engine.PrimitiveComponent.CanCharacterStepUp
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UPrimitiveComponent::CanCharacterStepUp(class APawn* Pawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CanCharacterStepUp");

	UPrimitiveComponent_CanCharacterStepUp_Params params {};
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2E700
//		Name   -> Function Engine.PrimitiveComponent.AddTorque
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Torque                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bAccelChange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::AddTorque(const struct FVector& Torque, const struct FName& BoneName, bool bAccelChange)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddTorque");

	UPrimitiveComponent_AddTorque_Params params {};
	params.Torque = Torque;
	params.BoneName = BoneName;
	params.bAccelChange = bAccelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2E340
//		Name   -> Function Engine.PrimitiveComponent.AddRadialImpulse
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ERadialImpulseFalloff>          Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bVelChange                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, TEnumAsByte<Engine_ERadialImpulseFalloff> Falloff, bool bVelChange)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddRadialImpulse");

	UPrimitiveComponent_AddRadialImpulse_Params params {};
	params.Origin = Origin;
	params.Radius = Radius;
	params.Strength = Strength;
	params.Falloff = Falloff;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2E180
//		Name   -> Function Engine.PrimitiveComponent.AddRadialForce
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ERadialImpulseFalloff>          Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bAccelChange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::AddRadialForce(const struct FVector& Origin, float Radius, float Strength, TEnumAsByte<Engine_ERadialImpulseFalloff> Falloff, bool bAccelChange)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddRadialForce");

	UPrimitiveComponent_AddRadialForce_Params params {};
	params.Origin = Origin;
	params.Radius = Radius;
	params.Strength = Strength;
	params.Falloff = Falloff;
	params.bAccelChange = bAccelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2DDB0
//		Name   -> Function Engine.PrimitiveComponent.AddImpulseAtLocation
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::AddImpulseAtLocation(const struct FVector& Impulse, const struct FVector& Location, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddImpulseAtLocation");

	UPrimitiveComponent_AddImpulseAtLocation_Params params {};
	params.Impulse = Impulse;
	params.Location = Location;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2DC90
//		Name   -> Function Engine.PrimitiveComponent.AddImpulse
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bVelChange                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::AddImpulse(const struct FVector& Impulse, const struct FName& BoneName, bool bVelChange)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddImpulse");

	UPrimitiveComponent_AddImpulse_Params params {};
	params.Impulse = Impulse;
	params.BoneName = BoneName;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2D9D0
//		Name   -> Function Engine.PrimitiveComponent.AddForceAtLocation
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPrimitiveComponent::AddForceAtLocation(const struct FVector& Force, const struct FVector& Location, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForceAtLocation");

	UPrimitiveComponent_AddForceAtLocation_Params params {};
	params.Force = Force;
	params.Location = Location;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2D8B0
//		Name   -> Function Engine.PrimitiveComponent.AddForce
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bAccelChange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::AddForce(const struct FVector& Force, const struct FName& BoneName, bool bAccelChange)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForce");

	UPrimitiveComponent_AddForce_Params params {};
	params.Force = Force;
	params.BoneName = BoneName;
	params.bAccelChange = bAccelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2D0B0
//		Name   -> Function Engine.PrimitiveComponent.AddAngularImpulse
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bVelChange                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPrimitiveComponent::AddAngularImpulse(const struct FVector& Impulse, const struct FName& BoneName, bool bVelChange)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddAngularImpulse");

	UPrimitiveComponent_AddAngularImpulse_Params params {};
	params.Impulse = Impulse;
	params.BoneName = BoneName;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UPrimitiveComponent::AfterRead()
{
	USceneComponent::AfterRead();

	READ_PTR_FULL(LODParentPrimitive, UPrimitiveComponent);
	READ_PTR_FULL(MergedCollisionComponentParent, UPrimitiveComponent);
}

void UPrimitiveComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

	DELE_PTR_FULL(LODParentPrimitive);
	DELE_PTR_FULL(MergedCollisionComponentParent);
}

// Function:
//		Offset -> 0x02B38440
//		Name   -> Function Engine.GameState.OnRep_SpectatorClass
//		Flags  -> (Native, Public)
void AGameState::OnRep_SpectatorClass()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_SpectatorClass");

	AGameState_OnRep_SpectatorClass_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38380
//		Name   -> Function Engine.GameState.OnRep_ReplicatedWorldTimeSeconds
//		Flags  -> (Native, Protected)
void AGameState::OnRep_ReplicatedWorldTimeSeconds()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_ReplicatedWorldTimeSeconds");

	AGameState_OnRep_ReplicatedWorldTimeSeconds_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38280
//		Name   -> Function Engine.GameState.OnRep_MatchState
//		Flags  -> (Native, Public)
void AGameState::OnRep_MatchState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_MatchState");

	AGameState_OnRep_MatchState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38240
//		Name   -> Function Engine.GameState.OnRep_GameModeClass
//		Flags  -> (Native, Public)
void AGameState::OnRep_GameModeClass()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_GameModeClass");

	AGameState_OnRep_GameModeClass_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38220
//		Name   -> Function Engine.GameState.OnRep_ElapsedTime
//		Flags  -> (Native, Public)
void AGameState::OnRep_ElapsedTime()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_ElapsedTime");

	AGameState_OnRep_ElapsedTime_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B35450
//		Name   -> Function Engine.GameState.GetServerWorldTimeSeconds
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float AGameState::GetServerWorldTimeSeconds()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameState.GetServerWorldTimeSeconds");

	AGameState_GetServerWorldTimeSeconds_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void AGameState::AfterRead()
{
	AInfo::AfterRead();

	READ_PTR_FULL(GameModeClass, UClass);
	READ_PTR_FULL(AuthorityGameMode, AGameMode);
	READ_PTR_FULL(SpectatorClass, UClass);
}

void AGameState::BeforeDelete()
{
	AInfo::BeforeDelete();

	DELE_PTR_FULL(GameModeClass);
	DELE_PTR_FULL(AuthorityGameMode);
	DELE_PTR_FULL(SpectatorClass);
}

void UGameUserSettings::AfterRead()
{
	UObject::AfterRead();

}

void UGameUserSettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UScriptViewportClient::AfterRead()
{
	UObject::AfterRead();

}

void UScriptViewportClient::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02EEE0E0
//		Name   -> Function Engine.GameViewportClient.SSSwapControllers
//		Flags  -> (Exec, Native, Public)
void UGameViewportClient::SSSwapControllers()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.SSSwapControllers");

	UGameViewportClient_SSSwapControllers_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02EEE190
//		Name   -> Function Engine.GameViewportClient.ShowTitleSafeArea
//		Flags  -> (Exec, Native, Public)
void UGameViewportClient::ShowTitleSafeArea()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.ShowTitleSafeArea");

	UGameViewportClient_ShowTitleSafeArea_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02EEE100
//		Name   -> Function Engine.GameViewportClient.SetConsoleTarget
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		int                                                PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameViewportClient::SetConsoleTarget(int PlayerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.SetConsoleTarget");

	UGameViewportClient_SetConsoleTarget_Params params {};
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UGameViewportClient::AfterRead()
{
	UScriptViewportClient::AfterRead();

	READ_PTR_FULL(ViewportConsole, UConsole);
	READ_PTR_FULL(World, UWorld);
	READ_PTR_FULL(GameInstance, UGameInstance);
}

void UGameViewportClient::BeforeDelete()
{
	UScriptViewportClient::BeforeDelete();

	DELE_PTR_FULL(ViewportConsole);
	DELE_PTR_FULL(World);
	DELE_PTR_FULL(GameInstance);
}

// Function:
//		Offset -> 0x02B38460
//		Name   -> Function Engine.PlayerState.OnRep_UniqueId
//		Flags  -> (Native, Public)
void APlayerState::OnRep_UniqueId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_UniqueId");

	APlayerState_OnRep_UniqueId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B382A0
//		Name   -> Function Engine.PlayerState.OnRep_PlayerName
//		Flags  -> (Native, Public)
void APlayerState::OnRep_PlayerName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_PlayerName");

	APlayerState_OnRep_PlayerName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void APlayerState::AfterRead()
{
	AInfo::AfterRead();

	READ_PTR_FULL(EngineMessageClass, UClass);
}

void APlayerState::BeforeDelete()
{
	AInfo::BeforeDelete();

	DELE_PTR_FULL(EngineMessageClass);
}

// Function:
//		Offset -> 0x02A3AF10
//		Name   -> Function Engine.Controller.UnPossess
//		Flags  -> (Native, Public, BlueprintCallable)
void AController::UnPossess()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.UnPossess");

	AController_UnPossess_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3ACE0
//		Name   -> Function Engine.Controller.StopMovement
//		Flags  -> (Native, Public, BlueprintCallable)
void AController::StopMovement()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.StopMovement");

	AController_StopMovement_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A395B0
//		Name   -> Function Engine.Controller.SetInitialLocationAndRotation
//		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    NewRotation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void AController::SetInitialLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetInitialLocationAndRotation");

	AController_SetInitialLocationAndRotation_Params params {};
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38F90
//		Name   -> Function Engine.Controller.SetControlRotation
//		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    NewRotation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void AController::SetControlRotation(const struct FRotator& NewRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetControlRotation");

	AController_SetControlRotation_Params params {};
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.Controller.ReceiveInstigatedAnyDamage
//		Flags  -> (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)
// Parameters:
//		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AController::ReceiveInstigatedAnyDamage(float Damage, class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.ReceiveInstigatedAnyDamage");

	AController_ReceiveInstigatedAnyDamage_Params params {};
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.DamagedActor = DamagedActor;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36EF0
//		Name   -> Function Engine.Controller.Possess
//		Flags  -> (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class APawn*                                       InPawn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AController::Possess(class APawn* InPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.Possess");

	AController_Possess_Params params {};
	params.InPawn = InPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36460
//		Name   -> Function Engine.Controller.OnRep_PlayerState
//		Flags  -> (Native, Public)
void AController::OnRep_PlayerState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.OnRep_PlayerState");

	AController_OnRep_PlayerState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36440
//		Name   -> Function Engine.Controller.OnRep_Pawn
//		Flags  -> (Native, Public)
void AController::OnRep_Pawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.OnRep_Pawn");

	AController_OnRep_Pawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A35FF0
//		Name   -> Function Engine.Controller.LineOfSightTo
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ViewPoint                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAlternateChecks                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AController::LineOfSightTo(class AActor* Other, const struct FVector& ViewPoint, bool bAlternateChecks)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.LineOfSightTo");

	AController_LineOfSightTo_Params params {};
	params.Other = Other;
	params.ViewPoint = ViewPoint;
	params.bAlternateChecks = bAlternateChecks;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A34470
//		Name   -> Function Engine.Controller.K2_GetPawn
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APawn*                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APawn* AController::K2_GetPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.K2_GetPawn");

	AController_K2_GetPawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A32260
//		Name   -> Function Engine.Controller.IsLocalPlayerController
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AController::IsLocalPlayerController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsLocalPlayerController");

	AController_IsLocalPlayerController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A32230
//		Name   -> Function Engine.Controller.IsLocalController
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AController::IsLocalController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsLocalController");

	AController_IsLocalController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31D10
//		Name   -> Function Engine.Controller.GetViewTarget
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* AController::GetViewTarget()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetViewTarget");

	AController_GetViewTarget_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F5F0
//		Name   -> Function Engine.Controller.GetDesiredRotation
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator AController::GetDesiredRotation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetDesiredRotation");

	AController_GetDesiredRotation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F090
//		Name   -> Function Engine.Controller.GetControlRotation
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator AController::GetControlRotation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetControlRotation");

	AController_GetControlRotation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2CA90
//		Name   -> Function Engine.Controller.ClientSetRotation
//		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bResetCamera                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AController::ClientSetRotation(const struct FRotator& NewRotation, bool bResetCamera)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.ClientSetRotation");

	AController_ClientSetRotation_Params params {};
	params.NewRotation = NewRotation;
	params.bResetCamera = bResetCamera;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C9B0
//		Name   -> Function Engine.Controller.ClientSetLocation
//		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
//		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AController::ClientSetLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.ClientSetLocation");

	AController_ClientSetLocation_Params params {};
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2ADF0
//		Name   -> Function Engine.Controller.CastToPlayerController
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APlayerController*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APlayerController* AController::CastToPlayerController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Controller.CastToPlayerController");

	AController_CastToPlayerController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void AController::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(Pawn, APawn);
	READ_PTR_FULL(Character, ACharacter);
	READ_PTR_FULL(PlayerState, APlayerState);
	READ_PTR_FULL(TransformComponent, USceneComponent);
}

void AController::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(Pawn);
	DELE_PTR_FULL(Character);
	DELE_PTR_FULL(PlayerState);
	DELE_PTR_FULL(TransformComponent);
}

// Function:
//		Offset -> 0x02A3B2C0
//		Name   -> Function Engine.PlayerController.WasInputKeyJustReleased
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::WasInputKeyJustReleased(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.WasInputKeyJustReleased");

	APlayerController_WasInputKeyJustReleased_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A3B1C0
//		Name   -> Function Engine.PlayerController.WasInputKeyJustPressed
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::WasInputKeyJustPressed(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.WasInputKeyJustPressed");

	APlayerController_WasInputKeyJustPressed_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A3ADF0
//		Name   -> Function Engine.PlayerController.ToggleSpeaking
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		bool                                               bInSpeaking                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ToggleSpeaking(bool bInSpeaking)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ToggleSpeaking");

	APlayerController_ToggleSpeaking_Params params {};
	params.bInSpeaking = bInSpeaking;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3AD00
//		Name   -> Function Engine.PlayerController.SwitchLevel
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FString                                     URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash)
void APlayerController::SwitchLevel(const struct FString& URL)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SwitchLevel");

	APlayerController_SwitchLevel_Params params {};
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3AC60
//		Name   -> Function Engine.PlayerController.StopHapticEffect
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<InputCore_EControllerHand>             Hand                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::StopHapticEffect(TEnumAsByte<InputCore_EControllerHand> Hand)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.StopHapticEffect");

	APlayerController_StopHapticEffect_Params params {};
	params.Hand = Hand;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A830
//		Name   -> Function Engine.PlayerController.StartFire
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		unsigned char                                      FireModeNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::StartFire(unsigned char FireModeNum)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.StartFire");

	APlayerController_StartFire_Params params {};
	params.FireModeNum = FireModeNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A150
//		Name   -> Function Engine.PlayerController.SetVirtualJoystickVisibility
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::SetVirtualJoystickVisibility(bool bVisible)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetVirtualJoystickVisibility");

	APlayerController_SetVirtualJoystickVisibility_Params params {};
	params.bVisible = bVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39FD0
//		Name   -> Function Engine.PlayerController.SetViewTargetWithBlend
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      NewViewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EViewTargetBlendFunction>       BlendFunc                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bLockOutgoing                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::SetViewTargetWithBlend(class AActor* NewViewTarget, float BlendTime, TEnumAsByte<Engine_EViewTargetBlendFunction> BlendFunc, float BlendExp, bool bLockOutgoing)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetViewTargetWithBlend");

	APlayerController_SetViewTargetWithBlend_Params params {};
	params.NewViewTarget = NewViewTarget;
	params.BlendTime = BlendTime;
	params.BlendFunc = BlendFunc;
	params.BlendExp = BlendExp;
	params.bLockOutgoing = bLockOutgoing;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39950
//		Name   -> Function Engine.PlayerController.SetName
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FString                                     S                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
void APlayerController::SetName(const struct FString& S)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetName");

	APlayerController_SetName_Params params {};
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39490
//		Name   -> Function Engine.PlayerController.SetIgnoreMoveInput
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewMoveInput                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::SetIgnoreMoveInput(bool bNewMoveInput)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetIgnoreMoveInput");

	APlayerController_SetIgnoreMoveInput_Params params {};
	params.bNewMoveInput = bNewMoveInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39400
//		Name   -> Function Engine.PlayerController.SetIgnoreLookInput
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewLookInput                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::SetIgnoreLookInput(bool bNewLookInput)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetIgnoreLookInput");

	APlayerController_SetIgnoreLookInput_Params params {};
	params.bNewLookInput = bNewLookInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39220
//		Name   -> Function Engine.PlayerController.SetHapticsByValue
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Frequency                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Amplitude                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<InputCore_EControllerHand>             Hand                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::SetHapticsByValue(float Frequency, float Amplitude, TEnumAsByte<InputCore_EControllerHand> Hand)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetHapticsByValue");

	APlayerController_SetHapticsByValue_Params params {};
	params.Frequency = Frequency;
	params.Amplitude = Amplitude;
	params.Hand = Hand;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38D40
//		Name   -> Function Engine.PlayerController.SetCinematicMode
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bInCinematicMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bHidePlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAffectsHUD                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAffectsMovement                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAffectsTurning                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetCinematicMode");

	APlayerController_SetCinematicMode_Params params {};
	params.bInCinematicMode = bInCinematicMode;
	params.bHidePlayer = bHidePlayer;
	params.bAffectsHUD = bAffectsHUD;
	params.bAffectsMovement = bAffectsMovement;
	params.bAffectsTurning = bAffectsTurning;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38B20
//		Name   -> Function Engine.PlayerController.SetAudioListenerOverride
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class USceneComponent*                             AttachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::SetAudioListenerOverride(class USceneComponent* AttachToComponent, const struct FVector& Location, const struct FRotator& Rotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetAudioListenerOverride");

	APlayerController_SetAudioListenerOverride_Params params {};
	params.AttachToComponent = AttachToComponent;
	params.Location = Location;
	params.Rotation = Rotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38390
//		Name   -> Function Engine.PlayerController.ServerViewSelf
//		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FViewTargetTransitionParams                 TransitionParams                                           (Parm)
void APlayerController::ServerViewSelf(const struct FViewTargetTransitionParams& TransitionParams)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewSelf");

	APlayerController_ServerViewSelf_Params params {};
	params.TransitionParams = TransitionParams;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38340
//		Name   -> Function Engine.PlayerController.ServerViewPrevPlayer
//		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
void APlayerController::ServerViewPrevPlayer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewPrevPlayer");

	APlayerController_ServerViewPrevPlayer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A382F0
//		Name   -> Function Engine.PlayerController.ServerViewNextPlayer
//		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
void APlayerController::ServerViewNextPlayer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewNextPlayer");

	APlayerController_ServerViewNextPlayer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A382A0
//		Name   -> Function Engine.PlayerController.ServerVerifyViewTarget
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APlayerController::ServerVerifyViewTarget()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerVerifyViewTarget");

	APlayerController_ServerVerifyViewTarget_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38180
//		Name   -> Function Engine.PlayerController.ServerUpdateCamera
//		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FVector_NetQuantize                         CamLoc                                                     (Parm)
//		int                                                CamPitchAndYaw                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ServerUpdateCamera(const struct FVector_NetQuantize& CamLoc, int CamPitchAndYaw)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateCamera");

	APlayerController_ServerUpdateCamera_Params params {};
	params.CamLoc = CamLoc;
	params.CamPitchAndYaw = CamPitchAndYaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38030
//		Name   -> Function Engine.PlayerController.ServerUnmutePlayer
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FUniqueNetIdRepl                            PlayerId                                                   (Parm)
void APlayerController::ServerUnmutePlayer(const struct FUniqueNetIdRepl& PlayerId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUnmutePlayer");

	APlayerController_ServerUnmutePlayer_Params params {};
	params.PlayerId = PlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37FE0
//		Name   -> Function Engine.PlayerController.ServerToggleAILogging
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APlayerController::ServerToggleAILogging()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerToggleAILogging");

	APlayerController_ServerToggleAILogging_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37F90
//		Name   -> Function Engine.PlayerController.ServerShortTimeout
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APlayerController::ServerShortTimeout()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerShortTimeout");

	APlayerController_ServerShortTimeout_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37ED0
//		Name   -> Function Engine.PlayerController.ServerSetSpectatorWaiting
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		bool                                               bWaiting                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ServerSetSpectatorWaiting(bool bWaiting)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerSetSpectatorWaiting");

	APlayerController_ServerSetSpectatorWaiting_Params params {};
	params.bWaiting = bWaiting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37DA0
//		Name   -> Function Engine.PlayerController.ServerSetSpectatorLocation
//		Flags  -> (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
//		struct FVector                                     NewLoc                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    NewRot                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ServerSetSpectatorLocation(const struct FVector& NewLoc, const struct FRotator& NewRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerSetSpectatorLocation");

	APlayerController_ServerSetSpectatorLocation_Params params {};
	params.NewLoc = NewLoc;
	params.NewRot = NewRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37D50
//		Name   -> Function Engine.PlayerController.ServerRestartPlayer
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APlayerController::ServerRestartPlayer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerRestartPlayer");

	APlayerController_ServerRestartPlayer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37D00
//		Name   -> Function Engine.PlayerController.ServerPause
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APlayerController::ServerPause()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerPause");

	APlayerController_ServerPause_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37C50
//		Name   -> Function Engine.PlayerController.ServerNotifyLoadedWorld
//		Flags  -> (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FName                                       WorldPackageName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ServerNotifyLoadedWorld(const struct FName& WorldPackageName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerNotifyLoadedWorld");

	APlayerController_ServerNotifyLoadedWorld_Params params {};
	params.WorldPackageName = WorldPackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37B00
//		Name   -> Function Engine.PlayerController.ServerMutePlayer
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FUniqueNetIdRepl                            PlayerId                                                   (Parm)
void APlayerController::ServerMutePlayer(const struct FUniqueNetIdRepl& PlayerId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerMutePlayer");

	APlayerController_ServerMutePlayer_Params params {};
	params.PlayerId = PlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37AB0
//		Name   -> Function Engine.PlayerController.ServerCheckClientPossessionReliable
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APlayerController::ServerCheckClientPossessionReliable()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCheckClientPossessionReliable");

	APlayerController_ServerCheckClientPossessionReliable_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37A60
//		Name   -> Function Engine.PlayerController.ServerCheckClientPossession
//		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
void APlayerController::ServerCheckClientPossession()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCheckClientPossession");

	APlayerController_ServerCheckClientPossession_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37990
//		Name   -> Function Engine.PlayerController.ServerChangeName
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FString                                     S                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
void APlayerController::ServerChangeName(const struct FString& S)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerChangeName");

	APlayerController_ServerChangeName_Params params {};
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A378D0
//		Name   -> Function Engine.PlayerController.ServerCamera
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FName                                       NewMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ServerCamera(const struct FName& NewMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCamera");

	APlayerController_ServerCamera_Params params {};
	params.NewMode = NewMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37810
//		Name   -> Function Engine.PlayerController.ServerAcknowledgePossession
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class APawn*                                       P                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ServerAcknowledgePossession(class APawn* P)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerAcknowledgePossession");

	APlayerController_ServerAcknowledgePossession_Params params {};
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37760
//		Name   -> Function Engine.PlayerController.SendToConsole
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FString                                     Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash)
void APlayerController::SendToConsole(const struct FString& Command)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SendToConsole");

	APlayerController_SendToConsole_Params params {};
	params.Command = Command;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37740
//		Name   -> Function Engine.PlayerController.RestartLevel
//		Flags  -> (Exec, Native, Public)
void APlayerController::RestartLevel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.RestartLevel");

	APlayerController_RestartLevel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37700
//		Name   -> Function Engine.PlayerController.ResetIgnoreMoveInput
//		Flags  -> (Native, Public, BlueprintCallable)
void APlayerController::ResetIgnoreMoveInput()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ResetIgnoreMoveInput");

	APlayerController_ResetIgnoreMoveInput_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A376E0
//		Name   -> Function Engine.PlayerController.ResetIgnoreLookInput
//		Flags  -> (Native, Public, BlueprintCallable)
void APlayerController::ResetIgnoreLookInput()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ResetIgnoreLookInput");

	APlayerController_ResetIgnoreLookInput_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A376C0
//		Name   -> Function Engine.PlayerController.ResetIgnoreInputFlags
//		Flags  -> (Native, Public, BlueprintCallable)
void APlayerController::ResetIgnoreInputFlags()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ResetIgnoreInputFlags");

	APlayerController_ResetIgnoreInputFlags_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36F80
//		Name   -> Function Engine.PlayerController.ProjectWorldLocationToScreen
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     WorldLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ScreenLocation                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::ProjectWorldLocationToScreen(const struct FVector& WorldLocation, struct FVector2D* ScreenLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ProjectWorldLocationToScreen");

	APlayerController_ProjectWorldLocationToScreen_Params params {};
	params.WorldLocation = WorldLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (ScreenLocation != nullptr)
		*ScreenLocation = params.ScreenLocation;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A36DE0
//		Name   -> Function Engine.PlayerController.PlayHapticEffect
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UHapticFeedbackEffect*                       HapticEffect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<InputCore_EControllerHand>             Hand                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::PlayHapticEffect(class UHapticFeedbackEffect* HapticEffect, TEnumAsByte<InputCore_EControllerHand> Hand, float Scale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.PlayHapticEffect");

	APlayerController_PlayHapticEffect_Params params {};
	params.HapticEffect = HapticEffect;
	params.Hand = Hand;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36B50
//		Name   -> Function Engine.PlayerController.PlayDynamicForceFeedback
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Intensity                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bAffectsLeftLarge                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		bool                                               bAffectsLeftSmall                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		bool                                               bAffectsRightLarge                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		bool                                               bAffectsRightSmall                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		TEnumAsByte<Engine_EDynamicForceFeedbackAction>    Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
void APlayerController::PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, TEnumAsByte<Engine_EDynamicForceFeedbackAction> Action, const struct FLatentActionInfo& LatentInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.PlayDynamicForceFeedback");

	APlayerController_PlayDynamicForceFeedback_Params params {};
	params.Intensity = Intensity;
	params.Duration = Duration;
	params.bAffectsLeftLarge = bAffectsLeftLarge;
	params.bAffectsLeftSmall = bAffectsLeftSmall;
	params.bAffectsRightLarge = bAffectsRightLarge;
	params.bAffectsRightSmall = bAffectsRightSmall;
	params.Action = Action;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36620
//		Name   -> Function Engine.PlayerController.Pause
//		Flags  -> (Exec, Native, Public)
void APlayerController::Pause()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.Pause");

	APlayerController_Pause_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36590
//		Name   -> Function Engine.PlayerController.OnServerStartedVisualLogger
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		bool                                               bIsLogging                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::OnServerStartedVisualLogger(bool bIsLogging)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.OnServerStartedVisualLogger");

	APlayerController_OnServerStartedVisualLogger_Params params {};
	params.bIsLogging = bIsLogging;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36110
//		Name   -> Function Engine.PlayerController.LocalTravel
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FString                                     URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash)
void APlayerController::LocalTravel(const struct FString& URL)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.LocalTravel");

	APlayerController_LocalTravel_Params params {};
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A323E0
//		Name   -> Function Engine.PlayerController.IsSeamlessTravelInProgress
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::IsSeamlessTravelInProgress()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.IsSeamlessTravelInProgress");

	APlayerController_IsSeamlessTravelInProgress_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A32380
//		Name   -> Function Engine.PlayerController.IsPossessingServerAcknowledgedPawn
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::IsPossessingServerAcknowledgedPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.IsPossessingServerAcknowledgedPawn");

	APlayerController_IsPossessingServerAcknowledgedPawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A322C0
//		Name   -> Function Engine.PlayerController.IsMoveInputIgnored
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::IsMoveInputIgnored()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.IsMoveInputIgnored");

	APlayerController_IsMoveInputIgnored_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A32290
//		Name   -> Function Engine.PlayerController.IsLookInputIgnored
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::IsLookInputIgnored()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.IsLookInputIgnored");

	APlayerController_IsLookInputIgnored_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A32130
//		Name   -> Function Engine.PlayerController.IsInputKeyDown
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::IsInputKeyDown(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.IsInputKeyDown");

	APlayerController_IsInputKeyDown_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A31D40
//		Name   -> Function Engine.PlayerController.GetViewportSize
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                SizeX                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                SizeY                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::GetViewportSize(int* SizeX, int* SizeY)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetViewportSize");

	APlayerController_GetViewportSize_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SizeX != nullptr)
		*SizeX = params.SizeX;
	if (SizeY != nullptr)
		*SizeY = params.SizeY;

}


// Function:
//		Offset -> 0x02A317D0
//		Name   -> Function Engine.PlayerController.GetSpectatorPawn
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class ASpectatorPawn*                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class ASpectatorPawn* APlayerController::GetSpectatorPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetSpectatorPawn");

	APlayerController_GetSpectatorPawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A30FB0
//		Name   -> Function Engine.PlayerController.GetMousePosition
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              LocationX                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LocationY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::GetMousePosition(float* LocationX, float* LocationY)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetMousePosition");

	APlayerController_GetMousePosition_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (LocationX != nullptr)
		*LocationX = params.LocationX;
	if (LocationY != nullptr)
		*LocationY = params.LocationY;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A30D60
//		Name   -> Function Engine.PlayerController.GetInputVectorKeyState
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector APlayerController::GetInputVectorKeyState(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputVectorKeyState");

	APlayerController_GetInputVectorKeyState_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A30AC0
//		Name   -> Function Engine.PlayerController.GetInputTouchState
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<InputCore_ETouchIndex>                 FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LocationX                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LocationY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bIsCurrentlyPressed                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::GetInputTouchState(TEnumAsByte<InputCore_ETouchIndex> FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputTouchState");

	APlayerController_GetInputTouchState_Params params {};
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (LocationX != nullptr)
		*LocationX = params.LocationX;
	if (LocationY != nullptr)
		*LocationY = params.LocationY;
	if (bIsCurrentlyPressed != nullptr)
		*bIsCurrentlyPressed = params.bIsCurrentlyPressed;

}


// Function:
//		Offset -> 0x02A309E0
//		Name   -> Function Engine.PlayerController.GetInputMouseDelta
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              DeltaX                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              DeltaY                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::GetInputMouseDelta(float* DeltaX, float* DeltaY)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputMouseDelta");

	APlayerController_GetInputMouseDelta_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (DeltaX != nullptr)
		*DeltaX = params.DeltaX;
	if (DeltaY != nullptr)
		*DeltaY = params.DeltaY;

}


// Function:
//		Offset -> 0x02A30850
//		Name   -> Function Engine.PlayerController.GetInputMotionState
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     Tilt                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     RotationRate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Gravity                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Acceleration                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::GetInputMotionState(struct FVector* Tilt, struct FVector* RotationRate, struct FVector* Gravity, struct FVector* Acceleration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputMotionState");

	APlayerController_GetInputMotionState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Tilt != nullptr)
		*Tilt = params.Tilt;
	if (RotationRate != nullptr)
		*RotationRate = params.RotationRate;
	if (Gravity != nullptr)
		*Gravity = params.Gravity;
	if (Acceleration != nullptr)
		*Acceleration = params.Acceleration;

}


// Function:
//		Offset -> 0x02A30750
//		Name   -> Function Engine.PlayerController.GetInputKeyTimeDown
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float APlayerController::GetInputKeyTimeDown(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputKeyTimeDown");

	APlayerController_GetInputKeyTimeDown_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A30490
//		Name   -> Function Engine.PlayerController.GetInputAnalogStickState
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_EControllerAnalogStick>         WhichStick                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              StickX                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              StickY                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::GetInputAnalogStickState(TEnumAsByte<Engine_EControllerAnalogStick> WhichStick, float* StickX, float* StickY)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputAnalogStickState");

	APlayerController_GetInputAnalogStickState_Params params {};
	params.WhichStick = WhichStick;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (StickX != nullptr)
		*StickX = params.StickX;
	if (StickY != nullptr)
		*StickY = params.StickY;

}


// Function:
//		Offset -> 0x02A30390
//		Name   -> Function Engine.PlayerController.GetInputAnalogKeyState
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float APlayerController::GetInputAnalogKeyState(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputAnalogKeyState");

	APlayerController_GetInputAnalogKeyState_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F8C0
//		Name   -> Function Engine.PlayerController.GetHUD
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AHUD*                                        ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AHUD* APlayerController::GetHUD()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHUD");

	APlayerController_GetHUD_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A30080
//		Name   -> Function Engine.PlayerController.GetHitResultUnderFingerForObjects
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<InputCore_ETouchIndex>                 FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  HitResult                                                  (Parm, OutParm, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::GetHitResultUnderFingerForObjects(TEnumAsByte<InputCore_ETouchIndex> FingerIndex, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFingerForObjects");

	APlayerController_GetHitResultUnderFingerForObjects_Params params {};
	params.FingerIndex = FingerIndex;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2FEE0
//		Name   -> Function Engine.PlayerController.GetHitResultUnderFingerByChannel
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<InputCore_ETouchIndex>                 FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ETraceTypeQuery>                TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  HitResult                                                  (Parm, OutParm, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::GetHitResultUnderFingerByChannel(TEnumAsByte<InputCore_ETouchIndex> FingerIndex, TEnumAsByte<Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFingerByChannel");

	APlayerController_GetHitResultUnderFingerByChannel_Params params {};
	params.FingerIndex = FingerIndex;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2FD40
//		Name   -> Function Engine.PlayerController.GetHitResultUnderFinger
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<InputCore_ETouchIndex>                 FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECollisionChannel>              TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  HitResult                                                  (Parm, OutParm, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::GetHitResultUnderFinger(TEnumAsByte<InputCore_ETouchIndex> FingerIndex, TEnumAsByte<Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFinger");

	APlayerController_GetHitResultUnderFinger_Params params {};
	params.FingerIndex = FingerIndex;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2FBB0
//		Name   -> Function Engine.PlayerController.GetHitResultUnderCursorForObjects
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  HitResult                                                  (Parm, OutParm, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::GetHitResultUnderCursorForObjects(TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursorForObjects");

	APlayerController_GetHitResultUnderCursorForObjects_Params params {};
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2FA50
//		Name   -> Function Engine.PlayerController.GetHitResultUnderCursorByChannel
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_ETraceTypeQuery>                TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  HitResult                                                  (Parm, OutParm, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::GetHitResultUnderCursorByChannel(TEnumAsByte<Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursorByChannel");

	APlayerController_GetHitResultUnderCursorByChannel_Params params {};
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F8F0
//		Name   -> Function Engine.PlayerController.GetHitResultUnderCursor
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_ECollisionChannel>              TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  HitResult                                                  (Parm, OutParm, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::GetHitResultUnderCursor(TEnumAsByte<Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursor");

	APlayerController_GetHitResultUnderCursor_Params params {};
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F840
//		Name   -> Function Engine.PlayerController.GetFocalLocation
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector APlayerController::GetFocalLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetFocalLocation");

	APlayerController_GetFocalLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E150
//		Name   -> Function Engine.PlayerController.FOV
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		float                                              NewFOV                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::FOV(float NewFOV)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.FOV");

	APlayerController_FOV_Params params {};
	params.NewFOV = NewFOV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2E0A0
//		Name   -> Function Engine.PlayerController.EnableCheats
//		Flags  -> (Exec, Native, Public)
void APlayerController::EnableCheats()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.EnableCheats");

	APlayerController_EnableCheats_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2DC90
//		Name   -> Function Engine.PlayerController.DeprojectScreenPositionToWorld
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     WorldLocation                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     WorldDirection                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, struct FVector* WorldLocation, struct FVector* WorldDirection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.DeprojectScreenPositionToWorld");

	APlayerController_DeprojectScreenPositionToWorld_Params params {};
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (WorldLocation != nullptr)
		*WorldLocation = params.WorldLocation;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2DB90
//		Name   -> Function Engine.PlayerController.DeprojectMousePositionToWorld
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     WorldLocation                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     WorldDirection                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerController::DeprojectMousePositionToWorld(struct FVector* WorldLocation, struct FVector* WorldDirection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.DeprojectMousePositionToWorld");

	APlayerController_DeprojectMousePositionToWorld_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (WorldLocation != nullptr)
		*WorldLocation = params.WorldLocation;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2D950
//		Name   -> Function Engine.PlayerController.ConsoleKey
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FKey                                        Key                                                        (Parm)
void APlayerController::ConsoleKey(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ConsoleKey");

	APlayerController_ConsoleKey_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2D820
//		Name   -> Function Engine.PlayerController.ClientWasKicked
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FText                                       KickReason                                                 (ConstParm, Parm, ReferenceParm)
void APlayerController::ClientWasKicked(const struct FText& KickReason)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientWasKicked");

	APlayerController_ClientWasKicked_Params params {};
	params.KickReason = KickReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2D800
//		Name   -> Function Engine.PlayerController.ClientVoiceHandshakeComplete
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APlayerController::ClientVoiceHandshakeComplete()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientVoiceHandshakeComplete");

	APlayerController_ClientVoiceHandshakeComplete_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2D6D0
//		Name   -> Function Engine.PlayerController.ClientUpdateLevelStreamingStatusBatched
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FString                                     PackageBasePath                                            (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TArray<struct FLevelStreamingStatusUpdateInfo>     LevelStreamingStatusUpdateInfo                             (ConstParm, Parm, ZeroConstructor, ReferenceParm)
void APlayerController::ClientUpdateLevelStreamingStatusBatched(const struct FString& PackageBasePath, TArray<struct FLevelStreamingStatusUpdateInfo> LevelStreamingStatusUpdateInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUpdateLevelStreamingStatusBatched");

	APlayerController_ClientUpdateLevelStreamingStatusBatched_Params params {};
	params.PackageBasePath = PackageBasePath;
	params.LevelStreamingStatusUpdateInfo = LevelStreamingStatusUpdateInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2D520
//		Name   -> Function Engine.PlayerController.ClientUpdateLevelStreamingStatus
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FName                                       PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bNewShouldBeLoaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bNewShouldBeVisible                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bNewShouldBlockOnLoad                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                LODIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientUpdateLevelStreamingStatus(const struct FName& PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int LODIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUpdateLevelStreamingStatus");

	APlayerController_ClientUpdateLevelStreamingStatus_Params params {};
	params.PackageName = PackageName;
	params.bNewShouldBeLoaded = bNewShouldBeLoaded;
	params.bNewShouldBeVisible = bNewShouldBeVisible;
	params.bNewShouldBlockOnLoad = bNewShouldBlockOnLoad;
	params.LODIndex = LODIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2D430
//		Name   -> Function Engine.PlayerController.ClientUnmutePlayer
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FUniqueNetIdRepl                            PlayerId                                                   (Parm)
void APlayerController::ClientUnmutePlayer(const struct FUniqueNetIdRepl& PlayerId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUnmutePlayer");

	APlayerController_ClientUnmutePlayer_Params params {};
	params.PlayerId = PlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2D2B0
//		Name   -> Function Engine.PlayerController.ClientTravelInternal
//		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
//		struct FString                                     URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ETravelType>                    TravelType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSeamless                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FGuid                                       MapPackageGuid                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientTravelInternal(const struct FString& URL, TEnumAsByte<Engine_ETravelType> TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTravelInternal");

	APlayerController_ClientTravelInternal_Params params {};
	params.URL = URL;
	params.TravelType = TravelType;
	params.bSeamless = bSeamless;
	params.MapPackageGuid = MapPackageGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2D130
//		Name   -> Function Engine.PlayerController.ClientTravel
//		Flags  -> (Final, Native, Public, HasDefaults)
// Parameters:
//		struct FString                                     URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ETravelType>                    TravelType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSeamless                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FGuid                                       MapPackageGuid                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientTravel(const struct FString& URL, TEnumAsByte<Engine_ETravelType> TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTravel");

	APlayerController_ClientTravel_Params params {};
	params.URL = URL;
	params.TravelType = TravelType;
	params.bSeamless = bSeamless;
	params.MapPackageGuid = MapPackageGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2CFC0
//		Name   -> Function Engine.PlayerController.ClientTeamMessage
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class APlayerState*                                SenderPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     S                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FName                                       Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MsgLifeTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientTeamMessage(class APlayerState* SenderPlayerState, const struct FString& S, const struct FName& Type, float MsgLifeTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTeamMessage");

	APlayerController_ClientTeamMessage_Params params {};
	params.SenderPlayerState = SenderPlayerState;
	params.S = S;
	params.Type = Type;
	params.MsgLifeTime = MsgLifeTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2CEF0
//		Name   -> Function Engine.PlayerController.ClientStopForceFeedback
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
//		class UForceFeedbackEffect*                        ForceFeedbackEffect                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientStopForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, const struct FName& Tag)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopForceFeedback");

	APlayerController_ClientStopForceFeedback_Params params {};
	params.ForceFeedbackEffect = ForceFeedbackEffect;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2CE60
//		Name   -> Function Engine.PlayerController.ClientStopCameraShake
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
//		class UClass*                                      Shake                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void APlayerController::ClientStopCameraShake(class UClass* Shake)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopCameraShake");

	APlayerController_ClientStopCameraShake_Params params {};
	params.Shake = Shake;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2CDD0
//		Name   -> Function Engine.PlayerController.ClientStopCameraAnim
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class UCameraAnim*                                 AnimToStop                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientStopCameraAnim(class UCameraAnim* AnimToStop)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopCameraAnim");

	APlayerController_ClientStopCameraAnim_Params params {};
	params.AnimToStop = AnimToStop;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2CDB0
//		Name   -> Function Engine.PlayerController.ClientStartOnlineSession
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APlayerController::ClientStartOnlineSession()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStartOnlineSession");

	APlayerController_ClientStartOnlineSession_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2CD20
//		Name   -> Function Engine.PlayerController.ClientSpawnCameraLensEffect
//		Flags  -> (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
//		class UClass*                                      LensEffectEmitterClass                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void APlayerController::ClientSpawnCameraLensEffect(class UClass* LensEffectEmitterClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSpawnCameraLensEffect");

	APlayerController_ClientSpawnCameraLensEffect_Params params {};
	params.LensEffectEmitterClass = LensEffectEmitterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2CC00
//		Name   -> Function Engine.PlayerController.ClientSetViewTarget
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class AActor*                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FViewTargetTransitionParams                 TransitionParams                                           (Parm)
void APlayerController::ClientSetViewTarget(class AActor* A, const struct FViewTargetTransitionParams& TransitionParams)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetViewTarget");

	APlayerController_ClientSetViewTarget_Params params {};
	params.A = A;
	params.TransitionParams = TransitionParams;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2CB70
//		Name   -> Function Engine.PlayerController.ClientSetSpectatorWaiting
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		bool                                               bWaiting                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientSetSpectatorWaiting(bool bWaiting)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetSpectatorWaiting");

	APlayerController_ClientSetSpectatorWaiting_Params params {};
	params.bWaiting = bWaiting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C920
//		Name   -> Function Engine.PlayerController.ClientSetHUD
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
//		class UClass*                                      NewHUDClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void APlayerController::ClientSetHUD(class UClass* NewHUDClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetHUD");

	APlayerController_ClientSetHUD_Params params {};
	params.NewHUDClass = NewHUDClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C820
//		Name   -> Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ForceDuration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                CinematicTextureGroups                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material, float ForceDuration, int CinematicTextureGroups)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident");

	APlayerController_ClientSetForceMipLevelsToBeResident_Params params {};
	params.Material = Material;
	params.ForceDuration = ForceDuration;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C6B0
//		Name   -> Function Engine.PlayerController.ClientSetCinematicMode
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		bool                                               bInCinematicMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAffectsMovement                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAffectsTurning                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAffectsHUD                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCinematicMode");

	APlayerController_ClientSetCinematicMode_Params params {};
	params.bInCinematicMode = bInCinematicMode;
	params.bAffectsMovement = bAffectsMovement;
	params.bAffectsTurning = bAffectsTurning;
	params.bAffectsHUD = bAffectsHUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C620
//		Name   -> Function Engine.PlayerController.ClientSetCameraMode
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FName                                       NewCamMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientSetCameraMode(const struct FName& NewCamMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCameraMode");

	APlayerController_ClientSetCameraMode_Params params {};
	params.NewCamMode = NewCamMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C490
//		Name   -> Function Engine.PlayerController.ClientSetCameraFade
//		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
//		bool                                               bEnableFading                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FColor                                      FadeColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   FadeAlpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bFadeAudio                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientSetCameraFade(bool bEnableFading, const struct FColor& FadeColor, const struct FVector2D& FadeAlpha, float FadeTime, bool bFadeAudio)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCameraFade");

	APlayerController_ClientSetCameraFade_Params params {};
	params.bEnableFading = bEnableFading;
	params.FadeColor = FadeColor;
	params.FadeAlpha = FadeAlpha;
	params.FadeTime = FadeTime;
	params.bFadeAudio = bFadeAudio;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C470
//		Name   -> Function Engine.PlayerController.ClientSetBlockOnAsyncLoading
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APlayerController::ClientSetBlockOnAsyncLoading()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetBlockOnAsyncLoading");

	APlayerController_ClientSetBlockOnAsyncLoading_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C450
//		Name   -> Function Engine.PlayerController.ClientSeamlessTravelComplete
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APlayerController::ClientSeamlessTravelComplete()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSeamlessTravelComplete");

	APlayerController_ClientSeamlessTravelComplete_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C3A0
//		Name   -> Function Engine.PlayerController.ClientReturnToMainMenu
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FString                                     ReturnReason                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
void APlayerController::ClientReturnToMainMenu(const struct FString& ReturnReason)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReturnToMainMenu");

	APlayerController_ClientReturnToMainMenu_Params params {};
	params.ReturnReason = ReturnReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C310
//		Name   -> Function Engine.PlayerController.ClientRetryClientRestart
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class APawn*                                       NewPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientRetryClientRestart(class APawn* NewPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRetryClientRestart");

	APlayerController_ClientRetryClientRestart_Params params {};
	params.NewPawn = NewPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C280
//		Name   -> Function Engine.PlayerController.ClientRestart
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class APawn*                                       NewPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientRestart(class APawn* NewPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRestart");

	APlayerController_ClientRestart_Params params {};
	params.NewPawn = NewPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C260
//		Name   -> Function Engine.PlayerController.ClientReset
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APlayerController::ClientReset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReset");

	APlayerController_ClientReset_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C1D0
//		Name   -> Function Engine.PlayerController.ClientRepObjRef
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientRepObjRef(class UObject* Object)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRepObjRef");

	APlayerController_ClientRepObjRef_Params params {};
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2C050
//		Name   -> Function Engine.PlayerController.ClientReceiveLocalizedMessage
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class UClass*                                      Message                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		int                                                Switch                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class APlayerState*                                RelatedPlayerState_2                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class APlayerState*                                RelatedPlayerState_3                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UObject*                                     OptionalObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientReceiveLocalizedMessage(class UClass* Message, int Switch, class APlayerState* RelatedPlayerState_2, class APlayerState* RelatedPlayerState_3, class UObject* OptionalObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReceiveLocalizedMessage");

	APlayerController_ClientReceiveLocalizedMessage_Params params {};
	params.Message = Message;
	params.Switch = Switch;
	params.RelatedPlayerState_2 = RelatedPlayerState_2;
	params.RelatedPlayerState_3 = RelatedPlayerState_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2BF00
//		Name   -> Function Engine.PlayerController.ClientPrestreamTextures
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class AActor*                                      ForcedActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ForceDuration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bEnableStreaming                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                CinematicTextureGroups                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientPrestreamTextures(class AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, int CinematicTextureGroups)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPrestreamTextures");

	APlayerController_ClientPrestreamTextures_Params params {};
	params.ForcedActor = ForcedActor;
	params.ForceDuration = ForceDuration;
	params.bEnableStreaming = bEnableStreaming;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2BDF0
//		Name   -> Function Engine.PlayerController.ClientPrepareMapChange
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FName                                       LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bFirst                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bLast                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientPrepareMapChange(const struct FName& LevelName, bool bFirst, bool bLast)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPrepareMapChange");

	APlayerController_ClientPrepareMapChange_Params params {};
	params.LevelName = LevelName;
	params.bFirst = bFirst;
	params.bLast = bLast;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2BCA0
//		Name   -> Function Engine.PlayerController.ClientPlaySoundAtLocation
//		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
//		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientPlaySoundAtLocation(class USoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlaySoundAtLocation");

	APlayerController_ClientPlaySoundAtLocation_Params params {};
	params.Sound = Sound;
	params.Location = Location;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2BBA0
//		Name   -> Function Engine.PlayerController.ClientPlaySound
//		Flags  -> (Net, Native, Event, Public, NetClient)
// Parameters:
//		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientPlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlaySound");

	APlayerController_ClientPlaySound_Params params {};
	params.Sound = Sound;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2BA90
//		Name   -> Function Engine.PlayerController.ClientPlayForceFeedback
//		Flags  -> (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
//		class UForceFeedbackEffect*                        ForceFeedbackEffect                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientPlayForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, bool bLooping, const struct FName& Tag)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayForceFeedback");

	APlayerController_ClientPlayForceFeedback_Params params {};
	params.ForceFeedbackEffect = ForceFeedbackEffect;
	params.bLooping = bLooping;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B930
//		Name   -> Function Engine.PlayerController.ClientPlayCameraShake
//		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
//		class UClass*                                      Shake                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECameraAnimPlaySpace>           PlaySpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    UserPlaySpaceRot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientPlayCameraShake(class UClass* Shake, float Scale, TEnumAsByte<Engine_ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayCameraShake");

	APlayerController_ClientPlayCameraShake_Params params {};
	params.Shake = Shake;
	params.Scale = Scale;
	params.PlaySpace = PlaySpace;
	params.UserPlaySpaceRot = UserPlaySpaceRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B690
//		Name   -> Function Engine.PlayerController.ClientPlayCameraAnim
//		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
//		class UCameraAnim*                                 AnimToPlay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendInTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendOutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bRandomStartTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ECameraAnimPlaySpace>           Space                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    CustomPlaySpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientPlayCameraAnim(class UCameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, TEnumAsByte<Engine_ECameraAnimPlaySpace> Space, const struct FRotator& CustomPlaySpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayCameraAnim");

	APlayerController_ClientPlayCameraAnim_Params params {};
	params.AnimToPlay = AnimToPlay;
	params.Scale = Scale;
	params.Rate = Rate;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bLoop = bLoop;
	params.bRandomStartTime = bRandomStartTime;
	params.Space = Space;
	params.CustomPlaySpace = CustomPlaySpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B5A0
//		Name   -> Function Engine.PlayerController.ClientMutePlayer
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FUniqueNetIdRepl                            PlayerId                                                   (Parm)
void APlayerController::ClientMutePlayer(const struct FUniqueNetIdRepl& PlayerId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientMutePlayer");

	APlayerController_ClientMutePlayer_Params params {};
	params.PlayerId = PlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B470
//		Name   -> Function Engine.PlayerController.ClientMessage
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FString                                     S                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FName                                       Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MsgLifeTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientMessage(const struct FString& S, const struct FName& Type, float MsgLifeTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientMessage");

	APlayerController_ClientMessage_Params params {};
	params.S = S;
	params.Type = Type;
	params.MsgLifeTime = MsgLifeTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B3E0
//		Name   -> Function Engine.PlayerController.ClientIgnoreMoveInput
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		bool                                               bIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientIgnoreMoveInput(bool bIgnore)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientIgnoreMoveInput");

	APlayerController_ClientIgnoreMoveInput_Params params {};
	params.bIgnore = bIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B350
//		Name   -> Function Engine.PlayerController.ClientIgnoreLookInput
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		bool                                               bIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientIgnoreLookInput(bool bIgnore)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientIgnoreLookInput");

	APlayerController_ClientIgnoreLookInput_Params params {};
	params.bIgnore = bIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B2C0
//		Name   -> Function Engine.PlayerController.ClientGotoState
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FName                                       NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientGotoState(const struct FName& NewState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientGotoState");

	APlayerController_ClientGotoState_Params params {};
	params.NewState = NewState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B1F0
//		Name   -> Function Engine.PlayerController.ClientGameEnded
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class AActor*                                      EndGameFocus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bIsWinner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientGameEnded");

	APlayerController_ClientGameEnded_Params params {};
	params.EndGameFocus = EndGameFocus;
	params.bIsWinner = bIsWinner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B1D0
//		Name   -> Function Engine.PlayerController.ClientForceGarbageCollection
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APlayerController::ClientForceGarbageCollection()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientForceGarbageCollection");

	APlayerController_ClientForceGarbageCollection_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B1B0
//		Name   -> Function Engine.PlayerController.ClientFlushLevelStreaming
//		Flags  -> (Final, Net, NetReliable, Native, Event, Public, NetClient)
void APlayerController::ClientFlushLevelStreaming()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientFlushLevelStreaming");

	APlayerController_ClientFlushLevelStreaming_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B190
//		Name   -> Function Engine.PlayerController.ClientEndOnlineSession
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APlayerController::ClientEndOnlineSession()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientEndOnlineSession");

	APlayerController_ClientEndOnlineSession_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B100
//		Name   -> Function Engine.PlayerController.ClientEnableNetworkVoice
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientEnableNetworkVoice(bool bEnable)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientEnableNetworkVoice");

	APlayerController_ClientEnableNetworkVoice_Params params {};
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B0E0
//		Name   -> Function Engine.PlayerController.ClientCommitMapChange
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APlayerController::ClientCommitMapChange()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCommitMapChange");

	APlayerController_ClientCommitMapChange_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B0C0
//		Name   -> Function Engine.PlayerController.ClientClearCameraLensEffects
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
void APlayerController::ClientClearCameraLensEffects()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientClearCameraLensEffects");

	APlayerController_ClientClearCameraLensEffects_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B030
//		Name   -> Function Engine.PlayerController.ClientCapBandwidth
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		int                                                Cap                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ClientCapBandwidth(int Cap)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCapBandwidth");

	APlayerController_ClientCapBandwidth_Params params {};
	params.Cap = Cap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2B010
//		Name   -> Function Engine.PlayerController.ClientCancelPendingMapChange
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APlayerController::ClientCancelPendingMapChange()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCancelPendingMapChange");

	APlayerController_ClientCancelPendingMapChange_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2AF80
//		Name   -> Function Engine.PlayerController.ClientBlendOutCameraShake
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
//		class UClass*                                      Shake                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void APlayerController::ClientBlendOutCameraShake(class UClass* Shake)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientBlendOutCameraShake");

	APlayerController_ClientBlendOutCameraShake_Params params {};
	params.Shake = Shake;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2AE60
//		Name   -> Function Engine.PlayerController.ClientAddTextureStreamingLoc
//		Flags  -> (Final, Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
//		struct FVector                                     InLoc                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bOverrideLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerController::ClientAddTextureStreamingLoc(const struct FVector& InLoc, float Duration, bool bOverrideLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientAddTextureStreamingLoc");

	APlayerController_ClientAddTextureStreamingLoc_Params params {};
	params.InLoc = InLoc;
	params.Duration = Duration;
	params.bOverrideLocation = bOverrideLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2AE20
//		Name   -> Function Engine.PlayerController.ClearAudioListenerOverride
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APlayerController::ClearAudioListenerOverride()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClearAudioListenerOverride");

	APlayerController_ClearAudioListenerOverride_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2AD60
//		Name   -> Function Engine.PlayerController.Camera
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FName                                       NewMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::Camera(const struct FName& NewMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.Camera");

	APlayerController_Camera_Params params {};
	params.NewMode = NewMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2A930
//		Name   -> Function Engine.PlayerController.AddYawInput
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::AddYawInput(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddYawInput");

	APlayerController_AddYawInput_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2A670
//		Name   -> Function Engine.PlayerController.AddRollInput
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::AddRollInput(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddRollInput");

	APlayerController_AddRollInput_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2A5F0
//		Name   -> Function Engine.PlayerController.AddPitchInput
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::AddPitchInput(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddPitchInput");

	APlayerController_AddPitchInput_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2A030
//		Name   -> Function Engine.PlayerController.ActivateTouchInterface
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UTouchInterface*                             NewTouchInterface                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerController::ActivateTouchInterface(class UTouchInterface* NewTouchInterface)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ActivateTouchInterface");

	APlayerController_ActivateTouchInterface_Params params {};
	params.NewTouchInterface = NewTouchInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void APlayerController::AfterRead()
{
	AController::AfterRead();

	READ_PTR_FULL(Player, UPlayer);
	READ_PTR_FULL(AcknowledgedPawn, APawn);
	READ_PTR_FULL(ControllingDirTrackInst, UInterpTrackInstDirector);
	READ_PTR_FULL(MyHUD, AHUD);
	READ_PTR_FULL(PlayerCameraManager, APlayerCameraManager);
	READ_PTR_FULL(PlayerCameraManagerClass, UClass);
	READ_PTR_FULL(CheatManager, UCheatManager);
	READ_PTR_FULL(CheatClass, UClass);
	READ_PTR_FULL(PlayerInput, UPlayerInput);
	READ_PTR_FULL(PendingSwapConnection, UNetConnection);
	READ_PTR_FULL(NetConnection, UNetConnection);
	READ_PTR_FULL(InactiveStateInputComponent, UInputComponent);
	READ_PTR_FULL(CurrentTouchInterface, UTouchInterface);
	READ_PTR_FULL(SpectatorPawn, ASpectatorPawn);
}

void APlayerController::BeforeDelete()
{
	AController::BeforeDelete();

	DELE_PTR_FULL(Player);
	DELE_PTR_FULL(AcknowledgedPawn);
	DELE_PTR_FULL(ControllingDirTrackInst);
	DELE_PTR_FULL(MyHUD);
	DELE_PTR_FULL(PlayerCameraManager);
	DELE_PTR_FULL(PlayerCameraManagerClass);
	DELE_PTR_FULL(CheatManager);
	DELE_PTR_FULL(CheatClass);
	DELE_PTR_FULL(PlayerInput);
	DELE_PTR_FULL(PendingSwapConnection);
	DELE_PTR_FULL(NetConnection);
	DELE_PTR_FULL(InactiveStateInputComponent);
	DELE_PTR_FULL(CurrentTouchInterface);
	DELE_PTR_FULL(SpectatorPawn);
}

void AStaticMeshActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(StaticMeshComponent, UStaticMeshComponent);
}

void AStaticMeshActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(StaticMeshComponent);
}

void ABrush::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(Brush, UModel);
	READ_PTR_FULL(BrushComponent, UBrushComponent);
}

void ABrush::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(Brush);
	DELE_PTR_FULL(BrushComponent);
}

void AVolume::AfterRead()
{
	ABrush::AfterRead();

}

void AVolume::BeforeDelete()
{
	ABrush::BeforeDelete();

}

void ABlockingVolume::AfterRead()
{
	AVolume::AfterRead();

}

void ABlockingVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

// Function:
//		Offset -> 0x02B38480
//		Name   -> Function Engine.WorldSettings.OnRep_WorldGravityZ
//		Flags  -> (Native, Public)
void AWorldSettings::OnRep_WorldGravityZ()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.WorldSettings.OnRep_WorldGravityZ");

	AWorldSettings_OnRep_WorldGravityZ_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void AWorldSettings::AfterRead()
{
	AInfo::AfterRead();

	READ_PTR_FULL(KillZDamageType, UClass);
	READ_PTR_FULL(DefaultPhysicsVolumeClass, UClass);
	READ_PTR_FULL(PhysicsCollisionHandlerClass, UClass);
	READ_PTR_FULL(DefaultGameMode, UClass);
	READ_PTR_FULL(GameNetworkManagerClass, UClass);
	READ_PTR_FULL(DefaultBaseSoundMix, USoundMix);
	READ_PTR_FULL(BookMarks[0xA], UBookMark);
	READ_PTR_FULL(Pauser, APlayerState);
}

void AWorldSettings::BeforeDelete()
{
	AInfo::BeforeDelete();

	DELE_PTR_FULL(KillZDamageType);
	DELE_PTR_FULL(DefaultPhysicsVolumeClass);
	DELE_PTR_FULL(PhysicsCollisionHandlerClass);
	DELE_PTR_FULL(DefaultGameMode);
	DELE_PTR_FULL(GameNetworkManagerClass);
	DELE_PTR_FULL(DefaultBaseSoundMix);
	DELE_PTR_FULL(BookMarks[0xA]);
	DELE_PTR_FULL(Pauser);
}

// Function:
//		Offset -> 0x02C380F0
//		Name   -> Function Engine.PostProcessComponent.AddOrUpdateBlendable
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InWeight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPostProcessComponent::AddOrUpdateBlendable(float InWeight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PostProcessComponent.AddOrUpdateBlendable");

	UPostProcessComponent_AddOrUpdateBlendable_Params params {};
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UPostProcessComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UPostProcessComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

void UTexture::AfterRead()
{
	UObject::AfterRead();

}

void UTexture::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UTextureRenderTarget::AfterRead()
{
	UTexture::AfterRead();

}

void UTextureRenderTarget::BeforeDelete()
{
	UTexture::BeforeDelete();

}

void UTextureRenderTarget2D::AfterRead()
{
	UTextureRenderTarget::AfterRead();

}

void UTextureRenderTarget2D::BeforeDelete()
{
	UTextureRenderTarget::BeforeDelete();

}

// Function:
//		Offset -> 0x02B40AF0
//		Name   -> Function Engine.DebugCameraController.ToggleDisplay
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ADebugCameraController::ToggleDisplay()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ToggleDisplay");

	ADebugCameraController_ToggleDisplay_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40520
//		Name   -> Function Engine.DebugCameraController.ShowDebugSelectedInfo
//		Flags  -> (Exec, Native, Public)
void ADebugCameraController::ShowDebugSelectedInfo()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ShowDebugSelectedInfo");

	ADebugCameraController_ShowDebugSelectedInfo_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B36A60
//		Name   -> Function Engine.DebugCameraController.IncreaseFOV
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ADebugCameraController::IncreaseFOV()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.IncreaseFOV");

	ADebugCameraController_IncreaseFOV_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B36A40
//		Name   -> Function Engine.DebugCameraController.IncreaseCameraSpeed
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ADebugCameraController::IncreaseCameraSpeed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.IncreaseCameraSpeed");

	ADebugCameraController_IncreaseCameraSpeed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2F720
//		Name   -> Function Engine.DebugCameraController.DecreaseFOV
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ADebugCameraController::DecreaseFOV()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.DecreaseFOV");

	ADebugCameraController_DecreaseFOV_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2F700
//		Name   -> Function Engine.DebugCameraController.DecreaseCameraSpeed
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ADebugCameraController::DecreaseCameraSpeed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.DecreaseCameraSpeed");

	ADebugCameraController_DecreaseCameraSpeed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ADebugCameraController::AfterRead()
{
	APlayerController::AfterRead();

	READ_PTR_FULL(DrawFrustum, UDrawFrustumComponent);
	READ_PTR_FULL(OriginalControllerRef, APlayerController);
	READ_PTR_FULL(OriginalPlayer, UPlayer);
}

void ADebugCameraController::BeforeDelete()
{
	APlayerController::BeforeDelete();

	DELE_PTR_FULL(DrawFrustum);
	DELE_PTR_FULL(OriginalControllerRef);
	DELE_PTR_FULL(OriginalPlayer);
}

// Function:
//		Offset -> 0x02B405C0
//		Name   -> Function Engine.HUD.ShowHUD
//		Flags  -> (Exec, Native, Public)
void AHUD::ShowHUD()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowHUD");

	AHUD_ShowHUD_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40540
//		Name   -> Function Engine.HUD.ShowDebugToggleSubCategory
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FName                                       Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AHUD::ShowDebugToggleSubCategory(const struct FName& Category)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebugToggleSubCategory");

	AHUD_ShowDebugToggleSubCategory_Params params {};
	params.Category = Category;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B404A0
//		Name   -> Function Engine.HUD.ShowDebugForReticleTargetToggle
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		class UClass*                                      DesiredClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void AHUD::ShowDebugForReticleTargetToggle(class UClass* DesiredClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebugForReticleTargetToggle");

	AHUD_ShowDebugForReticleTargetToggle_Params params {};
	params.DesiredClass = DesiredClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40410
//		Name   -> Function Engine.HUD.ShowDebug
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FName                                       DebugType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AHUD::ShowDebug(const struct FName& DebugType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebug");

	AHUD_ShowDebug_Params params {};
	params.DebugType = DebugType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39360
//		Name   -> Function Engine.HUD.RemoveDebugText
//		Flags  -> (Final, Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class AActor*                                      SrcActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bLeaveDurationText                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AHUD::RemoveDebugText(class AActor* SrcActor, bool bLeaveDurationText)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.RemoveDebugText");

	AHUD_RemoveDebugText_Params params {};
	params.SrcActor = SrcActor;
	params.bLeaveDurationText = bLeaveDurationText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39340
//		Name   -> Function Engine.HUD.RemoveAllDebugStrings
//		Flags  -> (Final, Net, NetReliable, Native, Event, Public, NetClient)
void AHUD::RemoveAllDebugStrings()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.RemoveAllDebugStrings");

	AHUD_RemoveAllDebugStrings_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.HUD.ReceiveHitBoxRelease
//		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
//		struct FName                                       BoxName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AHUD::ReceiveHitBoxRelease(const struct FName& BoxName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxRelease");

	AHUD_ReceiveHitBoxRelease_Params params {};
	params.BoxName = BoxName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.HUD.ReceiveHitBoxEndCursorOver
//		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
//		struct FName                                       BoxName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AHUD::ReceiveHitBoxEndCursorOver(const struct FName& BoxName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxEndCursorOver");

	AHUD_ReceiveHitBoxEndCursorOver_Params params {};
	params.BoxName = BoxName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.HUD.ReceiveHitBoxClick
//		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
//		struct FName                                       BoxName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AHUD::ReceiveHitBoxClick(const struct FName& BoxName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxClick");

	AHUD_ReceiveHitBoxClick_Params params {};
	params.BoxName = BoxName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.HUD.ReceiveHitBoxBeginCursorOver
//		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
//		struct FName                                       BoxName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AHUD::ReceiveHitBoxBeginCursorOver(const struct FName& BoxName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxBeginCursorOver");

	AHUD_ReceiveHitBoxBeginCursorOver_Params params {};
	params.BoxName = BoxName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.HUD.ReceiveDrawHUD
//		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
//		int                                                SizeX                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                SizeY                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AHUD::ReceiveDrawHUD(int SizeX, int SizeY)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveDrawHUD");

	AHUD_ReceiveDrawHUD_Params params {};
	params.SizeX = SizeX;
	params.SizeY = SizeY;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38D00
//		Name   -> Function Engine.HUD.Project
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector AHUD::Project(const struct FVector& Location)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.Project");

	AHUD_Project_Params params {};
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B358B0
//		Name   -> Function Engine.HUD.GetTextSize
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash)
//		float                                              OutWidth                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OutHeight                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UFont*                                       Font                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AHUD::GetTextSize(const struct FString& Text, float* OutWidth, float* OutHeight, class UFont* Font, float Scale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetTextSize");

	AHUD_GetTextSize_Params params {};
	params.Text = Text;
	params.Font = Font;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutWidth != nullptr)
		*OutWidth = params.OutWidth;
	if (OutHeight != nullptr)
		*OutHeight = params.OutHeight;

}


// Function:
//		Offset -> 0x02B33770
//		Name   -> Function Engine.HUD.GetOwningPlayerController
//		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APlayerController*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APlayerController* AHUD::GetOwningPlayerController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetOwningPlayerController");

	AHUD_GetOwningPlayerController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33740
//		Name   -> Function Engine.HUD.GetOwningPawn
//		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APawn*                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APawn* AHUD::GetOwningPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetOwningPawn");

	AHUD_GetOwningPawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31540
//		Name   -> Function Engine.HUD.GetActorsInSelectionRectangle
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      ClassFilter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		struct FVector2D                                   FirstPoint                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   SecondPoint                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
//		bool                                               bIncludeNonCollidingComponents                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bActorMustBeFullyEnclosed                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AHUD::GetActorsInSelectionRectangle(class UClass* ClassFilter, const struct FVector2D& FirstPoint, const struct FVector2D& SecondPoint, TArray<class AActor*>* OutActors, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetActorsInSelectionRectangle");

	AHUD_GetActorsInSelectionRectangle_Params params {};
	params.ClassFilter = ClassFilter;
	params.FirstPoint = FirstPoint;
	params.SecondPoint = SecondPoint;
	params.bIncludeNonCollidingComponents = bIncludeNonCollidingComponents;
	params.bActorMustBeFullyEnclosed = bActorMustBeFullyEnclosed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;

}


// Function:
//		Offset -> 0x02B30B30
//		Name   -> Function Engine.HUD.DrawTextureSimple
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UTexture*                                    Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bScalePosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AHUD::DrawTextureSimple(class UTexture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawTextureSimple");

	AHUD_DrawTextureSimple_Params params {};
	params.Texture = Texture;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.Scale = Scale;
	params.bScalePosition = bScalePosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B30710
//		Name   -> Function Engine.HUD.DrawTexture
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UTexture*                                    Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenW                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenH                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TextureU                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TextureV                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TextureUWidth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TextureVHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                TintColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		TEnumAsByte<Engine_EBlendMode>                     BlendMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		bool                                               bScalePosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		float                                              Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FVector2D                                   RotPivot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void AHUD::DrawTexture(class UTexture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, const struct FLinearColor& TintColor, TEnumAsByte<Engine_EBlendMode> BlendMode, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawTexture");

	AHUD_DrawTexture_Params params {};
	params.Texture = Texture;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.ScreenW = ScreenW;
	params.ScreenH = ScreenH;
	params.TextureU = TextureU;
	params.TextureV = TextureV;
	params.TextureUWidth = TextureUWidth;
	params.TextureVHeight = TextureVHeight;
	params.TintColor = TintColor;
	params.BlendMode = BlendMode;
	params.Scale = Scale;
	params.bScalePosition = bScalePosition;
	params.Rotation = Rotation;
	params.RotPivot = RotPivot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B304D0
//		Name   -> Function Engine.HUD.DrawText
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FString                                     Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FLinearColor                                TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UFont*                                       Font                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bScalePosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AHUD::DrawText(const struct FString& Text, const struct FLinearColor& TextColor, float ScreenX, float ScreenY, class UFont* Font, float Scale, bool bScalePosition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawText");

	AHUD_DrawText_Params params {};
	params.Text = Text;
	params.TextColor = TextColor;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.Font = Font;
	params.Scale = Scale;
	params.bScalePosition = bScalePosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B30320
//		Name   -> Function Engine.HUD.DrawRect
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                RectColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenW                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenH                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AHUD::DrawRect(const struct FLinearColor& RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawRect");

	AHUD_DrawRect_Params params {};
	params.RectColor = RectColor;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.ScreenW = ScreenW;
	params.ScreenH = ScreenH;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B30060
//		Name   -> Function Engine.HUD.DrawMaterialTriangle
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   V0_Pos                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   V1_Pos                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   V2_Pos                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   V0_UV                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   V1_UV                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   V2_UV                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                V0_Color                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                V1_Color                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                V2_Color                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AHUD::DrawMaterialTriangle(class UMaterialInterface* Material, const struct FVector2D& V0_Pos, const struct FVector2D& V1_Pos, const struct FVector2D& V2_Pos, const struct FVector2D& V0_UV, const struct FVector2D& V1_UV, const struct FVector2D& V2_UV, const struct FLinearColor& V0_Color, const struct FLinearColor& V1_Color, const struct FLinearColor& V2_Color)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterialTriangle");

	AHUD_DrawMaterialTriangle_Params params {};
	params.Material = Material;
	params.V0_Pos = V0_Pos;
	params.V1_Pos = V1_Pos;
	params.V2_Pos = V2_Pos;
	params.V0_UV = V0_UV;
	params.V1_UV = V1_UV;
	params.V2_UV = V2_UV;
	params.V0_Color = V0_Color;
	params.V1_Color = V1_Color;
	params.V2_Color = V2_Color;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2FE60
//		Name   -> Function Engine.HUD.DrawMaterialSimple
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenW                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenH                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bScalePosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AHUD::DrawMaterialSimple(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterialSimple");

	AHUD_DrawMaterialSimple_Params params {};
	params.Material = Material;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.ScreenW = ScreenW;
	params.ScreenH = ScreenH;
	params.Scale = Scale;
	params.bScalePosition = bScalePosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2FAD0
//		Name   -> Function Engine.HUD.DrawMaterial
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenW                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenH                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MaterialU                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MaterialV                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MaterialUWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MaterialVHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		bool                                               bScalePosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		float                                              Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FVector2D                                   RotPivot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void AHUD::DrawMaterial(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterial");

	AHUD_DrawMaterial_Params params {};
	params.Material = Material;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.ScreenW = ScreenW;
	params.ScreenH = ScreenH;
	params.MaterialU = MaterialU;
	params.MaterialV = MaterialV;
	params.MaterialUWidth = MaterialUWidth;
	params.MaterialVHeight = MaterialVHeight;
	params.Scale = Scale;
	params.bScalePosition = bScalePosition;
	params.Rotation = Rotation;
	params.RotPivot = RotPivot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2F920
//		Name   -> Function Engine.HUD.DrawLine
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		float                                              StartScreenX                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              StartScreenY                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              EndScreenX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              EndScreenY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AHUD::DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, const struct FLinearColor& LineColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawLine");

	AHUD_DrawLine_Params params {};
	params.StartScreenX = StartScreenX;
	params.StartScreenY = StartScreenY;
	params.EndScreenX = EndScreenX;
	params.EndScreenY = EndScreenY;
	params.LineColor = LineColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2F740
//		Name   -> Function Engine.HUD.Deproject
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     WorldPosition                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     WorldDirection                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AHUD::Deproject(float ScreenX, float ScreenY, struct FVector* WorldPosition, struct FVector* WorldDirection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.Deproject");

	AHUD_Deproject_Params params {};
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (WorldPosition != nullptr)
		*WorldPosition = params.WorldPosition;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;

}


// Function:
//		Offset -> 0x02B2DB00
//		Name   -> Function Engine.HUD.AddHitBox
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   Position                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bConsumesInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AHUD::AddHitBox(const struct FVector2D& Position, const struct FVector2D& Size, const struct FName& InName, bool bConsumesInput, int Priority)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.AddHitBox");

	AHUD_AddHitBox_Params params {};
	params.Position = Position;
	params.Size = Size;
	params.InName = InName;
	params.bConsumesInput = bConsumesInput;
	params.Priority = Priority;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2D350
//		Name   -> Function Engine.HUD.AddDebugText
//		Flags  -> (Final, Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
//		struct FString                                     DebugText                                                  (Parm, ZeroConstructor, HasGetValueTypeHash)
//		class AActor*                                      SrcActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     DesiredOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FColor                                      TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSkipOverwriteCheck                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAbsoluteLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bKeepAttachedToActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UFont*                                       InFont                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              FontScale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bDrawShadow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AHUD::AddDebugText(const struct FString& DebugText, class AActor* SrcActor, float Duration, const struct FVector& Offset, const struct FVector& DesiredOffset, const struct FColor& TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, class UFont* InFont, float FontScale, bool bDrawShadow)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HUD.AddDebugText");

	AHUD_AddDebugText_Params params {};
	params.DebugText = DebugText;
	params.SrcActor = SrcActor;
	params.Duration = Duration;
	params.Offset = Offset;
	params.DesiredOffset = DesiredOffset;
	params.TextColor = TextColor;
	params.bSkipOverwriteCheck = bSkipOverwriteCheck;
	params.bAbsoluteLocation = bAbsoluteLocation;
	params.bKeepAttachedToActor = bKeepAttachedToActor;
	params.InFont = InFont;
	params.FontScale = FontScale;
	params.bDrawShadow = bDrawShadow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void AHUD::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(PlayerOwner, APlayerController);
	READ_PTR_FULL(Canvas, UCanvas);
	READ_PTR_FULL(DebugCanvas, UCanvas);
	READ_PTR_FULL(ShowDebugTargetDesiredClass, UClass);
	READ_PTR_FULL(ShowDebugTargetActor, AActor);
}

void AHUD::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(PlayerOwner);
	DELE_PTR_FULL(Canvas);
	DELE_PTR_FULL(DebugCanvas);
	DELE_PTR_FULL(ShowDebugTargetDesiredClass);
	DELE_PTR_FULL(ShowDebugTargetActor);
}

void UFeatureToggledStringAssetReference::AfterRead()
{
	UDataAsset::AfterRead();

	READ_PTR_FULL(ClassType, UClass);
}

void UFeatureToggledStringAssetReference::BeforeDelete()
{
	UDataAsset::BeforeDelete();

	DELE_PTR_FULL(ClassType);
}

// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.LevelScriptActor.WorldOriginLocationChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		struct FIntVector                                  OldOriginLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FIntVector                                  NewOriginLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ALevelScriptActor::WorldOriginLocationChanged(const struct FIntVector& OldOriginLocation, const struct FIntVector& NewOriginLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.WorldOriginLocationChanged");

	ALevelScriptActor_WorldOriginLocationChanged_Params params {};
	params.OldOriginLocation = OldOriginLocation;
	params.NewOriginLocation = NewOriginLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B6D0
//		Name   -> Function Engine.LevelScriptActor.SetCinematicMode
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bCinematicMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bHidePlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAffectsHUD                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAffectsMovement                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAffectsTurning                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ALevelScriptActor::SetCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.SetCinematicMode");

	ALevelScriptActor_SetCinematicMode_Params params {};
	params.bCinematicMode = bCinematicMode;
	params.bHidePlayer = bHidePlayer;
	params.bAffectsHUD = bAffectsHUD;
	params.bAffectsMovement = bAffectsMovement;
	params.bAffectsTurning = bAffectsTurning;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B392A0
//		Name   -> Function Engine.LevelScriptActor.RemoteEvent
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ALevelScriptActor::RemoteEvent(const struct FName& EventName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.RemoteEvent");

	ALevelScriptActor_RemoteEvent_Params params {};
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.LevelScriptActor.MatchStarted
//		Flags  -> (Event, Public, BlueprintEvent)
void ALevelScriptActor::MatchStarted()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.MatchStarted");

	ALevelScriptActor_MatchStarted_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.LevelScriptActor.LevelReset
//		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
void ALevelScriptActor::LevelReset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.LevelReset");

	ALevelScriptActor_LevelReset_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.LevelScriptActor.InitialNetRelevantActorsCreated
//		Flags  -> (Event, Public, BlueprintEvent)
void ALevelScriptActor::InitialNetRelevantActorsCreated()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.InitialNetRelevantActorsCreated");

	ALevelScriptActor_InitialNetRelevantActorsCreated_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ALevelScriptActor::AfterRead()
{
	AActor::AfterRead();

}

void ALevelScriptActor::BeforeDelete()
{
	AActor::BeforeDelete();

}

// Function:
//		Offset -> 0x02B39470
//		Name   -> Function Engine.MeshComponent.ResetDefaultMaterials
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UMeshComponent::ResetDefaultMaterials()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.ResetDefaultMaterials");

	UMeshComponent_ResetDefaultMaterials_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B32E80
//		Name   -> Function Engine.MeshComponent.GetMaterials
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<class UMaterialInterface*>                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<class UMaterialInterface*> UMeshComponent::GetMaterials()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetMaterials");

	UMeshComponent_GetMaterials_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UMeshComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

}

void UMeshComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4AA10
//		Name   -> Function Engine.PhysicsHandleComponent.SetTargetRotation
//		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsHandleComponent::SetTargetRotation(const struct FRotator& NewRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetRotation");

	UPhysicsHandleComponent_SetTargetRotation_Params params {};
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4A930
//		Name   -> Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation
//		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsHandleComponent::SetTargetLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation");

	UPhysicsHandleComponent_SetTargetLocationAndRotation_Params params {};
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4A8A0
//		Name   -> Function Engine.PhysicsHandleComponent.SetTargetLocation
//		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsHandleComponent::SetTargetLocation(const struct FVector& NewLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetLocation");

	UPhysicsHandleComponent_SetTargetLocation_Params params {};
	params.NewLocation = NewLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48810
//		Name   -> Function Engine.PhysicsHandleComponent.SetLinearStiffness
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewLinearStiffness                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsHandleComponent::SetLinearStiffness(float NewLinearStiffness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetLinearStiffness");

	UPhysicsHandleComponent_SetLinearStiffness_Params params {};
	params.NewLinearStiffness = NewLinearStiffness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48790
//		Name   -> Function Engine.PhysicsHandleComponent.SetLinearDamping
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewLinearDamping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsHandleComponent::SetLinearDamping(float NewLinearDamping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetLinearDamping");

	UPhysicsHandleComponent_SetLinearDamping_Params params {};
	params.NewLinearDamping = NewLinearDamping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48400
//		Name   -> Function Engine.PhysicsHandleComponent.SetInterpolationSpeed
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewInterpolationSpeed                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsHandleComponent::SetInterpolationSpeed(float NewInterpolationSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetInterpolationSpeed");

	UPhysicsHandleComponent_SetInterpolationSpeed_Params params {};
	params.NewInterpolationSpeed = NewInterpolationSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44B60
//		Name   -> Function Engine.PhysicsHandleComponent.SetAngularStiffness
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewAngularStiffness                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsHandleComponent::SetAngularStiffness(float NewAngularStiffness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetAngularStiffness");

	UPhysicsHandleComponent_SetAngularStiffness_Params params {};
	params.NewAngularStiffness = NewAngularStiffness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44AE0
//		Name   -> Function Engine.PhysicsHandleComponent.SetAngularDamping
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewAngularDamping                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsHandleComponent::SetAngularDamping(float NewAngularDamping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetAngularDamping");

	UPhysicsHandleComponent_SetAngularDamping_Params params {};
	params.NewAngularDamping = NewAngularDamping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C436D0
//		Name   -> Function Engine.PhysicsHandleComponent.ReleaseComponent
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
void UPhysicsHandleComponent::ReleaseComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.ReleaseComponent");

	UPhysicsHandleComponent_ReleaseComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40720
//		Name   -> Function Engine.PhysicsHandleComponent.GrabComponent
//		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UPrimitiveComponent*                         Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       InBoneName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     GrabLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bConstrainRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsHandleComponent::GrabComponent(class UPrimitiveComponent* Component, const struct FName& InBoneName, const struct FVector& GrabLocation, bool bConstrainRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponent");

	UPhysicsHandleComponent_GrabComponent_Params params {};
	params.Component = Component;
	params.InBoneName = InBoneName;
	params.GrabLocation = GrabLocation;
	params.bConstrainRotation = bConstrainRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40220
//		Name   -> Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation
//		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     TargetLocation                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    TargetRotation                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsHandleComponent::GetTargetLocationAndRotation(struct FVector* TargetLocation, struct FRotator* TargetRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation");

	UPhysicsHandleComponent_GetTargetLocationAndRotation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (TargetLocation != nullptr)
		*TargetLocation = params.TargetLocation;
	if (TargetRotation != nullptr)
		*TargetRotation = params.TargetRotation;

}


void UPhysicsHandleComponent::AfterRead()
{
	UActorComponent::AfterRead();

	READ_PTR_FULL(GrabbedComponent, UPrimitiveComponent);
}

void UPhysicsHandleComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

	DELE_PTR_FULL(GrabbedComponent);
}

// Function:
//		Offset -> 0x02C4D240
//		Name   -> Function Engine.PlatformEventsComponent.SupportsConvertibleLaptops
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UPlatformEventsComponent::SupportsConvertibleLaptops()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.SupportsConvertibleLaptops");

	UPlatformEventsComponent_SupportsConvertibleLaptops_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.PlatformEventsComponent.PlatformEventDelegate__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate)
void UPlatformEventsComponent::PlatformEventDelegate__DelegateSignature()
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.PlatformEventsComponent.PlatformEventDelegate__DelegateSignature");

	UPlatformEventsComponent_PlatformEventDelegate__DelegateSignature_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40D20
//		Name   -> Function Engine.PlatformEventsComponent.IsInTabletMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UPlatformEventsComponent::IsInTabletMode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.IsInTabletMode");

	UPlatformEventsComponent_IsInTabletMode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40CF0
//		Name   -> Function Engine.PlatformEventsComponent.IsInLaptopMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UPlatformEventsComponent::IsInLaptopMode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.IsInLaptopMode");

	UPlatformEventsComponent_IsInLaptopMode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UPlatformEventsComponent::AfterRead()
{
	UActorComponent::AfterRead();

}

void UPlatformEventsComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D030
//		Name   -> Function Engine.AtmosphericFogComponent.StartPrecompute
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UAtmosphericFogComponent::StartPrecompute()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.StartPrecompute");

	UAtmosphericFogComponent_StartPrecompute_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4A820
//		Name   -> Function Engine.AtmosphericFogComponent.SetSunMultiplier
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewSunMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAtmosphericFogComponent::SetSunMultiplier(float NewSunMultiplier)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetSunMultiplier");

	UAtmosphericFogComponent_SetSunMultiplier_Params params {};
	params.NewSunMultiplier = NewSunMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4A270
//		Name   -> Function Engine.AtmosphericFogComponent.SetStartDistance
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewStartDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAtmosphericFogComponent::SetStartDistance(float NewStartDistance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetStartDistance");

	UAtmosphericFogComponent_SetStartDistance_Params params {};
	params.NewStartDistance = NewStartDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C494B0
//		Name   -> Function Engine.AtmosphericFogComponent.SetPrecomputeParams
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              DensityHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                MaxScatteringOrder                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                InscatterAltitudeSampleNum                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAtmosphericFogComponent::SetPrecomputeParams(float DensityHeight, int MaxScatteringOrder, int InscatterAltitudeSampleNum)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetPrecomputeParams");

	UAtmosphericFogComponent_SetPrecomputeParams_Params params {};
	params.DensityHeight = DensityHeight;
	params.MaxScatteringOrder = MaxScatteringOrder;
	params.InscatterAltitudeSampleNum = InscatterAltitudeSampleNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47970
//		Name   -> Function Engine.AtmosphericFogComponent.SetFogMultiplier
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewFogMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAtmosphericFogComponent::SetFogMultiplier(float NewFogMultiplier)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetFogMultiplier");

	UAtmosphericFogComponent_SetFogMultiplier_Params params {};
	params.NewFogMultiplier = NewFogMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46CE0
//		Name   -> Function Engine.AtmosphericFogComponent.SetDistanceScale
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewDistanceScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAtmosphericFogComponent::SetDistanceScale(float NewDistanceScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDistanceScale");

	UAtmosphericFogComponent_SetDistanceScale_Params params {};
	params.NewDistanceScale = NewDistanceScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46C60
//		Name   -> Function Engine.AtmosphericFogComponent.SetDistanceOffset
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewDistanceOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAtmosphericFogComponent::SetDistanceOffset(float NewDistanceOffset)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDistanceOffset");

	UAtmosphericFogComponent_SetDistanceOffset_Params params {};
	params.NewDistanceOffset = NewDistanceOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C468E0
//		Name   -> Function Engine.AtmosphericFogComponent.SetDensityOffset
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewDensityOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAtmosphericFogComponent::SetDensityOffset(float NewDensityOffset)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDensityOffset");

	UAtmosphericFogComponent_SetDensityOffset_Params params {};
	params.NewDensityOffset = NewDensityOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46860
//		Name   -> Function Engine.AtmosphericFogComponent.SetDensityMultiplier
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewDensityMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAtmosphericFogComponent::SetDensityMultiplier(float NewDensityMultiplier)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDensityMultiplier");

	UAtmosphericFogComponent_SetDensityMultiplier_Params params {};
	params.NewDensityMultiplier = NewDensityMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C467E0
//		Name   -> Function Engine.AtmosphericFogComponent.SetDefaultLightColor
//		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                NewLightColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAtmosphericFogComponent::SetDefaultLightColor(const struct FLinearColor& NewLightColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDefaultLightColor");

	UAtmosphericFogComponent_SetDefaultLightColor_Params params {};
	params.NewLightColor = NewLightColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46760
//		Name   -> Function Engine.AtmosphericFogComponent.SetDefaultBrightness
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewBrightness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAtmosphericFogComponent::SetDefaultBrightness(float NewBrightness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDefaultBrightness");

	UAtmosphericFogComponent_SetDefaultBrightness_Params params {};
	params.NewBrightness = NewBrightness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44950
//		Name   -> Function Engine.AtmosphericFogComponent.SetAltitudeScale
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewAltitudeScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAtmosphericFogComponent::SetAltitudeScale(float NewAltitudeScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetAltitudeScale");

	UAtmosphericFogComponent_SetAltitudeScale_Params params {};
	params.NewAltitudeScale = NewAltitudeScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3B870
//		Name   -> Function Engine.AtmosphericFogComponent.DisableSunDisk
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               NewSunDisk                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAtmosphericFogComponent::DisableSunDisk(bool NewSunDisk)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.DisableSunDisk");

	UAtmosphericFogComponent_DisableSunDisk_Params params {};
	params.NewSunDisk = NewSunDisk;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3B7C0
//		Name   -> Function Engine.AtmosphericFogComponent.DisableGroundScattering
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               NewGroundScattering                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAtmosphericFogComponent::DisableGroundScattering(bool NewGroundScattering)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.DisableGroundScattering");

	UAtmosphericFogComponent_DisableGroundScattering_Params params {};
	params.NewGroundScattering = NewGroundScattering;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UAtmosphericFogComponent::AfterRead()
{
	USceneComponent::AfterRead();

	READ_PTR_FULL(TransmittanceTexture, UTexture2D);
	READ_PTR_FULL(IrradianceTexture, UTexture2D);
}

void UAtmosphericFogComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

	DELE_PTR_FULL(TransmittanceTexture);
	DELE_PTR_FULL(IrradianceTexture);
}

void USoundAttenuation::AfterRead()
{
	UObject::AfterRead();

}

void USoundAttenuation::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D050
//		Name   -> Function Engine.AudioComponent.Stop
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UAudioComponent::Stop()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.Stop");

	UAudioComponent_Stop_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4B540
//		Name   -> Function Engine.AudioComponent.SetWaveParameter
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USoundWave*                                  InWave                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAudioComponent::SetWaveParameter(const struct FName& InName, class USoundWave* InWave)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetWaveParameter");

	UAudioComponent_SetWaveParameter_Params params {};
	params.InName = InName;
	params.InWave = InWave;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4B2A0
//		Name   -> Function Engine.AudioComponent.SetVolumeMultiplier
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewVolumeMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAudioComponent::SetVolumeMultiplier(float NewVolumeMultiplier)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetVolumeMultiplier");

	UAudioComponent_SetVolumeMultiplier_Params params {};
	params.NewVolumeMultiplier = NewVolumeMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4AF30
//		Name   -> Function Engine.AudioComponent.SetUISound
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bInUISound                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAudioComponent::SetUISound(bool bInUISound)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetUISound");

	UAudioComponent_SetUISound_Params params {};
	params.bInUISound = bInUISound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49AF0
//		Name   -> Function Engine.AudioComponent.SetSound
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USoundBase*                                  NewSound                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAudioComponent::SetSound(class USoundBase* NewSound)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSound");

	UAudioComponent_SetSound_Params params {};
	params.NewSound = NewSound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C490C0
//		Name   -> Function Engine.AudioComponent.SetPitchMultiplier
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewPitchMultiplier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAudioComponent::SetPitchMultiplier(float NewPitchMultiplier)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetPitchMultiplier");

	UAudioComponent_SetPitchMultiplier_Params params {};
	params.NewPitchMultiplier = NewPitchMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48240
//		Name   -> Function Engine.AudioComponent.SetIntParameter
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAudioComponent::SetIntParameter(const struct FName& InName, int InInt)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetIntParameter");

	UAudioComponent_SetIntParameter_Params params {};
	params.InName = InName;
	params.InInt = InInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47500
//		Name   -> Function Engine.AudioComponent.SetFloatParameter
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAudioComponent::SetFloatParameter(const struct FName& InName, float InFloat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetFloatParameter");

	UAudioComponent_SetFloatParameter_Params params {};
	params.InName = InName;
	params.InFloat = InFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C45A00
//		Name   -> Function Engine.AudioComponent.SetBoolParameter
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAudioComponent::SetBoolParameter(const struct FName& InName, bool InBool)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetBoolParameter");

	UAudioComponent_SetBoolParameter_Params params {};
	params.InName = InName;
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C42250
//		Name   -> Function Engine.AudioComponent.Play
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAudioComponent::Play(float StartTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.Play");

	UAudioComponent_Play_Params params {};
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40D80
//		Name   -> Function Engine.AudioComponent.IsPlaying
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UAudioComponent::IsPlaying()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.IsPlaying");

	UAudioComponent_IsPlaying_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3BD90
//		Name   -> Function Engine.AudioComponent.FadeOut
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              FadeOutDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              FadeVolumeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAudioComponent::FadeOut(float FadeOutDuration, float FadeVolumeLevel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.FadeOut");

	UAudioComponent_FadeOut_Params params {};
	params.FadeOutDuration = FadeOutDuration;
	params.FadeVolumeLevel = FadeVolumeLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3BC80
//		Name   -> Function Engine.AudioComponent.FadeIn
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              FadeInDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              FadeVolumeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAudioComponent::FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.FadeIn");

	UAudioComponent_FadeIn_Params params {};
	params.FadeInDuration = FadeInDuration;
	params.FadeVolumeLevel = FadeVolumeLevel;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C394B0
//		Name   -> Function Engine.AudioComponent.BP_GetAttenuationSettingsToApply
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FAttenuationSettings                        OutAttenuationSettings                                     (Parm, OutParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UAudioComponent::BP_GetAttenuationSettingsToApply(struct FAttenuationSettings* OutAttenuationSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.BP_GetAttenuationSettingsToApply");

	UAudioComponent_BP_GetAttenuationSettingsToApply_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutAttenuationSettings != nullptr)
		*OutAttenuationSettings = params.OutAttenuationSettings;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C38440
//		Name   -> Function Engine.AudioComponent.AdjustVolume
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              AdjustVolumeDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              AdjustVolumeLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAudioComponent::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.AdjustVolume");

	UAudioComponent_AdjustVolume_Params params {};
	params.AdjustVolumeDuration = AdjustVolumeDuration;
	params.AdjustVolumeLevel = AdjustVolumeLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C382D0
//		Name   -> Function Engine.AudioComponent.AdjustAttenuation
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FAttenuationSettings                        InAttenuationSettings                                      (ConstParm, Parm, OutParm, ReferenceParm)
void UAudioComponent::AdjustAttenuation(const struct FAttenuationSettings& InAttenuationSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.AdjustAttenuation");

	UAudioComponent_AdjustAttenuation_Params params {};
	params.InAttenuationSettings = InAttenuationSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UAudioComponent::AfterRead()
{
	USceneComponent::AfterRead();

	READ_PTR_FULL(Sound, USoundBase);
	READ_PTR_FULL(SoundClassOverride, USoundClass);
	READ_PTR_FULL(AttenuationSettings, USoundAttenuation);
}

void UAudioComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

	DELE_PTR_FULL(Sound);
	DELE_PTR_FULL(SoundClassOverride);
	DELE_PTR_FULL(AttenuationSettings);
}

void UBasisComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UBasisComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

void UCalmWaterComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UCalmWaterComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C46290
//		Name   -> Function Engine.ChildActorComponent.SetChildActorClass
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      InClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void UChildActorComponent::SetChildActorClass(class UClass* InClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ChildActorComponent.SetChildActorClass");

	UChildActorComponent_SetChildActorClass_Params params {};
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UChildActorComponent::AfterRead()
{
	USceneComponent::AfterRead();

	READ_PTR_FULL(ChildActorClass, UClass);
	READ_PTR_FULL(ChildActor, AActor);
}

void UChildActorComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

	DELE_PTR_FULL(ChildActorClass);
	DELE_PTR_FULL(ChildActor);
}

void UEditorOnlyChildActorComponent::AfterRead()
{
	UChildActorComponent::AfterRead();

	READ_PTR_FULL(CachedChildActorClass, UClass);
}

void UEditorOnlyChildActorComponent::BeforeDelete()
{
	UChildActorComponent::BeforeDelete();

	DELE_PTR_FULL(CachedChildActorClass);
}

// Function:
//		Offset -> 0x02C49A70
//		Name   -> Function Engine.DecalComponent.SetSortOrder
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDecalComponent::SetSortOrder(int Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetSortOrder");

	UDecalComponent_SetSortOrder_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48580
//		Name   -> Function Engine.DecalComponent.SetLifeSpan
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              LifeSpan                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDecalComponent::SetLifeSpan(float LifeSpan)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetLifeSpan");

	UDecalComponent_SetLifeSpan_Params params {};
	params.LifeSpan = LifeSpan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C466E0
//		Name   -> Function Engine.DecalComponent.SetDecalMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          NewDecalMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDecalComponent::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetDecalMaterial");

	UDecalComponent_SetDecalMaterial_Params params {};
	params.NewDecalMaterial = NewDecalMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3D900
//		Name   -> Function Engine.DecalComponent.GetDecalMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UMaterialInterface*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInterface* UDecalComponent::GetDecalMaterial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetDecalMaterial");

	UDecalComponent_GetDecalMaterial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D8D0
//		Name   -> Function Engine.DecalComponent.GetDecalDynamicMaterialInstance
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UMaterialInstanceDynamic*                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInstanceDynamic* UDecalComponent::GetDecalDynamicMaterialInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetDecalDynamicMaterialInstance");

	UDecalComponent_GetDecalDynamicMaterialInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3B2A0
//		Name   -> Function Engine.DecalComponent.CreateDynamicMaterialInstance
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInstanceDynamic*                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInstanceDynamic* UDecalComponent::CreateDynamicMaterialInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.CreateDynamicMaterialInstance");

	UDecalComponent_CreateDynamicMaterialInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UDecalComponent::AfterRead()
{
	USceneComponent::AfterRead();

	READ_PTR_FULL(DecalMaterial, UMaterialInterface);
	READ_PTR_FULL(MaterialInstanceDynamic, UMaterialInstanceDynamic);
}

void UDecalComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

	DELE_PTR_FULL(DecalMaterial);
	DELE_PTR_FULL(MaterialInstanceDynamic);
}

// Function:
//		Offset -> 0x02C4A2F0
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetStartDistance
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetStartDistance(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetStartDistance");

	UExponentialHeightFogComponent_SetStartDistance_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C481C0
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetInscatteringStartScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetInscatteringStartScale(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringStartScale");

	UExponentialHeightFogComponent_SetInscatteringStartScale_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48140
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetInscatteringFarScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetInscatteringFarScale(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringFarScale");

	UExponentialHeightFogComponent_SetInscatteringFarScale_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C478F0
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetFogMaxOpacity(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity");

	UExponentialHeightFogComponent_SetFogMaxOpacity_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47870
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UExponentialHeightFogComponent::SetFogInscatteringColor(const struct FLinearColor& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor");

	UExponentialHeightFogComponent_SetFogInscatteringColor_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C477F0
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetFogHeightFalloff(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff");

	UExponentialHeightFogComponent_SetFogHeightFalloff_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47770
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetFogDensity
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetFogDensity(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogDensity");

	UExponentialHeightFogComponent_SetFogDensity_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47480
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetFarInscatteringColour
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UExponentialHeightFogComponent::SetFarInscatteringColour(const struct FLinearColor& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFarInscatteringColour");

	UExponentialHeightFogComponent_SetFarInscatteringColour_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47380
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetExponentialFogFarDistance
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetExponentialFogFarDistance(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetExponentialFogFarDistance");

	UExponentialHeightFogComponent_SetExponentialFogFarDistance_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46BE0
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetDirectionalInscatteringStartScale(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartScale");

	UExponentialHeightFogComponent_SetDirectionalInscatteringStartScale_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46B60
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetDirectionalInscatteringStartDistance(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance");

	UExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46AE0
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringFarScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetDirectionalInscatteringFarScale(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringFarScale");

	UExponentialHeightFogComponent_SetDirectionalInscatteringFarScale_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46A60
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UExponentialHeightFogComponent::SetDirectionalInscatteringExponent(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent");

	UExponentialHeightFogComponent_SetDirectionalInscatteringExponent_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C469E0
//		Name   -> Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UExponentialHeightFogComponent::SetDirectionalInscatteringColor(const struct FLinearColor& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor");

	UExponentialHeightFogComponent_SetDirectionalInscatteringColor_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UExponentialHeightFogComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UExponentialHeightFogComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D5F0
//		Name   -> Function Engine.FogVolumeComponent.UpdateFog
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UFogVolumeComponent::UpdateFog()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FogVolumeComponent.UpdateFog");

	UFogVolumeComponent_UpdateFog_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UFogVolumeComponent::AfterRead()
{
	USceneComponent::AfterRead();

	READ_PTR_FULL(VolumeTexture, UTexture);
	READ_PTR_FULL(DensityMap, UTexture);
	READ_PTR_FULL(MeshFogVolumeTexture, UTexture);
}

void UFogVolumeComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

	DELE_PTR_FULL(VolumeTexture);
	DELE_PTR_FULL(DensityMap);
	DELE_PTR_FULL(MeshFogVolumeTexture);
}

void UInstancedNavMeshInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UInstancedNavMeshInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UInstancedNavMeshComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UInstancedNavMeshComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02B3B570
//		Name   -> Function Engine.LightComponentBase.SetCastShadows
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ULightComponentBase::SetCastShadows(bool bNewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastShadows");

	ULightComponentBase_SetCastShadows_Params params {};
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B326D0
//		Name   -> Function Engine.LightComponentBase.GetLightColor
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor ULightComponentBase::GetLightColor()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.GetLightColor");

	ULightComponentBase_GetLightColor_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void ULightComponentBase::AfterRead()
{
	USceneComponent::AfterRead();

}

void ULightComponentBase::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02B3FBE0
//		Name   -> Function Engine.LightComponent.SetTemperature
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewTemperature                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ULightComponent::SetTemperature(float NewTemperature)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetTemperature");

	ULightComponent_SetTemperature_Params params {};
	params.NewTemperature = NewTemperature;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D6A0
//		Name   -> Function Engine.LightComponent.SetLightFunctionScale
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLightFunctionScale                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ULightComponent::SetLightFunctionScale(const struct FVector& NewLightFunctionScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionScale");

	ULightComponent_SetLightFunctionScale_Params params {};
	params.NewLightFunctionScale = NewLightFunctionScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D590
//		Name   -> Function Engine.LightComponent.SetLightFunctionMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          NewLightFunctionMaterial                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ULightComponent::SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionMaterial");

	ULightComponent_SetLightFunctionMaterial_Params params {};
	params.NewLightFunctionMaterial = NewLightFunctionMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D490
//		Name   -> Function Engine.LightComponent.SetLightFunctionFadeDistance
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewLightFunctionFadeDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ULightComponent::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionFadeDistance");

	ULightComponent_SetLightFunctionFadeDistance_Params params {};
	params.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D390
//		Name   -> Function Engine.LightComponent.SetLightFunctionDisabledBrightness
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ULightComponent::SetLightFunctionDisabledBrightness(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionDisabledBrightness");

	ULightComponent_SetLightFunctionDisabledBrightness_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D240
//		Name   -> Function Engine.LightComponent.SetLightColor
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                NewLightColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSRGB                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ULightComponent::SetLightColor(const struct FLinearColor& NewLightColor, bool bSRGB)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightColor");

	ULightComponent_SetLightColor_Params params {};
	params.NewLightColor = NewLightColor;
	params.bSRGB = bSRGB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D140
//		Name   -> Function Engine.LightComponent.SetIntensity
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewIntensity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ULightComponent::SetIntensity(float NewIntensity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIntensity");

	ULightComponent_SetIntensity_Params params {};
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D040
//		Name   -> Function Engine.LightComponent.SetIndirectLightingIntensity
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewIntensity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ULightComponent::SetIndirectLightingIntensity(float NewIntensity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIndirectLightingIntensity");

	ULightComponent_SetIndirectLightingIntensity_Params params {};
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3CFC0
//		Name   -> Function Engine.LightComponent.SetIESTexture
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UTextureLightProfile*                        NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ULightComponent::SetIESTexture(class UTextureLightProfile* NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIESTexture");

	ULightComponent_SetIESTexture_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3CB60
//		Name   -> Function Engine.LightComponent.SetEnableLightShaftBloom
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ULightComponent::SetEnableLightShaftBloom(bool bNewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetEnableLightShaftBloom");

	ULightComponent_SetEnableLightShaftBloom_Params params {};
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B2D0
//		Name   -> Function Engine.LightComponent.SetBloomTint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FColor                                      NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ULightComponent::SetBloomTint(const struct FColor& NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomTint");

	ULightComponent_SetBloomTint_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B250
//		Name   -> Function Engine.LightComponent.SetBloomThreshold
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ULightComponent::SetBloomThreshold(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomThreshold");

	ULightComponent_SetBloomThreshold_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B1D0
//		Name   -> Function Engine.LightComponent.SetBloomScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ULightComponent::SetBloomScale(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomScale");

	ULightComponent_SetBloomScale_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39950
//		Name   -> Function Engine.LightComponent.SetAffectTranslucentLighting
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ULightComponent::SetAffectTranslucentLighting(bool bNewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetAffectTranslucentLighting");

	ULightComponent_SetAffectTranslucentLighting_Params params {};
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39830
//		Name   -> Function Engine.LightComponent.SetAffectDynamicIndirectLighting
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ULightComponent::SetAffectDynamicIndirectLighting(bool bNewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetAffectDynamicIndirectLighting");

	ULightComponent_SetAffectDynamicIndirectLighting_Params params {};
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B33310
//		Name   -> Function Engine.LightComponent.GetNumberOfShadowCastersInFirstCascade
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int ULightComponent::GetNumberOfShadowCastersInFirstCascade()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.GetNumberOfShadowCastersInFirstCascade");

	ULightComponent_GetNumberOfShadowCastersInFirstCascade_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void ULightComponent::AfterRead()
{
	ULightComponentBase::AfterRead();

	READ_PTR_FULL(LightFunctionMaterial, UMaterialInterface);
	READ_PTR_FULL(IESTexture, UTextureLightProfile);
}

void ULightComponent::BeforeDelete()
{
	ULightComponentBase::BeforeDelete();

	DELE_PTR_FULL(LightFunctionMaterial);
	DELE_PTR_FULL(IESTexture);
}

// Function:
//		Offset -> 0x02C4AE30
//		Name   -> Function Engine.AmbientLightSourceComponent.SetTint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                NewTint                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAmbientLightSourceComponent::SetTint(const struct FLinearColor& NewTint)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AmbientLightSourceComponent.SetTint");

	UAmbientLightSourceComponent_SetTint_Params params {};
	params.NewTint = NewTint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C495C0
//		Name   -> Function Engine.AmbientLightSourceComponent.SetRadius
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewRadius                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAmbientLightSourceComponent::SetRadius(float NewRadius)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AmbientLightSourceComponent.SetRadius");

	UAmbientLightSourceComponent_SetRadius_Params params {};
	params.NewRadius = NewRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47DC0
//		Name   -> Function Engine.AmbientLightSourceComponent.SetGroupingPolicy
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EAmbientLightClusteringPolicy>  Policy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAmbientLightSourceComponent::SetGroupingPolicy(TEnumAsByte<Engine_EAmbientLightClusteringPolicy> Policy)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AmbientLightSourceComponent.SetGroupingPolicy");

	UAmbientLightSourceComponent_SetGroupingPolicy_Params params {};
	params.Policy = Policy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44A60
//		Name   -> Function Engine.AmbientLightSourceComponent.SetAmbientIntensity
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewIntensity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAmbientLightSourceComponent::SetAmbientIntensity(float NewIntensity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AmbientLightSourceComponent.SetAmbientIntensity");

	UAmbientLightSourceComponent_SetAmbientIntensity_Params params {};
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UAmbientLightSourceComponent::AfterRead()
{
	ULightComponent::AfterRead();

}

void UAmbientLightSourceComponent::BeforeDelete()
{
	ULightComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C49960
//		Name   -> Function Engine.DirectionalLightComponent.SetShadowLastTransitionSize
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetShadowLastTransitionSize(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowLastTransitionSize");

	UDirectionalLightComponent_SetShadowLastTransitionSize_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C498E0
//		Name   -> Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetShadowDistanceFadeoutFraction(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction");

	UDirectionalLightComponent_SetShadowDistanceFadeoutFraction_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48F30
//		Name   -> Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetOcclusionMaskDarkness(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness");

	UDirectionalLightComponent_SetOcclusionMaskDarkness_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48EB0
//		Name   -> Function Engine.DirectionalLightComponent.SetNormalOffsetBiasScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetNormalOffsetBiasScale(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetNormalOffsetBiasScale");

	UDirectionalLightComponent_SetNormalOffsetBiasScale_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48700
//		Name   -> Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UDirectionalLightComponent::SetLightShaftOverrideDirection(const struct FVector& NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection");

	UDirectionalLightComponent_SetLightShaftOverrideDirection_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47400
//		Name   -> Function Engine.DirectionalLightComponent.SetFarCascadeUpdateRate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetFarCascadeUpdateRate(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetFarCascadeUpdateRate");

	UDirectionalLightComponent_SetFarCascadeUpdateRate_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46EE0
//		Name   -> Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UDirectionalLightComponent::SetEnableLightShaftOcclusion(bool bNewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion");

	UDirectionalLightComponent_SetEnableLightShaftOcclusion_Params params {};
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46E60
//		Name   -> Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetDynamicShadowDistanceStationaryLight(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight");

	UDirectionalLightComponent_SetDynamicShadowDistanceStationaryLight_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46DE0
//		Name   -> Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetDynamicShadowDistanceMovableLight(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight");

	UDirectionalLightComponent_SetDynamicShadowDistanceMovableLight_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46D60
//		Name   -> Function Engine.DirectionalLightComponent.SetDynamicShadowCascades
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetDynamicShadowCascades(int NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowCascades");

	UDirectionalLightComponent_SetDynamicShadowCascades_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46390
//		Name   -> Function Engine.DirectionalLightComponent.SetCloudsShadowsIntensity
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetCloudsShadowsIntensity(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCloudsShadowsIntensity");

	UDirectionalLightComponent_SetCloudsShadowsIntensity_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46310
//		Name   -> Function Engine.DirectionalLightComponent.SetCloseCascadeUpdateRate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetCloseCascadeUpdateRate(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCloseCascadeUpdateRate");

	UDirectionalLightComponent_SetCloseCascadeUpdateRate_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46210
//		Name   -> Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetCascadeTransitionFraction(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction");

	UDirectionalLightComponent_SetCascadeTransitionFraction_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46190
//		Name   -> Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDirectionalLightComponent::SetCascadeDistributionExponent(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent");

	UDirectionalLightComponent_SetCascadeDistributionExponent_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UDirectionalLightComponent::AfterRead()
{
	ULightComponent::AfterRead();

}

void UDirectionalLightComponent::BeforeDelete()
{
	ULightComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C49BF0
//		Name   -> Function Engine.PointLightComponent.SetSourceRadius
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPointLightComponent::SetSourceRadius(float bNewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSourceRadius");

	UPointLightComponent_SetSourceRadius_Params params {};
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49B70
//		Name   -> Function Engine.PointLightComponent.SetSourceLength
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPointLightComponent::SetSourceLength(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSourceLength");

	UPointLightComponent_SetSourceLength_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48680
//		Name   -> Function Engine.PointLightComponent.SetLightFalloffExponent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewLightFalloffExponent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPointLightComponent::SetLightFalloffExponent(float NewLightFalloffExponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetLightFalloffExponent");

	UPointLightComponent_SetLightFalloffExponent_Params params {};
	params.NewLightFalloffExponent = NewLightFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44DF0
//		Name   -> Function Engine.PointLightComponent.SetAttenuationRadius
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewRadius                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPointLightComponent::SetAttenuationRadius(float NewRadius)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetAttenuationRadius");

	UPointLightComponent_SetAttenuationRadius_Params params {};
	params.NewRadius = NewRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UPointLightComponent::AfterRead()
{
	ULightComponent::AfterRead();

}

void UPointLightComponent::BeforeDelete()
{
	ULightComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C49040
//		Name   -> Function Engine.SpotLightComponent.SetOuterConeAngle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewOuterConeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USpotLightComponent::SetOuterConeAngle(float NewOuterConeAngle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetOuterConeAngle");

	USpotLightComponent_SetOuterConeAngle_Params params {};
	params.NewOuterConeAngle = NewOuterConeAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48480
//		Name   -> Function Engine.SpotLightComponent.SetKickBackProportionality
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewKickBackRatio                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USpotLightComponent::SetKickBackProportionality(float NewKickBackRatio)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetKickBackProportionality");

	USpotLightComponent_SetKickBackProportionality_Params params {};
	params.NewKickBackRatio = NewKickBackRatio;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C480C0
//		Name   -> Function Engine.SpotLightComponent.SetInnerConeAngle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewInnerConeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USpotLightComponent::SetInnerConeAngle(float NewInnerConeAngle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetInnerConeAngle");

	USpotLightComponent_SetInnerConeAngle_Params params {};
	params.NewInnerConeAngle = NewInnerConeAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void USpotLightComponent::AfterRead()
{
	UPointLightComponent::AfterRead();

}

void USpotLightComponent::BeforeDelete()
{
	UPointLightComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C48FB0
//		Name   -> Function Engine.SkyLightComponent.SetOcclusionTint
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FColor                                      InTint                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void USkyLightComponent::SetOcclusionTint(const struct FColor& InTint)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionTint");

	USkyLightComponent_SetOcclusionTint_Params params {};
	params.InTint = InTint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C489B0
//		Name   -> Function Engine.SkyLightComponent.SetMinOcclusion
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InMinOcclusion                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkyLightComponent::SetMinOcclusion(float InMinOcclusion)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetMinOcclusion");

	USkyLightComponent_SetMinOcclusion_Params params {};
	params.InMinOcclusion = InMinOcclusion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48600
//		Name   -> Function Engine.SkyLightComponent.SetLightColor
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                NewLightColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkyLightComponent::SetLightColor(const struct FLinearColor& NewLightColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetLightColor");

	USkyLightComponent_SetLightColor_Params params {};
	params.NewLightColor = NewLightColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48300
//		Name   -> Function Engine.SkyLightComponent.SetIntensity
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewIntensity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkyLightComponent::SetIntensity(float NewIntensity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetIntensity");

	USkyLightComponent_SetIntensity_Params params {};
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48040
//		Name   -> Function Engine.SkyLightComponent.SetIndirectLightingIntensity
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewIntensity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkyLightComponent::SetIndirectLightingIntensity(float NewIntensity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetIndirectLightingIntensity");

	USkyLightComponent_SetIndirectLightingIntensity_Params params {};
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46490
//		Name   -> Function Engine.SkyLightComponent.SetCubemapBlend
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UTextureCube*                                SourceCubemap                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UTextureCube*                                DestinationCubemap                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InBlendFraction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkyLightComponent::SetCubemapBlend(class UTextureCube* SourceCubemap, class UTextureCube* DestinationCubemap, float InBlendFraction)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetCubemapBlend");

	USkyLightComponent_SetCubemapBlend_Params params {};
	params.SourceCubemap = SourceCubemap;
	params.DestinationCubemap = DestinationCubemap;
	params.InBlendFraction = InBlendFraction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46410
//		Name   -> Function Engine.SkyLightComponent.SetCubemap
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UTextureCube*                                NewCubemap                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkyLightComponent::SetCubemap(class UTextureCube* NewCubemap)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetCubemap");

	USkyLightComponent_SetCubemap_Params params {};
	params.NewCubemap = NewCubemap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C435E0
//		Name   -> Function Engine.SkyLightComponent.RecaptureSky
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USkyLightComponent::RecaptureSky()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.RecaptureSky");

	USkyLightComponent_RecaptureSky_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void USkyLightComponent::AfterRead()
{
	ULightComponentBase::AfterRead();

	READ_PTR_FULL(Cubemap, UTextureCube);
	READ_PTR_FULL(BlendDestinationCubemap, UTextureCube);
}

void USkyLightComponent::BeforeDelete()
{
	ULightComponentBase::BeforeDelete();

	DELE_PTR_FULL(Cubemap);
	DELE_PTR_FULL(BlendDestinationCubemap);
}

void UNavigationGraphNodeComponent::AfterRead()
{
	USceneComponent::AfterRead();

	READ_PTR_FULL(NextNodeComponent, UNavigationGraphNodeComponent);
	READ_PTR_FULL(PrevNodeComponent, UNavigationGraphNodeComponent);
}

void UNavigationGraphNodeComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

	DELE_PTR_FULL(NextNodeComponent);
	DELE_PTR_FULL(PrevNodeComponent);
}

// Function:
//		Offset -> 0x02C3FD40
//		Name   -> Function Engine.PhysicsSpringComponent.GetSpringRestingPoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPhysicsSpringComponent::GetSpringRestingPoint()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringRestingPoint");

	UPhysicsSpringComponent_GetSpringRestingPoint_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FD00
//		Name   -> Function Engine.PhysicsSpringComponent.GetSpringDirection
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPhysicsSpringComponent::GetSpringDirection()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringDirection");

	UPhysicsSpringComponent_GetSpringDirection_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FCC0
//		Name   -> Function Engine.PhysicsSpringComponent.GetSpringCurrentEndPoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPhysicsSpringComponent::GetSpringCurrentEndPoint()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringCurrentEndPoint");

	UPhysicsSpringComponent_GetSpringCurrentEndPoint_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3ED00
//		Name   -> Function Engine.PhysicsSpringComponent.GetNormalizedCompressionScalar
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UPhysicsSpringComponent::GetNormalizedCompressionScalar()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetNormalizedCompressionScalar");

	UPhysicsSpringComponent_GetNormalizedCompressionScalar_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UPhysicsSpringComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UPhysicsSpringComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

void UPhysicsThrusterComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UPhysicsThrusterComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C44D70
//		Name   -> Function Engine.ArrowComponent.SetArrowColor_New
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                NewColor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UArrowComponent::SetArrowColor_New(const struct FLinearColor& NewColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ArrowComponent.SetArrowColor_New");

	UArrowComponent_SetArrowColor_New_Params params {};
	params.NewColor = NewColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44CF0
//		Name   -> Function Engine.ArrowComponent.SetArrowColor_DEPRECATED
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FColor                                      NewColor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UArrowComponent::SetArrowColor_DEPRECATED(const struct FColor& NewColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ArrowComponent.SetArrowColor_DEPRECATED");

	UArrowComponent_SetArrowColor_DEPRECATED_Params params {};
	params.NewColor = NewColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UArrowComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

}

void UArrowComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

}

void UWaterId::AfterRead()
{
	UObject::AfterRead();

}

void UWaterId::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UBaseWaterComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

	READ_PTR_FULL(WaterId, UClass);
}

void UBaseWaterComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

	DELE_PTR_FULL(WaterId);
}

// Function:
//		Offset -> 0x02C4B4B0
//		Name   -> Function Engine.FFTWaterComponent.SetWaterPositionOffset
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   PositionOffset                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UFFTWaterComponent::SetWaterPositionOffset(const struct FVector2D& PositionOffset)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetWaterPositionOffset");

	UFFTWaterComponent_SetWaterPositionOffset_Params params {};
	params.PositionOffset = PositionOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4B420
//		Name   -> Function Engine.FFTWaterComponent.SetWaterColour
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                WaterColour                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UFFTWaterComponent::SetWaterColour(const struct FLinearColor& WaterColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetWaterColour");

	UFFTWaterComponent_SetWaterColour_Params params {};
	params.WaterColour = WaterColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49C70
//		Name   -> Function Engine.FFTWaterComponent.SetSpecularBrightness
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              SpecularBrightness                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UFFTWaterComponent::SetSpecularBrightness(float SpecularBrightness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetSpecularBrightness");

	UFFTWaterComponent_SetSpecularBrightness_Params params {};
	params.SpecularBrightness = SpecularBrightness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C499E0
//		Name   -> Function Engine.FFTWaterComponent.SetShallowWaterColour
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                ShallowWaterColour                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UFFTWaterComponent::SetShallowWaterColour(const struct FLinearColor& ShallowWaterColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetShallowWaterColour");

	UFFTWaterComponent_SetShallowWaterColour_Params params {};
	params.ShallowWaterColour = ShallowWaterColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49640
//		Name   -> Function Engine.FFTWaterComponent.SetReflectionBrightness
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              ReflectionBrightness                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UFFTWaterComponent::SetReflectionBrightness(float ReflectionBrightness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetReflectionBrightness");

	UFFTWaterComponent_SetReflectionBrightness_Params params {};
	params.ReflectionBrightness = ReflectionBrightness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48BC0
//		Name   -> Function Engine.FFTWaterComponent.SetMurkyRegion
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FMurkyRegion                                MurkyRegion                                                (ConstParm, Parm, OutParm, ReferenceParm)
void UFFTWaterComponent::SetMurkyRegion(const struct FMurkyRegion& MurkyRegion)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetMurkyRegion");

	UFFTWaterComponent_SetMurkyRegion_Params params {};
	params.MurkyRegion = MurkyRegion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47BC0
//		Name   -> Function Engine.FFTWaterComponent.SetFresnelPower
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              FresnelPower                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UFFTWaterComponent::SetFresnelPower(float FresnelPower)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetFresnelPower");

	UFFTWaterComponent_SetFresnelPower_Params params {};
	params.FresnelPower = FresnelPower;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C476E0
//		Name   -> Function Engine.FFTWaterComponent.SetFoamHighlightColour
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                FoamHighlightColour                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UFFTWaterComponent::SetFoamHighlightColour(const struct FLinearColor& FoamHighlightColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetFoamHighlightColour");

	UFFTWaterComponent_SetFoamHighlightColour_Params params {};
	params.FoamHighlightColour = FoamHighlightColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47650
//		Name   -> Function Engine.FFTWaterComponent.SetFoamColour
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                FoamColour                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UFFTWaterComponent::SetFoamColour(const struct FLinearColor& FoamColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetFoamColour");

	UFFTWaterComponent_SetFoamColour_Params params {};
	params.FoamColour = FoamColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C475D0
//		Name   -> Function Engine.FFTWaterComponent.SetFoamBrightness
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              FoamBrightness                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UFFTWaterComponent::SetFoamBrightness(float FoamBrightness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetFoamBrightness");

	UFFTWaterComponent_SetFoamBrightness_Params params {};
	params.FoamBrightness = FoamBrightness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46080
//		Name   -> Function Engine.FFTWaterComponent.SetCarrierWaveParams
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Amplitude                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              WaveLength                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              PropagationSpeed                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UFFTWaterComponent::SetCarrierWaveParams(float Amplitude, float WaveLength, float PropagationSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetCarrierWaveParams");

	UFFTWaterComponent_SetCarrierWaveParams_Params params {};
	params.Amplitude = Amplitude;
	params.WaveLength = WaveLength;
	params.PropagationSpeed = PropagationSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44F80
//		Name   -> Function Engine.FFTWaterComponent.SetBackLitColour
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                BackLitColour                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UFFTWaterComponent::SetBackLitColour(const struct FLinearColor& BackLitColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetBackLitColour");

	UFFTWaterComponent_SetBackLitColour_Params params {};
	params.BackLitColour = BackLitColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C449D0
//		Name   -> Function Engine.FFTWaterComponent.SetAmbientColour
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                AmbientColour                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UFFTWaterComponent::SetAmbientColour(const struct FLinearColor& AmbientColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.SetAmbientColour");

	UFFTWaterComponent_SetAmbientColour_Params params {};
	params.AmbientColour = AmbientColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40560
//		Name   -> Function Engine.FFTWaterComponent.GetWaterPositionOffset
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   PositionOffset                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UFFTWaterComponent::GetWaterPositionOffset(struct FVector2D* PositionOffset)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterComponent.GetWaterPositionOffset");

	UFFTWaterComponent_GetWaterPositionOffset_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (PositionOffset != nullptr)
		*PositionOffset = params.PositionOffset;

}


void UFFTWaterComponent::AfterRead()
{
	UBaseWaterComponent::AfterRead();

	READ_PTR_FULL(Brush, UModel);
	READ_PTR_FULL(BrushBodySetup, UBodySetup);
	READ_PTR_FULL(LightFunctionMaterial, UMaterialInterface);
	READ_PTR_FULL(DefaultLightFunctionMaterial, UMaterial);
}

void UFFTWaterComponent::BeforeDelete()
{
	UBaseWaterComponent::BeforeDelete();

	DELE_PTR_FULL(Brush);
	DELE_PTR_FULL(BrushBodySetup);
	DELE_PTR_FULL(LightFunctionMaterial);
	DELE_PTR_FULL(DefaultLightFunctionMaterial);
}

// Function:
//		Offset -> 0x02C4A780
//		Name   -> Function Engine.StaticMeshComponent.SetStaticMesh
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UStaticMesh*                                 NewMesh                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UStaticMeshComponent::SetStaticMesh(class UStaticMesh* NewMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetStaticMesh");

	UStaticMeshComponent_SetStaticMesh_Params params {};
	params.NewMesh = NewMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C47A70
//		Name   -> Function Engine.StaticMeshComponent.SetForcedLodModel
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                NewForcedLodModel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UStaticMeshComponent::SetForcedLodModel(int NewForcedLodModel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetForcedLodModel");

	UStaticMeshComponent_SetForcedLodModel_Params params {};
	params.NewForcedLodModel = NewForcedLodModel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46660
//		Name   -> Function Engine.StaticMeshComponent.SetCustomDepthMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UStaticMeshComponent::SetCustomDepthMaterial(class UMaterialInterface* Material)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetCustomDepthMaterial");

	UStaticMeshComponent_SetCustomDepthMaterial_Params params {};
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41DF0
//		Name   -> Function Engine.StaticMeshComponent.OnRep_StaticMesh
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class UStaticMesh*                                 OldStaticMesh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UStaticMeshComponent::OnRep_StaticMesh(class UStaticMesh* OldStaticMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.OnRep_StaticMesh");

	UStaticMeshComponent_OnRep_StaticMesh_Params params {};
	params.OldStaticMesh = OldStaticMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3E990
//		Name   -> Function Engine.StaticMeshComponent.GetLocalBounds
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     Min                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Max                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UStaticMeshComponent::GetLocalBounds(struct FVector* Min, struct FVector* Max)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.GetLocalBounds");

	UStaticMeshComponent_GetLocalBounds_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Min != nullptr)
		*Min = params.Min;
	if (Max != nullptr)
		*Max = params.Max;

}


// Function:
//		Offset -> 0x02C3D6C0
//		Name   -> Function Engine.StaticMeshComponent.GetCustomDepthMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UMaterialInterface*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInterface* UStaticMeshComponent::GetCustomDepthMaterial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.GetCustomDepthMaterial");

	UStaticMeshComponent_GetCustomDepthMaterial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UStaticMeshComponent::AfterRead()
{
	UMeshComponent::AfterRead();

	READ_PTR_FULL(StaticMesh, UStaticMesh);
	READ_PTR_FULL(CustomDepthMaterial, UMaterialInterface);
}

void UStaticMeshComponent::BeforeDelete()
{
	UMeshComponent::BeforeDelete();

	DELE_PTR_FULL(StaticMesh);
	DELE_PTR_FULL(CustomDepthMaterial);
}

void AFogVolume::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(SphereComponent, USphereComponent);
	READ_PTR_FULL(FogVolumeComponent, UFogVolumeComponent);
}

void AFogVolume::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(SphereComponent);
	DELE_PTR_FULL(FogVolumeComponent);
}

void AThreadedActor::AfterRead()
{
	AActor::AfterRead();

}

void AThreadedActor::BeforeDelete()
{
	AActor::BeforeDelete();

}

// Function:
//		Offset -> 0x02B33D20
//		Name   -> Function Engine.MaterialInterface.GetPhysicalMaterial
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UPhysicalMaterial*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UPhysicalMaterial* UMaterialInterface::GetPhysicalMaterial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetPhysicalMaterial");

	UMaterialInterface_GetPhysicalMaterial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31880
//		Name   -> Function Engine.MaterialInterface.GetBaseMaterial
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterial*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterial* UMaterialInterface::GetBaseMaterial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetBaseMaterial");

	UMaterialInterface_GetBaseMaterial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UMaterialInterface::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(SubsurfaceProfile, USubsurfaceProfile);
}

void UMaterialInterface::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(SubsurfaceProfile);
}

void UMaterial::AfterRead()
{
	UMaterialInterface::AfterRead();

	READ_PTR_FULL(PhysMaterial, UPhysicalMaterial);
}

void UMaterial::BeforeDelete()
{
	UMaterialInterface::BeforeDelete();

	DELE_PTR_FULL(PhysMaterial);
}

// Function:
//		Offset -> 0x02D5EE40
//		Name   -> Function Engine.CameraModifier.IsDisabled
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UCameraModifier::IsDisabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.IsDisabled");

	UCameraModifier_IsDisabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5CB70
//		Name   -> Function Engine.CameraModifier.GetViewTarget
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* UCameraModifier::GetViewTarget()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.GetViewTarget");

	UCameraModifier_GetViewTarget_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D57290
//		Name   -> Function Engine.CameraModifier.EnableModifier
//		Flags  -> (Native, Public, BlueprintCallable)
void UCameraModifier::EnableModifier()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.EnableModifier");

	UCameraModifier_EnableModifier_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D54560
//		Name   -> Function Engine.CameraModifier.DisableModifier
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCameraModifier::DisableModifier(bool bImmediate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.DisableModifier");

	UCameraModifier_DisableModifier_Params params {};
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.CameraModifier.BlueprintModifyPostProcess
//		Flags  -> (BlueprintCosmetic, Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              PostProcessBlendWeight                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FPostProcessSettings                        PostProcessSettings                                        (Parm, OutParm)
void UCameraModifier::BlueprintModifyPostProcess(float DeltaTime, float* PostProcessBlendWeight, struct FPostProcessSettings* PostProcessSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.BlueprintModifyPostProcess");

	UCameraModifier_BlueprintModifyPostProcess_Params params {};
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (PostProcessBlendWeight != nullptr)
		*PostProcessBlendWeight = params.PostProcessBlendWeight;
	if (PostProcessSettings != nullptr)
		*PostProcessSettings = params.PostProcessSettings;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.CameraModifier.BlueprintModifyCamera
//		Flags  -> (BlueprintCosmetic, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ViewLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ViewRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              FOV                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NewViewLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    NewViewRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              NewFOV                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCameraModifier::BlueprintModifyCamera(float DeltaTime, const struct FVector& ViewLocation, const struct FRotator& ViewRotation, float FOV, struct FVector* NewViewLocation, struct FRotator* NewViewRotation, float* NewFOV)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.BlueprintModifyCamera");

	UCameraModifier_BlueprintModifyCamera_Params params {};
	params.DeltaTime = DeltaTime;
	params.ViewLocation = ViewLocation;
	params.ViewRotation = ViewRotation;
	params.FOV = FOV;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (NewViewLocation != nullptr)
		*NewViewLocation = params.NewViewLocation;
	if (NewViewRotation != nullptr)
		*NewViewRotation = params.NewViewRotation;
	if (NewFOV != nullptr)
		*NewFOV = params.NewFOV;

}


void UCameraModifier::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(CameraOwner, APlayerCameraManager);
}

void UCameraModifier::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(CameraOwner);
}

void APhysicsVolume::AfterRead()
{
	AVolume::AfterRead();

}

void APhysicsVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

// Function:
//		Offset -> 0x02B40130
//		Name   -> Function Engine.ParticleSystemComponent.SetVectorParameter
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UParticleSystemComponent::SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetVectorParameter");

	UParticleSystemComponent_SetVectorParameter_Params params {};
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3FD70
//		Name   -> Function Engine.ParticleSystemComponent.SetTrailSourceData
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       InFirstSocketName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       InSecondSocketName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ETrailWidthMode>                InWidthMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InWidth                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetTrailSourceData(const struct FName& InFirstSocketName, const struct FName& InSecondSocketName, TEnumAsByte<Engine_ETrailWidthMode> InWidthMode, float InWidth)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetTrailSourceData");

	UParticleSystemComponent_SetTrailSourceData_Params params {};
	params.InFirstSocketName = InFirstSocketName;
	params.InSecondSocketName = InSecondSocketName;
	params.InWidthMode = InWidthMode;
	params.InWidth = InWidth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3FCF0
//		Name   -> Function Engine.ParticleSystemComponent.SetTemplate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystem*                             NewTemplate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetTemplate(class UParticleSystem* NewTemplate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetTemplate");

	UParticleSystemComponent_SetTemplate_Params params {};
	params.NewTemplate = NewTemplate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E460
//		Name   -> Function Engine.ParticleSystemComponent.SetMaterialParameter
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInterface*                          Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetMaterialParameter(const struct FName& ParameterName, class UMaterialInterface* Param)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetMaterialParameter");

	UParticleSystemComponent_SetMaterialParameter_Params params {};
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3CDE0
//		Name   -> Function Engine.ParticleSystemComponent.SetFloatParameter
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetFloatParameter(const struct FName& ParameterName, float Param)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetFloatParameter");

	UParticleSystemComponent_SetFloatParameter_Params params {};
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3CA40
//		Name   -> Function Engine.ParticleSystemComponent.SetEnableDistanceFading
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UParticleSystemComponent::SetEnableDistanceFading(bool bEnable)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetEnableDistanceFading");

	UParticleSystemComponent_SetEnableDistanceFading_Params params {};
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C970
//		Name   -> Function Engine.ParticleSystemComponent.SetEmitterEnable
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       EmitterName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bNewEnableState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UParticleSystemComponent::SetEmitterEnable(const struct FName& EmitterName, bool bNewEnableState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetEmitterEnable");

	UParticleSystemComponent_SetEmitterEnable_Params params {};
	params.EmitterName = EmitterName;
	params.bNewEnableState = bNewEnableState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C500
//		Name   -> Function Engine.ParticleSystemComponent.SetCustomLocalSpaceWorldSpace
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UParticleSystemComponent::SetCustomLocalSpaceWorldSpace()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetCustomLocalSpaceWorldSpace");

	UParticleSystemComponent_SetCustomLocalSpaceWorldSpace_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C480
//		Name   -> Function Engine.ParticleSystemComponent.SetCustomLocalSpaceComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USceneComponent*                             InComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetCustomLocalSpaceComponent(class USceneComponent* InComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetCustomLocalSpaceComponent");

	UParticleSystemComponent_SetCustomLocalSpaceComponent_Params params {};
	params.InComponent = InComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3BD40
//		Name   -> Function Engine.ParticleSystemComponent.SetColorParameter
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UParticleSystemComponent::SetColorParameter(const struct FName& ParameterName, const struct FLinearColor& Param)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetColorParameter");

	UParticleSystemComponent_SetColorParameter_Params params {};
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B0C0
//		Name   -> Function Engine.ParticleSystemComponent.SetBeamTargetTangent
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NewTangentPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetBeamTargetTangent(int EmitterIndex, const struct FVector& NewTangentPoint, int TargetIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetTangent");

	UParticleSystemComponent_SetBeamTargetTangent_Params params {};
	params.EmitterIndex = EmitterIndex;
	params.NewTangentPoint = NewTangentPoint;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3AFC0
//		Name   -> Function Engine.ParticleSystemComponent.SetBeamTargetStrength
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              NewTargetStrength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetBeamTargetStrength(int EmitterIndex, float NewTargetStrength, int TargetIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetStrength");

	UParticleSystemComponent_SetBeamTargetStrength_Params params {};
	params.EmitterIndex = EmitterIndex;
	params.NewTargetStrength = NewTargetStrength;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3AEB0
//		Name   -> Function Engine.ParticleSystemComponent.SetBeamTargetPoint
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NewTargetPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetBeamTargetPoint(int EmitterIndex, const struct FVector& NewTargetPoint, int TargetIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetPoint");

	UParticleSystemComponent_SetBeamTargetPoint_Params params {};
	params.EmitterIndex = EmitterIndex;
	params.NewTargetPoint = NewTargetPoint;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3ADA0
//		Name   -> Function Engine.ParticleSystemComponent.SetBeamSourceTangent
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NewTangentPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                SourceIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetBeamSourceTangent(int EmitterIndex, const struct FVector& NewTangentPoint, int SourceIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourceTangent");

	UParticleSystemComponent_SetBeamSourceTangent_Params params {};
	params.EmitterIndex = EmitterIndex;
	params.NewTangentPoint = NewTangentPoint;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3ACA0
//		Name   -> Function Engine.ParticleSystemComponent.SetBeamSourceStrength
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              NewSourceStrength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                SourceIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetBeamSourceStrength(int EmitterIndex, float NewSourceStrength, int SourceIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourceStrength");

	UParticleSystemComponent_SetBeamSourceStrength_Params params {};
	params.EmitterIndex = EmitterIndex;
	params.NewSourceStrength = NewSourceStrength;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3AB90
//		Name   -> Function Engine.ParticleSystemComponent.SetBeamSourcePoint
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NewSourcePoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                SourceIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetBeamSourcePoint(int EmitterIndex, const struct FVector& NewSourcePoint, int SourceIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourcePoint");

	UParticleSystemComponent_SetBeamSourcePoint_Params params {};
	params.EmitterIndex = EmitterIndex;
	params.NewSourcePoint = NewSourcePoint;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3AAC0
//		Name   -> Function Engine.ParticleSystemComponent.SetBeamEndPoint
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NewEndPoint                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UParticleSystemComponent::SetBeamEndPoint(int EmitterIndex, const struct FVector& NewEndPoint)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamEndPoint");

	UParticleSystemComponent_SetBeamEndPoint_Params params {};
	params.EmitterIndex = EmitterIndex;
	params.NewEndPoint = NewEndPoint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39770
//		Name   -> Function Engine.ParticleSystemComponent.SetActorParameter
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::SetActorParameter(const struct FName& ParameterName, class AActor* Param)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetActorParameter");

	UParticleSystemComponent_SetActorParameter_Params params {};
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B33220
//		Name   -> Function Engine.ParticleSystemComponent.GetNumActiveParticles
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UParticleSystemComponent::GetNumActiveParticles()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetNumActiveParticles");

	UParticleSystemComponent_GetNumActiveParticles_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B330B0
//		Name   -> Function Engine.ParticleSystemComponent.GetNamedMaterial
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInterface*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInterface* UParticleSystemComponent::GetNamedMaterial(const struct FName& InName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetNamedMaterial");

	UParticleSystemComponent_GetNamedMaterial_Params params {};
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B312B0
//		Name   -> Function Engine.ParticleSystemComponent.GenerateParticleEvent
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       InEventName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InEmitterTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     InLocation                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     InDirection                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     InVelocity                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UParticleSystemComponent::GenerateParticleEvent(const struct FName& InEventName, float InEmitterTime, const struct FVector& InLocation, const struct FVector& InDirection, const struct FVector& InVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GenerateParticleEvent");

	UParticleSystemComponent_GenerateParticleEvent_Params params {};
	params.InEventName = InEventName;
	params.InEmitterTime = InEmitterTime;
	params.InLocation = InLocation;
	params.InDirection = InDirection;
	params.InVelocity = InVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B30D00
//		Name   -> Function Engine.ParticleSystemComponent.EndTrails
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UParticleSystemComponent::EndTrails()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.EndTrails");

	UParticleSystemComponent_EndTrails_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2F580
//		Name   -> Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInterface*                          SourceMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInstanceDynamic*                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInstanceDynamic* UParticleSystemComponent::CreateNamedDynamicMaterialInstance(const struct FName& InName, class UMaterialInterface* SourceMaterial)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance");

	UParticleSystemComponent_CreateNamedDynamicMaterialInstance_Params params {};
	params.InName = InName;
	params.SourceMaterial = SourceMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2E820
//		Name   -> Function Engine.ParticleSystemComponent.BeginTrails
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       InFirstSocketName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       InSecondSocketName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ETrailWidthMode>                InWidthMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InWidth                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UParticleSystemComponent::BeginTrails(const struct FName& InFirstSocketName, const struct FName& InSecondSocketName, TEnumAsByte<Engine_ETrailWidthMode> InWidthMode, float InWidth)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.BeginTrails");

	UParticleSystemComponent_BeginTrails_Params params {};
	params.InFirstSocketName = InFirstSocketName;
	params.InSecondSocketName = InSecondSocketName;
	params.InWidthMode = InWidthMode;
	params.InWidth = InWidth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2DFC0
//		Name   -> Function Engine.ParticleSystemComponent.AddKillSphere
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector4                                    KillSphere                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UParticleSystemComponent::AddKillSphere(const struct FVector4& KillSphere)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.AddKillSphere");

	UParticleSystemComponent_AddKillSphere_Params params {};
	params.KillSphere = KillSphere;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2D6F0
//		Name   -> Function Engine.ParticleSystemComponent.AddEmitterPoint
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector4                                    Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector4                                    InheritedVelocity                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector4                                    Orientation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Scale                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UParticleSystemComponent::AddEmitterPoint(const struct FVector4& Position, const struct FVector4& InheritedVelocity, const struct FVector4& Orientation, const struct FVector& Scale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.AddEmitterPoint");

	UParticleSystemComponent_AddEmitterPoint_Params params {};
	params.Position = Position;
	params.InheritedVelocity = InheritedVelocity;
	params.Orientation = Orientation;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UParticleSystemComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

	READ_PTR_FULL(Template, UParticleSystem);
}

void UParticleSystemComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

	DELE_PTR_FULL(Template);
}

// Function:
//		Offset -> 0x02B402A0
//		Name   -> Function Engine.SplineComponent.SetWorldLocationAtSplinePoint
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     InLocation                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void USplineComponent::SetWorldLocationAtSplinePoint(int PointIndex, const struct FVector& InLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetWorldLocationAtSplinePoint");

	USplineComponent_SetWorldLocationAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.InLocation = InLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3FF40
//		Name   -> Function Engine.SplineComponent.SetUnselectedSplineSegmentColor
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                SegmentColor                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void USplineComponent::SetUnselectedSplineSegmentColor(const struct FLinearColor& SegmentColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetUnselectedSplineSegmentColor");

	USplineComponent_SetUnselectedSplineSegmentColor_Params params {};
	params.SegmentColor = SegmentColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3FAD0
//		Name   -> Function Engine.SplineComponent.SetTangentAtSplinePoint
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     InTangent                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USplineComponent::SetTangentAtSplinePoint(int PointIndex, const struct FVector& InTangent, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetTangentAtSplinePoint");

	USplineComponent_SetTangentAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.InTangent = InTangent;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3FA10
//		Name   -> Function Engine.SplineComponent.SetSplineWorldPoints
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<struct FVector>                             Points                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
void USplineComponent::SetSplineWorldPoints(TArray<struct FVector> Points)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplineWorldPoints");

	USplineComponent_SetSplineWorldPoints_Params params {};
	params.Points = Points;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F850
//		Name   -> Function Engine.SplineComponent.SetSplinePointType
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplinePointType>               Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USplineComponent::SetSplinePointType(int PointIndex, TEnumAsByte<Engine_ESplinePointType> Type)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplinePointType");

	USplineComponent_SetSplinePointType_Params params {};
	params.PointIndex = PointIndex;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F910
//		Name   -> Function Engine.SplineComponent.SetSplinePoints
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<struct FVector>                             Points                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USplineComponent::SetSplinePoints(TArray<struct FVector> Points, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplinePoints");

	USplineComponent_SetSplinePoints_Params params {};
	params.Points = Points;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F790
//		Name   -> Function Engine.SplineComponent.SetSplineLocalPoints
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<struct FVector>                             Points                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
void USplineComponent::SetSplineLocalPoints(TArray<struct FVector> Points)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplineLocalPoints");

	USplineComponent_SetSplineLocalPoints_Params params {};
	params.Points = Points;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F550
//		Name   -> Function Engine.SplineComponent.SetSelectedSplineSegmentColor
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                SegmentColor                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void USplineComponent::SetSelectedSplineSegmentColor(const struct FLinearColor& SegmentColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSelectedSplineSegmentColor");

	USplineComponent_SetSelectedSplineSegmentColor_Params params {};
	params.SegmentColor = SegmentColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3DE60
//		Name   -> Function Engine.SplineComponent.SetLocationAtSplinePoint
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     InLocation                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USplineComponent::SetLocationAtSplinePoint(int PointIndex, const struct FVector& InLocation, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetLocationAtSplinePoint");

	USplineComponent_SetLocationAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.InLocation = InLocation;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C800
//		Name   -> Function Engine.SplineComponent.SetDefaultUpVector
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     UpVector                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USplineComponent::SetDefaultUpVector(const struct FVector& UpVector, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetDefaultUpVector");

	USplineComponent_SetDefaultUpVector_Params params {};
	params.UpVector = UpVector;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B890
//		Name   -> Function Engine.SplineComponent.SetClosedLoop
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bInClosedLoop                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineComponent::SetClosedLoop(bool bInClosedLoop)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetClosedLoop");

	USplineComponent_SetClosedLoop_Params params {};
	params.bInClosedLoop = bInClosedLoop;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B36C10
//		Name   -> Function Engine.SplineComponent.IsClosedLoop
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USplineComponent::IsClosedLoop()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.IsClosedLoop");

	USplineComponent_IsClosedLoop_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36770
//		Name   -> Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetWorldTangentAtDistanceAlongSpline(float Distance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline");

	USplineComponent_GetWorldTangentAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36680
//		Name   -> Function Engine.SplineComponent.GetWorldRotationAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator USplineComponent::GetWorldRotationAtTime(float Time, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldRotationAtTime");

	USplineComponent_GetWorldRotationAtTime_Params params {};
	params.Time = Time;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B365D0
//		Name   -> Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator USplineComponent::GetWorldRotationAtDistanceAlongSpline(float Distance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline");

	USplineComponent_GetWorldRotationAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B364E0
//		Name   -> Function Engine.SplineComponent.GetWorldLocationAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetWorldLocationAtTime(float Time, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtTime");

	USplineComponent_GetWorldLocationAtTime_Params params {};
	params.Time = Time;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36430
//		Name   -> Function Engine.SplineComponent.GetWorldLocationAtSplinePoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetWorldLocationAtSplinePoint(int PointIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtSplinePoint");

	USplineComponent_GetWorldLocationAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36380
//		Name   -> Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetWorldLocationAtDistanceAlongSpline(float Distance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline");

	USplineComponent_GetWorldLocationAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36290
//		Name   -> Function Engine.SplineComponent.GetWorldDirectionAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldDirectionAtTime");

	USplineComponent_GetWorldDirectionAtTime_Params params {};
	params.Time = Time;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B361E0
//		Name   -> Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetWorldDirectionAtDistanceAlongSpline(float Distance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline");

	USplineComponent_GetWorldDirectionAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36080
//		Name   -> Function Engine.SplineComponent.GetUpVectorAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetUpVectorAtTime(float Time, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtTime");

	USplineComponent_GetUpVectorAtTime_Params params {};
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35FB0
//		Name   -> Function Engine.SplineComponent.GetUpVectorAtSplinePoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetUpVectorAtSplinePoint(int PointIndex, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtSplinePoint");

	USplineComponent_GetUpVectorAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35ED0
//		Name   -> Function Engine.SplineComponent.GetUpVectorAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetUpVectorAtDistanceAlongSpline(float Distance, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtDistanceAlongSpline");

	USplineComponent_GetUpVectorAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35D40
//		Name   -> Function Engine.SplineComponent.GetTransformAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUseScale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform USplineComponent::GetTransformAtTime(float Time, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity, bool bUseScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtTime");

	USplineComponent_GetTransformAtTime_Params params {};
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;
	params.bUseScale = bUseScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35C00
//		Name   -> Function Engine.SplineComponent.GetTransformAtSplinePoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseScale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform USplineComponent::GetTransformAtSplinePoint(int PointIndex, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtSplinePoint");

	USplineComponent_GetTransformAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseScale = bUseScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35AB0
//		Name   -> Function Engine.SplineComponent.GetTransformAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseScale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform USplineComponent::GetTransformAtDistanceAlongSpline(float Distance, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtDistanceAlongSpline");

	USplineComponent_GetTransformAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseScale = bUseScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35790
//		Name   -> Function Engine.SplineComponent.GetTangentAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetTangentAtTime(float Time, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtTime");

	USplineComponent_GetTangentAtTime_Params params {};
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B356C0
//		Name   -> Function Engine.SplineComponent.GetTangentAtSplinePoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetTangentAtSplinePoint(int PointIndex, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtSplinePoint");

	USplineComponent_GetTangentAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B355E0
//		Name   -> Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetTangentAtDistanceAlongSpline(float Distance, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline");

	USplineComponent_GetTangentAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35550
//		Name   -> Function Engine.SplineComponent.GetSplinePointType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplinePointType>               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
TEnumAsByte<Engine_ESplinePointType> USplineComponent::GetSplinePointType(int PointIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetSplinePointType");

	USplineComponent_GetSplinePointType_Params params {};
	params.PointIndex = PointIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35520
//		Name   -> Function Engine.SplineComponent.GetSplineLength
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USplineComponent::GetSplineLength()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetSplineLength");

	USplineComponent_GetSplineLength_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35370
//		Name   -> Function Engine.SplineComponent.GetScaleAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetScaleAtTime(float Time, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtTime");

	USplineComponent_GetScaleAtTime_Params params {};
	params.Time = Time;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B352D0
//		Name   -> Function Engine.SplineComponent.GetScaleAtSplinePoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetScaleAtSplinePoint(int PointIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtSplinePoint");

	USplineComponent_GetScaleAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35230
//		Name   -> Function Engine.SplineComponent.GetScaleAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetScaleAtDistanceAlongSpline(float Distance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtDistanceAlongSpline");

	USplineComponent_GetScaleAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35110
//		Name   -> Function Engine.SplineComponent.GetRotationAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator USplineComponent::GetRotationAtTime(float Time, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtTime");

	USplineComponent_GetRotationAtTime_Params params {};
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B35040
//		Name   -> Function Engine.SplineComponent.GetRotationAtSplinePoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator USplineComponent::GetRotationAtSplinePoint(int PointIndex, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtSplinePoint");

	USplineComponent_GetRotationAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34F60
//		Name   -> Function Engine.SplineComponent.GetRotationAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator USplineComponent::GetRotationAtDistanceAlongSpline(float Distance, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtDistanceAlongSpline");

	USplineComponent_GetRotationAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34E50
//		Name   -> Function Engine.SplineComponent.GetRollAtTime
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USplineComponent::GetRollAtTime(float Time, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtTime");

	USplineComponent_GetRollAtTime_Params params {};
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34D90
//		Name   -> Function Engine.SplineComponent.GetRollAtSplinePoint
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USplineComponent::GetRollAtSplinePoint(int PointIndex, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtSplinePoint");

	USplineComponent_GetRollAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34CC0
//		Name   -> Function Engine.SplineComponent.GetRollAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USplineComponent::GetRollAtDistanceAlongSpline(float Distance, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtDistanceAlongSpline");

	USplineComponent_GetRollAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34BA0
//		Name   -> Function Engine.SplineComponent.GetRightVectorAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetRightVectorAtTime(float Time, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtTime");

	USplineComponent_GetRightVectorAtTime_Params params {};
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34AD0
//		Name   -> Function Engine.SplineComponent.GetRightVectorAtSplinePoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetRightVectorAtSplinePoint(int PointIndex, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtSplinePoint");

	USplineComponent_GetRightVectorAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B349F0
//		Name   -> Function Engine.SplineComponent.GetRightVectorAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetRightVectorAtDistanceAlongSpline(float Distance, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtDistanceAlongSpline");

	USplineComponent_GetRightVectorAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34260
//		Name   -> Function Engine.SplineComponent.GetQuaternionAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FQuat                                       ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FQuat USplineComponent::GetQuaternionAtTime(float Time, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetQuaternionAtTime");

	USplineComponent_GetQuaternionAtTime_Params params {};
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34190
//		Name   -> Function Engine.SplineComponent.GetQuaternionAtSplinePoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FQuat                                       ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FQuat USplineComponent::GetQuaternionAtSplinePoint(int PointIndex, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetQuaternionAtSplinePoint");

	USplineComponent_GetQuaternionAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B340B0
//		Name   -> Function Engine.SplineComponent.GetQuaternionAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FQuat                                       ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FQuat USplineComponent::GetQuaternionAtDistanceAlongSpline(float Distance, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetQuaternionAtDistanceAlongSpline");

	USplineComponent_GetQuaternionAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33340
//		Name   -> Function Engine.SplineComponent.GetNumberOfSplinePoints
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int USplineComponent::GetNumberOfSplinePoints()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetNumberOfSplinePoints");

	USplineComponent_GetNumberOfSplinePoints_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32BA0
//		Name   -> Function Engine.SplineComponent.GetLocationAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetLocationAtTime(float Time, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtTime");

	USplineComponent_GetLocationAtTime_Params params {};
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32AD0
//		Name   -> Function Engine.SplineComponent.GetLocationAtSplinePoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetLocationAtSplinePoint(int PointIndex, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtSplinePoint");

	USplineComponent_GetLocationAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B329F0
//		Name   -> Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetLocationAtDistanceAlongSpline(float Distance, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline");

	USplineComponent_GetLocationAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32880
//		Name   -> Function Engine.SplineComponent.GetLocationAndTangentAtSplinePoint
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Tangent                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USplineComponent::GetLocationAndTangentAtSplinePoint(int PointIndex, struct FVector* Location, struct FVector* Tangent, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAndTangentAtSplinePoint");

	USplineComponent_GetLocationAndTangentAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Location != nullptr)
		*Location = params.Location;
	if (Tangent != nullptr)
		*Tangent = params.Tangent;

}


// Function:
//		Offset -> 0x02B32750
//		Name   -> Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     LocalLocation                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     LocalTangent                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineComponent::GetLocalLocationAndTangentAtSplinePoint(int PointIndex, struct FVector* LocalLocation, struct FVector* LocalTangent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint");

	USplineComponent_GetLocalLocationAndTangentAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (LocalLocation != nullptr)
		*LocalLocation = params.LocalLocation;
	if (LocalTangent != nullptr)
		*LocalTangent = params.LocalTangent;

}


// Function:
//		Offset -> 0x02B32580
//		Name   -> Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USplineComponent::GetInputKeyAtDistanceAlongSpline(float Distance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline");

	USplineComponent_GetInputKeyAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B323C0
//		Name   -> Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USplineComponent::GetDistanceAlongSplineAtSplinePoint(int PointIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint");

	USplineComponent_GetDistanceAlongSplineAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B322A0
//		Name   -> Function Engine.SplineComponent.GetDirectionAtTime
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetDirectionAtTime(float Time, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtTime");

	USplineComponent_GetDirectionAtTime_Params params {};
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B321D0
//		Name   -> Function Engine.SplineComponent.GetDirectionAtSplinePoint
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetDirectionAtSplinePoint(int PointIndex, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtSplinePoint");

	USplineComponent_GetDirectionAtSplinePoint_Params params {};
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B320F0
//		Name   -> Function Engine.SplineComponent.GetDirectionAtDistanceAlongSpline
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetDirectionAtDistanceAlongSpline(float Distance, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtDistanceAlongSpline");

	USplineComponent_GetDirectionAtDistanceAlongSpline_Params params {};
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32050
//		Name   -> Function Engine.SplineComponent.GetDefaultUpVector
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineComponent::GetDefaultUpVector(TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDefaultUpVector");

	USplineComponent_GetDefaultUpVector_Params params {};
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2EED0
//		Name   -> Function Engine.SplineComponent.ClearSplinePoints
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USplineComponent::ClearSplinePoints()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.ClearSplinePoints");

	USplineComponent_ClearSplinePoints_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2E670
//		Name   -> Function Engine.SplineComponent.AddSplineWorldPoint
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void USplineComponent::AddSplineWorldPoint(const struct FVector& Position)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplineWorldPoint");

	USplineComponent_AddSplineWorldPoint_Params params {};
	params.Position = Position;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2E590
//		Name   -> Function Engine.SplineComponent.AddSplinePoint
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ESplineCoordinateSpace>         CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USplineComponent::AddSplinePoint(const struct FVector& Position, TEnumAsByte<Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplinePoint");

	USplineComponent_AddSplinePoint_Params params {};
	params.Position = Position;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2E500
//		Name   -> Function Engine.SplineComponent.AddSplineLocalPoint
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void USplineComponent::AddSplineLocalPoint(const struct FVector& Position)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplineLocalPoint");

	USplineComponent_AddSplineLocalPoint_Params params {};
	params.Position = Position;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void USplineComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

}

void USplineComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

}

void UShapeComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

	READ_PTR_FULL(ShapeBodySetup, UBodySetup);
	READ_PTR_FULL(AreaClass, UClass);
}

void UShapeComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

	DELE_PTR_FULL(ShapeBodySetup);
	DELE_PTR_FULL(AreaClass);
}

// Function:
//		Offset -> 0x02C45F70
//		Name   -> Function Engine.CapsuleComponent.SetCapsuleSize
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InRadius                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InHalfHeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUpdateOverlaps                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCapsuleComponent::SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleSize");

	UCapsuleComponent_SetCapsuleSize_Params params {};
	params.InRadius = InRadius;
	params.InHalfHeight = InHalfHeight;
	params.bUpdateOverlaps = bUpdateOverlaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C45EA0
//		Name   -> Function Engine.CapsuleComponent.SetCapsuleRadius
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUpdateOverlaps                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCapsuleComponent::SetCapsuleRadius(float Radius, bool bUpdateOverlaps)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleRadius");

	UCapsuleComponent_SetCapsuleRadius_Params params {};
	params.Radius = Radius;
	params.bUpdateOverlaps = bUpdateOverlaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C45DD0
//		Name   -> Function Engine.CapsuleComponent.SetCapsuleHalfHeight
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUpdateOverlaps                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCapsuleComponent::SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleHalfHeight");

	UCapsuleComponent_SetCapsuleHalfHeight_Params params {};
	params.HalfHeight = HalfHeight;
	params.bUpdateOverlaps = bUpdateOverlaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40420
//		Name   -> Function Engine.CapsuleComponent.GetUnscaledCapsuleSize
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              OutRadius                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OutHalfHeight                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCapsuleComponent::GetUnscaledCapsuleSize(float* OutRadius, float* OutHalfHeight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleSize");

	UCapsuleComponent_GetUnscaledCapsuleSize_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutRadius != nullptr)
		*OutRadius = params.OutRadius;
	if (OutHalfHeight != nullptr)
		*OutHalfHeight = params.OutHalfHeight;

}


// Function:
//		Offset -> 0x02C40400
//		Name   -> Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCapsuleComponent::GetUnscaledCapsuleRadius()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius");

	UCapsuleComponent_GetUnscaledCapsuleRadius_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C403E0
//		Name   -> Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCapsuleComponent::GetUnscaledCapsuleHalfHeight()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight");

	UCapsuleComponent_GetUnscaledCapsuleHalfHeight_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FC00
//		Name   -> Function Engine.CapsuleComponent.GetShapeScale
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCapsuleComponent::GetShapeScale()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetShapeScale");

	UCapsuleComponent_GetShapeScale_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FAA0
//		Name   -> Function Engine.CapsuleComponent.GetScaledCapsuleSize
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              OutRadius                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OutHalfHeight                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCapsuleComponent::GetScaledCapsuleSize(float* OutRadius, float* OutHalfHeight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleSize");

	UCapsuleComponent_GetScaledCapsuleSize_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutRadius != nullptr)
		*OutRadius = params.OutRadius;
	if (OutHalfHeight != nullptr)
		*OutHalfHeight = params.OutHalfHeight;

}


// Function:
//		Offset -> 0x02C3FA50
//		Name   -> Function Engine.CapsuleComponent.GetScaledCapsuleRadius
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCapsuleComponent::GetScaledCapsuleRadius()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleRadius");

	UCapsuleComponent_GetScaledCapsuleRadius_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FA00
//		Name   -> Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCapsuleComponent::GetScaledCapsuleHalfHeight()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight");

	UCapsuleComponent_GetScaledCapsuleHalfHeight_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UCapsuleComponent::AfterRead()
{
	UShapeComponent::AfterRead();

}

void UCapsuleComponent::BeforeDelete()
{
	UShapeComponent::BeforeDelete();

}

void UTextureProxy::AfterRead()
{
	UTexture::AfterRead();

	READ_PTR_FULL(Texture, UTexture);
}

void UTextureProxy::BeforeDelete()
{
	UTexture::BeforeDelete();

	DELE_PTR_FULL(Texture);
}

void UCommandlet::AfterRead()
{
	UObject::AfterRead();

}

void UCommandlet::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D610
//		Name   -> Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform
//		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                InstanceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  NewInstanceTransform                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bWorldSpace                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bMarkRenderStateDirty                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UInstancedStaticMeshComponent::UpdateInstanceTransform(int InstanceIndex, const struct FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform");

	UInstancedStaticMeshComponent_UpdateInstanceTransform_Params params {};
	params.InstanceIndex = InstanceIndex;
	params.NewInstanceTransform = NewInstanceTransform;
	params.bWorldSpace = bWorldSpace;
	params.bMarkRenderStateDirty = bMarkRenderStateDirty;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C465A0
//		Name   -> Function Engine.InstancedStaticMeshComponent.SetCullDistances
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                StartCullDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                EndCullDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UInstancedStaticMeshComponent::SetCullDistances(int StartCullDistance, int EndCullDistance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.SetCullDistances");

	UInstancedStaticMeshComponent_SetCullDistances_Params params {};
	params.StartCullDistance = StartCullDistance;
	params.EndCullDistance = EndCullDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C436F0
//		Name   -> Function Engine.InstancedStaticMeshComponent.RemoveInstance
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                InstanceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UInstancedStaticMeshComponent::RemoveInstance(int InstanceIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.RemoveInstance");

	UInstancedStaticMeshComponent_RemoveInstance_Params params {};
	params.InstanceIndex = InstanceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3E160
//		Name   -> Function Engine.InstancedStaticMeshComponent.GetInstanceTransform
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                InstanceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  OutInstanceTransform                                       (Parm, OutParm, IsPlainOldData, NoDestructor)
//		bool                                               bWorldSpace                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UInstancedStaticMeshComponent::GetInstanceTransform(int InstanceIndex, struct FTransform* OutInstanceTransform, bool bWorldSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstanceTransform");

	UInstancedStaticMeshComponent_GetInstanceTransform_Params params {};
	params.InstanceIndex = InstanceIndex;
	params.bWorldSpace = bWorldSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutInstanceTransform != nullptr)
		*OutInstanceTransform = params.OutInstanceTransform;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3E510
//		Name   -> Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingSphere
//		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     Center                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSphereInWorldSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<int>                                        ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<int> UInstancedStaticMeshComponent::GetInstancesOverlappingSphere(const struct FVector& Center, float Radius, bool bSphereInWorldSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingSphere");

	UInstancedStaticMeshComponent_GetInstancesOverlappingSphere_Params params {};
	params.Center = Center;
	params.Radius = Radius;
	params.bSphereInWorldSpace = bSphereInWorldSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DFE0
//		Name   -> Function Engine.InstancedStaticMeshComponent.GetInstanceCount
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UInstancedStaticMeshComponent::GetInstanceCount()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstanceCount");

	UInstancedStaticMeshComponent_GetInstanceCount_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3B9E0
//		Name   -> Function Engine.InstancedStaticMeshComponent.EnableGPUVisibility
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UInstancedStaticMeshComponent::EnableGPUVisibility(bool bEnable)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.EnableGPUVisibility");

	UInstancedStaticMeshComponent_EnableGPUVisibility_Params params {};
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3A8B0
//		Name   -> Function Engine.InstancedStaticMeshComponent.ClearInstances
//		Flags  -> (Native, Public, BlueprintCallable)
void UInstancedStaticMeshComponent::ClearInstances()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.ClearInstances");

	UInstancedStaticMeshComponent_ClearInstances_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C37DD0
//		Name   -> Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  WorldTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UInstancedStaticMeshComponent::AddInstanceWorldSpace(const struct FTransform& WorldTransform)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace");

	UInstancedStaticMeshComponent_AddInstanceWorldSpace_Params params {};
	params.WorldTransform = WorldTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C37EC0
//		Name   -> Function Engine.InstancedStaticMeshComponent.AddInstances
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<struct FTransform>                          InstanceTransforms                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
void UInstancedStaticMeshComponent::AddInstances(TArray<struct FTransform> InstanceTransforms)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstances");

	UInstancedStaticMeshComponent_AddInstances_Params params {};
	params.InstanceTransforms = InstanceTransforms;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C37BE0
//		Name   -> Function Engine.InstancedStaticMeshComponent.AddInstance
//		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  InstanceTransform                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UInstancedStaticMeshComponent::AddInstance(const struct FTransform& InstanceTransform)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstance");

	UInstancedStaticMeshComponent_AddInstance_Params params {};
	params.InstanceTransform = InstanceTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UInstancedStaticMeshComponent::AfterRead()
{
	UStaticMeshComponent::AfterRead();

	READ_PTR_FULL(PhysicsSerializer, UPhysicsSerializer);
}

void UInstancedStaticMeshComponent::BeforeDelete()
{
	UStaticMeshComponent::BeforeDelete();

	DELE_PTR_FULL(PhysicsSerializer);
}

// Function:
//		Offset -> 0x02C43790
//		Name   -> Function Engine.HierarchicalInstancedStaticMeshComponent.RemoveInstances
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        InstancesToRemove                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UHierarchicalInstancedStaticMeshComponent::RemoveInstances(TArray<int> InstancesToRemove)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.HierarchicalInstancedStaticMeshComponent.RemoveInstances");

	UHierarchicalInstancedStaticMeshComponent_RemoveInstances_Params params {};
	params.InstancesToRemove = InstancesToRemove;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UHierarchicalInstancedStaticMeshComponent::AfterRead()
{
	UInstancedStaticMeshComponent::AfterRead();

}

void UHierarchicalInstancedStaticMeshComponent::BeforeDelete()
{
	UInstancedStaticMeshComponent::BeforeDelete();

}

void UMaterialInstance::AfterRead()
{
	UMaterialInterface::AfterRead();

	READ_PTR_FULL(PhysMaterial, UPhysicalMaterial);
	READ_PTR_FULL(Parent, UMaterialInterface);
}

void UMaterialInstance::BeforeDelete()
{
	UMaterialInterface::BeforeDelete();

	DELE_PTR_FULL(PhysMaterial);
	DELE_PTR_FULL(Parent);
}

void UMaterialInstanceConstant::AfterRead()
{
	UMaterialInstance::AfterRead();

}

void UMaterialInstanceConstant::BeforeDelete()
{
	UMaterialInstance::BeforeDelete();

}

void UMaterialExpression::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(Material, UMaterial);
	READ_PTR_FULL(Function, UMaterialFunction);
}

void UMaterialExpression::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(Material);
	DELE_PTR_FULL(Function);
}

void UMaterialExpressionCustomOutput::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionCustomOutput::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

// Function:
//		Offset -> 0x02C376E0
//		Name   -> Function Engine.BlueprintAsyncActionBase.Activate
//		Flags  -> (Native, Public, BlueprintCallable)
void UBlueprintAsyncActionBase::Activate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.BlueprintAsyncActionBase.Activate");

	UBlueprintAsyncActionBase_Activate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UBlueprintAsyncActionBase::AfterRead()
{
	UObject::AfterRead();

}

void UBlueprintAsyncActionBase::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UBlueprintGeneratedClass::AfterRead()
{
	UClass::AfterRead();

	READ_PTR_FULL(SimpleConstructionScript, USimpleConstructionScript);
	READ_PTR_FULL(InheritableComponentHandler, UInheritableComponentHandler);
	READ_PTR_FULL(UberGraphFramePointerProperty, UStructProperty);
	READ_PTR_FULL(UberGraphFunction, UFunction);
}

void UBlueprintGeneratedClass::BeforeDelete()
{
	UClass::BeforeDelete();

	DELE_PTR_FULL(SimpleConstructionScript);
	DELE_PTR_FULL(InheritableComponentHandler);
	DELE_PTR_FULL(UberGraphFramePointerProperty);
	DELE_PTR_FULL(UberGraphFunction);
}

void UAISystemBase::AfterRead()
{
	UObject::AfterRead();

}

void UAISystemBase::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UUserDefinedStruct::AfterRead()
{
	UScriptStruct::AfterRead();

}

void UUserDefinedStruct::BeforeDelete()
{
	UScriptStruct::BeforeDelete();

}

void UPlayer::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(PlayerController, APlayerController);
}

void UPlayer::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(PlayerController);
}

void UNetConnection::AfterRead()
{
	UPlayer::AfterRead();

	READ_PTR_FULL(Driver, UNetDriver);
	READ_PTR_FULL(PackageMap, UPackageMap);
	READ_PTR_FULL(ViewTarget, AActor);
	READ_PTR_FULL(OwningActor, AActor);
}

void UNetConnection::BeforeDelete()
{
	UPlayer::BeforeDelete();

	DELE_PTR_FULL(Driver);
	DELE_PTR_FULL(PackageMap);
	DELE_PTR_FULL(ViewTarget);
	DELE_PTR_FULL(OwningActor);
}

void UNetDriver::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(ServerConnection, UNetConnection);
	READ_PTR_FULL(World, UWorld);
	READ_PTR_FULL(NetConnectionClass, UClass);
	READ_PTR_FULL(RoleProperty, UProperty);
	READ_PTR_FULL(RemoteRoleProperty, UProperty);
}

void UNetDriver::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(ServerConnection);
	DELE_PTR_FULL(World);
	DELE_PTR_FULL(NetConnectionClass);
	DELE_PTR_FULL(RoleProperty);
	DELE_PTR_FULL(RemoteRoleProperty);
}

void UOnlineSession::AfterRead()
{
	UObject::AfterRead();

}

void UOnlineSession::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UModel::AfterRead()
{
	UObject::AfterRead();

}

void UModel::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UEdGraphNode::AfterRead()
{
	UObject::AfterRead();

}

void UEdGraphNode::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UEdGraphPin::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(DefaultObject, UObject);
	READ_PTR_FULL(ParentPin, UEdGraphPin);
}

void UEdGraphPin::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(DefaultObject);
	DELE_PTR_FULL(ParentPin);
}

void UEngineBaseTypes::AfterRead()
{
	UObject::AfterRead();

}

void UEngineBaseTypes::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UDamageType::AfterRead()
{
	UObject::AfterRead();

}

void UDamageType::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UEngineTypes::AfterRead()
{
	UObject::AfterRead();

}

void UEngineTypes::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UBlueprintCore::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(SkeletonGeneratedClass, UClass);
	READ_PTR_FULL(GeneratedClass, UClass);
}

void UBlueprintCore::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(SkeletonGeneratedClass);
	DELE_PTR_FULL(GeneratedClass);
}

void UBlueprint::AfterRead()
{
	UBlueprintCore::AfterRead();

	READ_PTR_FULL(ParentClass, UClass);
	READ_PTR_FULL(PRIVATE_InnermostPreviousCDO, UObject);
	READ_PTR_FULL(SimpleConstructionScript, USimpleConstructionScript);
	READ_PTR_FULL(InheritableComponentHandler, UInheritableComponentHandler);
}

void UBlueprint::BeforeDelete()
{
	UBlueprintCore::BeforeDelete();

	DELE_PTR_FULL(ParentClass);
	DELE_PTR_FULL(PRIVATE_InnermostPreviousCDO);
	DELE_PTR_FULL(SimpleConstructionScript);
	DELE_PTR_FULL(InheritableComponentHandler);
}

void UInterface_AssetUserData::AfterRead()
{
	UInterface::AfterRead();

}

void UInterface_AssetUserData::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UTestInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UTestInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UDerivedTestInterface::AfterRead()
{
	UTestInterface::AfterRead();

}

void UDerivedTestInterface::BeforeDelete()
{
	UTestInterface::BeforeDelete();

}

void UComponentWithDerivedTestInterface::AfterRead()
{
	UActorComponent::AfterRead();

}

void UComponentWithDerivedTestInterface::BeforeDelete()
{
	UActorComponent::BeforeDelete();

}

void AActorWithComponentWithDerivedTestInterface::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(ComponentWithDerivedTestInterface, UComponentWithDerivedTestInterface);
}

void AActorWithComponentWithDerivedTestInterface::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(ComponentWithDerivedTestInterface);
}

void AActorWithTestInterface::AfterRead()
{
	AActor::AfterRead();

}

void AActorWithTestInterface::BeforeDelete()
{
	AActor::BeforeDelete();

}

// Function:
//		Offset -> 0x02A3A8B0
//		Name   -> Function Engine.AmbientSound.Stop
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AAmbientSound::Stop()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.Stop");

	AAmbientSound_Stop_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A36640
//		Name   -> Function Engine.AmbientSound.Play
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AAmbientSound::Play(float StartTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.Play");

	AAmbientSound_Play_Params params {};
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2E290
//		Name   -> Function Engine.AmbientSound.FadeOut
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              FadeOutDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              FadeVolumeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AAmbientSound::FadeOut(float FadeOutDuration, float FadeVolumeLevel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.FadeOut");

	AAmbientSound_FadeOut_Params params {};
	params.FadeOutDuration = FadeOutDuration;
	params.FadeVolumeLevel = FadeVolumeLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2E1D0
//		Name   -> Function Engine.AmbientSound.FadeIn
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              FadeInDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              FadeVolumeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AAmbientSound::FadeIn(float FadeInDuration, float FadeVolumeLevel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.FadeIn");

	AAmbientSound_FadeIn_Params params {};
	params.FadeInDuration = FadeInDuration;
	params.FadeVolumeLevel = FadeVolumeLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2A9B0
//		Name   -> Function Engine.AmbientSound.AdjustVolume
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              AdjustVolumeDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              AdjustVolumeLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AAmbientSound::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.AdjustVolume");

	AAmbientSound_AdjustVolume_Params params {};
	params.AdjustVolumeDuration = AdjustVolumeDuration;
	params.AdjustVolumeLevel = AdjustVolumeLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void AAmbientSound::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(AudioComponent, UAudioComponent);
}

void AAmbientSound::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(AudioComponent);
}

void AAutomaticInstancingActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(DummyRoot, USceneComponent);
}

void AAutomaticInstancingActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(DummyRoot);
}

void UPendingNetGame::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(NetDriver, UNetDriver);
	READ_PTR_FULL(PreLoadedMapPackage, UPackage);
	READ_PTR_FULL(PreLoadedWorld, UWorld);
}

void UPendingNetGame::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(NetDriver);
	DELE_PTR_FULL(PreLoadedMapPackage);
	DELE_PTR_FULL(PreLoadedWorld);
}

void UWorld::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(PersistentLevel, ULevel);
	READ_PTR_FULL(NetDriver, UNetDriver);
	READ_PTR_FULL(LineBatcher, ULineBatchComponent);
	READ_PTR_FULL(PersistentLineBatcher, ULineBatchComponent);
	READ_PTR_FULL(ForegroundLineBatcher, ULineBatchComponent);
	READ_PTR_FULL(GameState, AGameState);
	READ_PTR_FULL(NetworkManager, AGameNetworkManager);
	READ_PTR_FULL(PhysicsCollisionHandler, UPhysicsCollisionHandler);
	READ_PTR_FULL(CurrentLevelPendingVisibility, ULevel);
	READ_PTR_FULL(MyParticleEventManager, AParticleEventManager);
	READ_PTR_FULL(DefaultPhysicsVolume, APhysicsVolume);
	READ_PTR_FULL(NavigationSystem, UNavigationSystem);
	READ_PTR_FULL(AuthorityGameMode, AGameMode);
	READ_PTR_FULL(AISystem, UAISystemBase);
	READ_PTR_FULL(AvoidanceManager, UAvoidanceManager);
	READ_PTR_FULL(CurrentLevel, ULevel);
	READ_PTR_FULL(OwningGameInstance, UGameInstance);
	READ_PTR_FULL(WorldComposition, UWorldComposition);
}

void UWorld::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(PersistentLevel);
	DELE_PTR_FULL(NetDriver);
	DELE_PTR_FULL(LineBatcher);
	DELE_PTR_FULL(PersistentLineBatcher);
	DELE_PTR_FULL(ForegroundLineBatcher);
	DELE_PTR_FULL(GameState);
	DELE_PTR_FULL(NetworkManager);
	DELE_PTR_FULL(PhysicsCollisionHandler);
	DELE_PTR_FULL(CurrentLevelPendingVisibility);
	DELE_PTR_FULL(MyParticleEventManager);
	DELE_PTR_FULL(DefaultPhysicsVolume);
	DELE_PTR_FULL(NavigationSystem);
	DELE_PTR_FULL(AuthorityGameMode);
	DELE_PTR_FULL(AISystem);
	DELE_PTR_FULL(AvoidanceManager);
	DELE_PTR_FULL(CurrentLevel);
	DELE_PTR_FULL(OwningGameInstance);
	DELE_PTR_FULL(WorldComposition);
}

void ULevel::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(ActorCluster, ULevelActorContainer);
	READ_PTR_FULL(OwningWorld, UWorld);
	READ_PTR_FULL(Model, UModel);
	READ_PTR_FULL(LevelScriptActor, ALevelScriptActor);
	READ_PTR_FULL(NavListStart, ANavigationObjectBase);
	READ_PTR_FULL(NavListEnd, ANavigationObjectBase);
}

void ULevel::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(ActorCluster);
	DELE_PTR_FULL(OwningWorld);
	DELE_PTR_FULL(Model);
	DELE_PTR_FULL(LevelScriptActor);
	DELE_PTR_FULL(NavListStart);
	DELE_PTR_FULL(NavListEnd);
}

void ABrushShape::AfterRead()
{
	ABrush::AfterRead();

}

void ABrushShape::BeforeDelete()
{
	ABrush::BeforeDelete();

}

void AAudioVolume::AfterRead()
{
	AVolume::AfterRead();

	READ_PTR_FULL(NextLowerPriorityVolume, AAudioVolume);
}

void AAudioVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

	DELE_PTR_FULL(NextLowerPriorityVolume);
}

void ACameraBlockingVolume::AfterRead()
{
	AVolume::AfterRead();

}

void ACameraBlockingVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

void ACullDistanceVolume::AfterRead()
{
	AVolume::AfterRead();

}

void ACullDistanceVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

// Function:
//		Offset -> 0x02A3AF90
//		Name   -> Function Engine.FFTWater.ValidateVertexBuffer
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AFFTWater::ValidateVertexBuffer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.ValidateVertexBuffer");

	AFFTWater_ValidateVertexBuffer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A3AF60
//		Name   -> Function Engine.FFTWater.ValidateParticlesVelocity
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AFFTWater::ValidateParticlesVelocity()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.ValidateParticlesVelocity");

	AFFTWater_ValidateParticlesVelocity_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A3AF30
//		Name   -> Function Engine.FFTWater.ValidateIndexBuffer
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AFFTWater::ValidateIndexBuffer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.ValidateIndexBuffer");

	AFFTWater_ValidateIndexBuffer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A3A330
//		Name   -> Function Engine.FFTWater.SetWireframe
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bWireframe                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AFFTWater::SetWireframe(bool bWireframe)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetWireframe");

	AFFTWater_SetWireframe_Params params {};
	params.bWireframe = bWireframe;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A2B0
//		Name   -> Function Engine.FFTWater.SetWaterColour
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                WaterColour                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AFFTWater::SetWaterColour(const struct FLinearColor& WaterColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetWaterColour");

	AFFTWater_SetWaterColour_Params params {};
	params.WaterColour = WaterColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39D30
//		Name   -> Function Engine.FFTWater.SetSpecularBrightness
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              SpecularBrightness                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AFFTWater::SetSpecularBrightness(float SpecularBrightness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetSpecularBrightness");

	AFFTWater_SetSpecularBrightness_Params params {};
	params.SpecularBrightness = SpecularBrightness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39CB0
//		Name   -> Function Engine.FFTWater.SetShallowWaterColour
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                ShallowWaterColour                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AFFTWater::SetShallowWaterColour(const struct FLinearColor& ShallowWaterColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetShallowWaterColour");

	AFFTWater_SetShallowWaterColour_Params params {};
	params.ShallowWaterColour = ShallowWaterColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39A80
//		Name   -> Function Engine.FFTWater.SetReflectionBrightness
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              ReflectionBrightness                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AFFTWater::SetReflectionBrightness(float ReflectionBrightness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetReflectionBrightness");

	AFFTWater_SetReflectionBrightness_Params params {};
	params.ReflectionBrightness = ReflectionBrightness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A397B0
//		Name   -> Function Engine.FFTWater.SetLightFunctionMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AFFTWater::SetLightFunctionMaterial(class UMaterialInterface* Material)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetLightFunctionMaterial");

	AFFTWater_SetLightFunctionMaterial_Params params {};
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A391A0
//		Name   -> Function Engine.FFTWater.SetFresnelPower
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              FresnelPower                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AFFTWater::SetFresnelPower(float FresnelPower)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetFresnelPower");

	AFFTWater_SetFresnelPower_Params params {};
	params.FresnelPower = FresnelPower;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39120
//		Name   -> Function Engine.FFTWater.SetFoamHighlightColour
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                FoamHighlightColour                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AFFTWater::SetFoamHighlightColour(const struct FLinearColor& FoamHighlightColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetFoamHighlightColour");

	AFFTWater_SetFoamHighlightColour_Params params {};
	params.FoamHighlightColour = FoamHighlightColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A390A0
//		Name   -> Function Engine.FFTWater.SetFoamColour
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                FoamColour                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AFFTWater::SetFoamColour(const struct FLinearColor& FoamColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetFoamColour");

	AFFTWater_SetFoamColour_Params params {};
	params.FoamColour = FoamColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39020
//		Name   -> Function Engine.FFTWater.SetFoamBrightness
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              FoamBrightness                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AFFTWater::SetFoamBrightness(float FoamBrightness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetFoamBrightness");

	AFFTWater_SetFoamBrightness_Params params {};
	params.FoamBrightness = FoamBrightness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38CC0
//		Name   -> Function Engine.FFTWater.SetCausticsDepth
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Depth                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AFFTWater::SetCausticsDepth(float Depth)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetCausticsDepth");

	AFFTWater_SetCausticsDepth_Params params {};
	params.Depth = Depth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38C40
//		Name   -> Function Engine.FFTWater.SetBackLitColour
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                BackLitColour                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AFFTWater::SetBackLitColour(const struct FLinearColor& BackLitColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetBackLitColour");

	AFFTWater_SetBackLitColour_Params params {};
	params.BackLitColour = BackLitColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A38A20
//		Name   -> Function Engine.FFTWater.SetAmbientColour
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                AmbientColour                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AFFTWater::SetAmbientColour(const struct FLinearColor& AmbientColour)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.SetAmbientColour");

	AFFTWater_SetAmbientColour_Params params {};
	params.AmbientColour = AmbientColour;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A31E50
//		Name   -> Function Engine.FFTWater.HasLightFunctionMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AFFTWater::HasLightFunctionMaterial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.HasLightFunctionMaterial");

	AFFTWater_HasLightFunctionMaterial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2EBF0
//		Name   -> Function Engine.FFTWater.GetComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UFFTWaterComponent*                          ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UFFTWaterComponent* AFFTWater::GetComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWater.GetComponent");

	AFFTWater_GetComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void AFFTWater::AfterRead()
{
	AVolume::AfterRead();

	READ_PTR_FULL(FFTWaterComponent, UFFTWaterComponent);
	READ_PTR_FULL(ExtendedPlaneComponent, UFFTWaterExtendedPlaneComponent);
}

void AFFTWater::BeforeDelete()
{
	AVolume::BeforeDelete();

	DELE_PTR_FULL(FFTWaterComponent);
	DELE_PTR_FULL(ExtendedPlaneComponent);
}

void ALevelStreamingVolume::AfterRead()
{
	AVolume::AfterRead();

}

void ALevelStreamingVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

void ALightmassCharacterIndirectDetailVolume::AfterRead()
{
	AVolume::AfterRead();

}

void ALightmassCharacterIndirectDetailVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

void ALightmassImportanceVolume::AfterRead()
{
	AVolume::AfterRead();

}

void ALightmassImportanceVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

void UNavigationTypes::AfterRead()
{
	UObject::AfterRead();

}

void UNavigationTypes::BeforeDelete()
{
	UObject::BeforeDelete();

}

void ANavMeshBoundsVolume::AfterRead()
{
	AVolume::AfterRead();

}

void ANavMeshBoundsVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

void AInstancedNavMeshBoundsVolume::AfterRead()
{
	ANavMeshBoundsVolume::AfterRead();

}

void AInstancedNavMeshBoundsVolume::BeforeDelete()
{
	ANavMeshBoundsVolume::BeforeDelete();

}

void UNavArea::AfterRead()
{
	UObject::AfterRead();

}

void UNavArea::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UNavRelevantInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UNavRelevantInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

// Function:
//		Offset -> 0x02A38AA0
//		Name   -> Function Engine.NavModifierVolume.SetAreaClass
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      NewAreaClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void ANavModifierVolume::SetAreaClass(class UClass* NewAreaClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavModifierVolume.SetAreaClass");

	ANavModifierVolume_SetAreaClass_Params params {};
	params.NewAreaClass = NewAreaClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ANavModifierVolume::AfterRead()
{
	AVolume::AfterRead();

	READ_PTR_FULL(AreaClass, UClass);
}

void ANavModifierVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

	DELE_PTR_FULL(AreaClass);
}

void ADefaultPhysicsVolume::AfterRead()
{
	APhysicsVolume::AfterRead();

}

void ADefaultPhysicsVolume::BeforeDelete()
{
	APhysicsVolume::BeforeDelete();

}

void AKillZVolume::AfterRead()
{
	APhysicsVolume::AfterRead();

}

void AKillZVolume::BeforeDelete()
{
	APhysicsVolume::BeforeDelete();

}

void APainCausingVolume::AfterRead()
{
	APhysicsVolume::AfterRead();

	READ_PTR_FULL(DamageType, UClass);
	READ_PTR_FULL(DamageInstigator, AController);
}

void APainCausingVolume::BeforeDelete()
{
	APhysicsVolume::BeforeDelete();

	DELE_PTR_FULL(DamageType);
	DELE_PTR_FULL(DamageInstigator);
}

void UBlendableInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UBlendableInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UScene::AfterRead()
{
	UObject::AfterRead();

}

void UScene::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UInterface_PostProcessVolume::AfterRead()
{
	UInterface::AfterRead();

}

void UInterface_PostProcessVolume::BeforeDelete()
{
	UInterface::BeforeDelete();

}

// Function:
//		Offset -> 0x02A2A460
//		Name   -> Function Engine.PostProcessVolume.AddOrUpdateBlendable
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InWeight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APostProcessVolume::AddOrUpdateBlendable(float InWeight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PostProcessVolume.AddOrUpdateBlendable");

	APostProcessVolume_AddOrUpdateBlendable_Params params {};
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void APostProcessVolume::AfterRead()
{
	AVolume::AfterRead();

}

void APostProcessVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

void APrecomputedVisibilityOverrideVolume::AfterRead()
{
	AVolume::AfterRead();

}

void APrecomputedVisibilityOverrideVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

void APrecomputedVisibilityVolume::AfterRead()
{
	AVolume::AfterRead();

}

void APrecomputedVisibilityVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

void ATriggerVolume::AfterRead()
{
	AVolume::AfterRead();

}

void ATriggerVolume::BeforeDelete()
{
	AVolume::BeforeDelete();

}

void ACalmWaterZone::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(CalmWaterComponent, UCalmWaterComponent);
}

void ACalmWaterZone::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(CalmWaterComponent);
}

// Function:
//		Offset -> 0x02A2E9B0
//		Name   -> Function Engine.CameraActor.GetAutoActivatePlayerIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int ACameraActor::GetAutoActivatePlayerIndex()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraActor.GetAutoActivatePlayerIndex");

	ACameraActor_GetAutoActivatePlayerIndex_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void ACameraActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(CameraComponent, UCameraComponent);
}

void ACameraActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(CameraComponent);
}

void AClientOnlyTestActor::AfterRead()
{
	AActor::AfterRead();

}

void AClientOnlyTestActor::BeforeDelete()
{
	AActor::BeforeDelete();

}

void UNavAgentInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UNavAgentInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.CameraShake.ReceiveStopShake
//		Flags  -> (Event, Public, BlueprintEvent)
void UCameraShake::ReceiveStopShake()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.ReceiveStopShake");

	UCameraShake_ReceiveStopShake_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.CameraShake.ReceivePlayShake
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCameraShake::ReceivePlayShake(float Scale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.ReceivePlayShake");

	UCameraShake_ReceivePlayShake_Params params {};
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A37320
//		Name   -> Function Engine.CameraShake.ReceiveIsFinished
//		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UCameraShake::ReceiveIsFinished()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.ReceiveIsFinished");

	UCameraShake_ReceiveIsFinished_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.CameraShake.BlueprintUpdateCameraShake
//		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FMinimalViewInfo                            POV                                                        (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FMinimalViewInfo                            ModifiedPOV                                                (Parm, OutParm)
void UCameraShake::BlueprintUpdateCameraShake(float DeltaTime, float Alpha, const struct FMinimalViewInfo& POV, struct FMinimalViewInfo* ModifiedPOV)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.BlueprintUpdateCameraShake");

	UCameraShake_BlueprintUpdateCameraShake_Params params {};
	params.DeltaTime = DeltaTime;
	params.Alpha = Alpha;
	params.POV = POV;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (ModifiedPOV != nullptr)
		*ModifiedPOV = params.ModifiedPOV;

}


void UCameraShake::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(Anim, UCameraAnim);
	READ_PTR_FULL(CameraOwner, APlayerCameraManager);
	READ_PTR_FULL(AnimInst, UCameraAnimInst);
}

void UCameraShake::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(Anim);
	DELE_PTR_FULL(CameraOwner);
	DELE_PTR_FULL(AnimInst);
}

// Function:
//		Offset -> 0x02A3ABD0
//		Name   -> Function Engine.PlayerCameraManager.StopCameraShake
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UCameraShake*                                ShakeInstance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerCameraManager::StopCameraShake(class UCameraShake* ShakeInstance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraShake");

	APlayerCameraManager_StopCameraShake_Params params {};
	params.ShakeInstance = ShakeInstance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3ABB0
//		Name   -> Function Engine.PlayerCameraManager.StopCameraFade
//		Flags  -> (Native, Public, BlueprintCallable)
void APlayerCameraManager::StopCameraFade()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraFade");

	APlayerCameraManager_StopCameraFade_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3AAE0
//		Name   -> Function Engine.PlayerCameraManager.StopCameraAnimInst
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UCameraAnimInst*                             AnimInst                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerCameraManager::StopCameraAnimInst(class UCameraAnimInst* AnimInst, bool bImmediate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraAnimInst");

	APlayerCameraManager_StopCameraAnimInst_Params params {};
	params.AnimInst = AnimInst;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3AA50
//		Name   -> Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShake
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      Shake                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void APlayerCameraManager::StopAllInstancesOfCameraShake(class UClass* Shake)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShake");

	APlayerCameraManager_StopAllInstancesOfCameraShake_Params params {};
	params.Shake = Shake;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A980
//		Name   -> Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UCameraAnim*                                 Anim                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerCameraManager::StopAllInstancesOfCameraAnim(class UCameraAnim* Anim, bool bImmediate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim");

	APlayerCameraManager_StopAllInstancesOfCameraAnim_Params params {};
	params.Anim = Anim;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A960
//		Name   -> Function Engine.PlayerCameraManager.StopAllCameraShakes
//		Flags  -> (Native, Public, BlueprintCallable)
void APlayerCameraManager::StopAllCameraShakes()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllCameraShakes");

	APlayerCameraManager_StopAllCameraShakes_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A8D0
//		Name   -> Function Engine.PlayerCameraManager.StopAllCameraAnims
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerCameraManager::StopAllCameraAnims(bool bImmediate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllCameraAnims");

	APlayerCameraManager_StopAllCameraAnims_Params params {};
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A3A660
//		Name   -> Function Engine.PlayerCameraManager.StartCameraFade
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		float                                              FromAlpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ToAlpha                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                Color                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bShouldFadeAudio                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bHoldWhenFinished                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerCameraManager::StartCameraFade(float FromAlpha, float ToAlpha, float Duration, const struct FLinearColor& Color, bool bShouldFadeAudio, bool bHoldWhenFinished)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StartCameraFade");

	APlayerCameraManager_StartCameraFade_Params params {};
	params.FromAlpha = FromAlpha;
	params.ToAlpha = ToAlpha;
	params.Duration = Duration;
	params.Color = Color;
	params.bShouldFadeAudio = bShouldFadeAudio;
	params.bHoldWhenFinished = bHoldWhenFinished;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A39830
//		Name   -> Function Engine.PlayerCameraManager.SetManualCameraFade
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		float                                              InFadeAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                Color                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bInFadeAudio                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void APlayerCameraManager::SetManualCameraFade(float InFadeAmount, const struct FLinearColor& Color, bool bInFadeAudio)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.SetManualCameraFade");

	APlayerCameraManager_SetManualCameraFade_Params params {};
	params.InFadeAmount = InFadeAmount;
	params.Color = Color;
	params.bInFadeAudio = bInFadeAudio;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A373E0
//		Name   -> Function Engine.PlayerCameraManager.RemoveCameraModifier
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UCameraModifier*                             ModifierToRemove                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerCameraManager::RemoveCameraModifier(class UCameraModifier* ModifierToRemove)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.RemoveCameraModifier");

	APlayerCameraManager_RemoveCameraModifier_Params params {};
	params.ModifierToRemove = ModifierToRemove;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A37350
//		Name   -> Function Engine.PlayerCameraManager.RemoveCameraLensEffect
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class AEmitterCameraLensEffectBase*                Emitter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APlayerCameraManager::RemoveCameraLensEffect(class AEmitterCameraLensEffectBase* Emitter)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.RemoveCameraLensEffect");

	APlayerCameraManager_RemoveCameraLensEffect_Params params {};
	params.Emitter = Emitter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A369E0
//		Name   -> Function Engine.PlayerCameraManager.PlayCameraShake
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UClass*                                      ShakeClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECameraAnimPlaySpace>           PlaySpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    UserPlaySpaceRot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UCameraShake*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UCameraShake* APlayerCameraManager::PlayCameraShake(class UClass* ShakeClass, float Scale, TEnumAsByte<Engine_ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.PlayCameraShake");

	APlayerCameraManager_PlayCameraShake_Params params {};
	params.ShakeClass = ShakeClass;
	params.Scale = Scale;
	params.PlaySpace = PlaySpace;
	params.UserPlaySpaceRot = UserPlaySpaceRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A366C0
//		Name   -> Function Engine.PlayerCameraManager.PlayCameraAnim
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UCameraAnim*                                 Anim                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendInTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendOutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bRandomStartTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECameraAnimPlaySpace>           PlaySpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    UserPlaySpaceRot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UCurveFloat*                                 BlendInCurve                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UCameraAnimInst*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UCameraAnimInst* APlayerCameraManager::PlayCameraAnim(class UCameraAnim* Anim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, TEnumAsByte<Engine_ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot, class UCurveFloat* BlendInCurve)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.PlayCameraAnim");

	APlayerCameraManager_PlayCameraAnim_Params params {};
	params.Anim = Anim;
	params.Rate = Rate;
	params.Scale = Scale;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bLoop = bLoop;
	params.bRandomStartTime = bRandomStartTime;
	params.Duration = Duration;
	params.PlaySpace = PlaySpace;
	params.UserPlaySpaceRot = UserPlaySpaceRot;
	params.BlendInCurve = BlendInCurve;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A323B0
//		Name   -> Function Engine.PlayerCameraManager.IsScreenFullyOccluded
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerCameraManager::IsScreenFullyOccluded()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.IsScreenFullyOccluded");

	APlayerCameraManager_IsScreenFullyOccluded_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A32100
//		Name   -> Function Engine.PlayerCameraManager.IsFadeInProgress
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerCameraManager::IsFadeInProgress()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.IsFadeInProgress");

	APlayerCameraManager_IsFadeInProgress_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A312C0
//		Name   -> Function Engine.PlayerCameraManager.GetOwningPlayerController
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APlayerController*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APlayerController* APlayerCameraManager::GetOwningPlayerController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetOwningPlayerController");

	APlayerCameraManager_GetOwningPlayerController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2F770
//		Name   -> Function Engine.PlayerCameraManager.GetFOVAngle
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float APlayerCameraManager::GetFOVAngle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetFOVAngle");

	APlayerCameraManager_GetFOVAngle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2EA20
//		Name   -> Function Engine.PlayerCameraManager.GetCameraRotation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator APlayerCameraManager::GetCameraRotation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetCameraRotation");

	APlayerCameraManager_GetCameraRotation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E9E0
//		Name   -> Function Engine.PlayerCameraManager.GetCameraLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector APlayerCameraManager::GetCameraLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetCameraLocation");

	APlayerCameraManager_GetCameraLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2E350
//		Name   -> Function Engine.PlayerCameraManager.FindCameraModifierByClass
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      ModifierClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class UCameraModifier*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UCameraModifier* APlayerCameraManager::FindCameraModifierByClass(class UClass* ModifierClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.FindCameraModifierByClass");

	APlayerCameraManager_FindCameraModifierByClass_Params params {};
	params.ModifierClass = ModifierClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2AE40
//		Name   -> Function Engine.PlayerCameraManager.ClearCameraLensEffects
//		Flags  -> (Native, Public, BlueprintCallable)
void APlayerCameraManager::ClearCameraLensEffects()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.ClearCameraLensEffects");

	APlayerCameraManager_ClearCameraLensEffects_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.PlayerCameraManager.BlueprintUpdateCamera
//		Flags  -> (BlueprintCosmetic, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
//		class AActor*                                      CameraTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NewCameraLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    NewCameraRotation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              NewCameraFOV                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool APlayerCameraManager::BlueprintUpdateCamera(class AActor* CameraTarget, struct FVector* NewCameraLocation, struct FRotator* NewCameraRotation, float* NewCameraFOV)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.BlueprintUpdateCamera");

	APlayerCameraManager_BlueprintUpdateCamera_Params params {};
	params.CameraTarget = CameraTarget;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (NewCameraLocation != nullptr)
		*NewCameraLocation = params.NewCameraLocation;
	if (NewCameraRotation != nullptr)
		*NewCameraRotation = params.NewCameraRotation;
	if (NewCameraFOV != nullptr)
		*NewCameraFOV = params.NewCameraFOV;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2ACD0
//		Name   -> Function Engine.PlayerCameraManager.BlendOutAllInstancesOfCameraShake
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      Shake                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void APlayerCameraManager::BlendOutAllInstancesOfCameraShake(class UClass* Shake)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.BlendOutAllInstancesOfCameraShake");

	APlayerCameraManager_BlendOutAllInstancesOfCameraShake_Params params {};
	params.Shake = Shake;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02A2A3C0
//		Name   -> Function Engine.PlayerCameraManager.AddNewCameraModifier
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      ModifierClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class UCameraModifier*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UCameraModifier* APlayerCameraManager::AddNewCameraModifier(class UClass* ModifierClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.AddNewCameraModifier");

	APlayerCameraManager_AddNewCameraModifier_Params params {};
	params.ModifierClass = ModifierClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02A2A150
//		Name   -> Function Engine.PlayerCameraManager.AddCameraLensEffect
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      LensEffectEmitterClass                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class AEmitterCameraLensEffectBase*                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AEmitterCameraLensEffectBase* APlayerCameraManager::AddCameraLensEffect(class UClass* LensEffectEmitterClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.AddCameraLensEffect");

	APlayerCameraManager_AddCameraLensEffect_Params params {};
	params.LensEffectEmitterClass = LensEffectEmitterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void APlayerCameraManager::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(PCOwner, APlayerController);
	READ_PTR_FULL(TransformComponent, USceneComponent);
	READ_PTR_FULL(CachedCameraShakeMod, UCameraModifier_CameraShake);
	READ_PTR_FULL(AnimInstPool[0x8], UCameraAnimInst);
	READ_PTR_FULL(AnimCameraActor, ACameraActor);
}

void APlayerCameraManager::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(PCOwner);
	DELE_PTR_FULL(TransformComponent);
	DELE_PTR_FULL(CachedCameraShakeMod);
	DELE_PTR_FULL(AnimInstPool[0x8]);
	DELE_PTR_FULL(AnimCameraActor);
}

// Function:
//		Offset -> 0x02A31B50
//		Name   -> Function Engine.CurveBase.GetValueRange
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              MinValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MaxValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCurveBase::GetValueRange(float* MinValue, float* MaxValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CurveBase.GetValueRange");

	UCurveBase_GetValueRange_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (MinValue != nullptr)
		*MinValue = params.MinValue;
	if (MaxValue != nullptr)
		*MaxValue = params.MaxValue;

}


// Function:
//		Offset -> 0x02A31850
//		Name   -> Function Engine.CurveBase.GetTimeRange
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              MinTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MaxTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCurveBase::GetTimeRange(float* MinTime, float* MaxTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CurveBase.GetTimeRange");

	UCurveBase_GetTimeRange_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (MinTime != nullptr)
		*MinTime = params.MinTime;
	if (MaxTime != nullptr)
		*MaxTime = params.MaxTime;

}


void UCurveBase::AfterRead()
{
	UObject::AfterRead();

}

void UCurveBase::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UAnimBlueprint::AfterRead()
{
	UBlueprint::AfterRead();

	READ_PTR_FULL(TargetSkeleton, USkeleton);
}

void UAnimBlueprint::BeforeDelete()
{
	UBlueprint::BeforeDelete();

	DELE_PTR_FULL(TargetSkeleton);
}

void ULevelScriptBlueprint::AfterRead()
{
	UBlueprint::AfterRead();

}

void ULevelScriptBlueprint::BeforeDelete()
{
	UBlueprint::BeforeDelete();

}

void UDataTable::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(RowStruct, UScriptStruct);
}

void UDataTable::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(RowStruct);
}

// Function:
//		Offset -> 0x02C3D7F0
//		Name   -> Function Engine.DataTableFunctionLibrary.GetDataTableRowNames
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UDataTable*                                  Table                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FName>                               OutRowNames                                                (Parm, OutParm, ZeroConstructor)
void UDataTableFunctionLibrary::STATIC_GetDataTableRowNames(class UDataTable* Table, TArray<struct FName>* OutRowNames)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableRowNames");

	UDataTableFunctionLibrary_GetDataTableRowNames_Params params {};
	params.Table = Table;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutRowNames != nullptr)
		*OutRowNames = params.OutRowNames;

}


// Function:
//		Offset -> 0x02C3D6F0
//		Name   -> Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UDataTable*                                  Table                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       RowName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTableRowBase                               OutRow                                                     (Parm, OutParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UDataTableFunctionLibrary::STATIC_GetDataTableRowFromName(class UDataTable* Table, const struct FName& RowName, struct FTableRowBase* OutRow)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName");

	UDataTableFunctionLibrary_GetDataTableRowFromName_Params params {};
	params.Table = Table;
	params.RowName = RowName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutRow != nullptr)
		*OutRow = params.OutRow;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3BAE0
//		Name   -> Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UCurveTable*                                 CurveTable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       RowName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InXY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EEvaluateCurveTableResult>      OutResult                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OutXY                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDataTableFunctionLibrary::STATIC_EvaluateCurveTableRow(class UCurveTable* CurveTable, const struct FName& RowName, float InXY, TEnumAsByte<Engine_EEvaluateCurveTableResult>* OutResult, float* OutXY)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow");

	UDataTableFunctionLibrary_EvaluateCurveTableRow_Params params {};
	params.CurveTable = CurveTable;
	params.RowName = RowName;
	params.InXY = InXY;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutResult != nullptr)
		*OutResult = params.OutResult;
	if (OutXY != nullptr)
		*OutXY = params.OutXY;

}


void UDataTableFunctionLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UDataTableFunctionLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

void UDebugDrawService::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UDebugDrawService::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02C392D0
//		Name   -> Function Engine.DeformablesBlueprintFunctionLibrary.ApplyWorldForceToDeformables
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class USkinnedMeshComponent*                       SkinnedMeshComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     WorldSpaceForce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UDeformablesBlueprintFunctionLibrary::STATIC_ApplyWorldForceToDeformables(class USkinnedMeshComponent* SkinnedMeshComp, const struct FVector& WorldSpaceForce)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DeformablesBlueprintFunctionLibrary.ApplyWorldForceToDeformables");

	UDeformablesBlueprintFunctionLibrary_ApplyWorldForceToDeformables_Params params {};
	params.SkinnedMeshComp = SkinnedMeshComp;
	params.WorldSpaceForce = WorldSpaceForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UDeformablesBlueprintFunctionLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UDeformablesBlueprintFunctionLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02C40BF0
//		Name   -> Function Engine.FeatureConfigBlueprintFunctionLibrary.IsFeatureEnabled
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       FeatureName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UFeatureConfigBlueprintFunctionLibrary::STATIC_IsFeatureEnabled(const struct FName& FeatureName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FeatureConfigBlueprintFunctionLibrary.IsFeatureEnabled");

	UFeatureConfigBlueprintFunctionLibrary_IsFeatureEnabled_Params params {};
	params.FeatureName = FeatureName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UFeatureConfigBlueprintFunctionLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UFeatureConfigBlueprintFunctionLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

void UDialogueTypes::AfterRead()
{
	UObject::AfterRead();

}

void UDialogueTypes::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D320
//		Name   -> Function Engine.GameplayStatics.UnloadStreamLevel
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
void UGameplayStatics::STATIC_UnloadStreamLevel(class UObject* WorldContextObject, const struct FName& LevelName, const struct FLatentActionInfo& LatentInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.UnloadStreamLevel");

	UGameplayStatics_UnloadStreamLevel_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.LevelName = LevelName;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4CD20
//		Name   -> Function Engine.GameplayStatics.SpawnSoundAttached
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USceneComponent*                             AttachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		TEnumAsByte<Engine_EAttachLocation>                LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		bool                                               bStopWhenAttachedToDestroyed                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class UAudioComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UAudioComponent* UGameplayStatics::STATIC_SpawnSoundAttached(class USoundBase* Sound, class USceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<Engine_EAttachLocation> LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSoundAttached");

	UGameplayStatics_SpawnSoundAttached_Params params {};
	params.Sound = Sound;
	params.AttachToComponent = AttachToComponent;
	params.AttachPointName = AttachPointName;
	params.Location = Location;
	params.Rotation = Rotation;
	params.LocationType = LocationType;
	params.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4CAD0
//		Name   -> Function Engine.GameplayStatics.SpawnSoundAtLocation
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class UAudioComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UAudioComponent* UGameplayStatics::STATIC_SpawnSoundAtLocation(class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSoundAtLocation");

	UGameplayStatics_SpawnSoundAtLocation_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Sound = Sound;
	params.Location = Location;
	params.Rotation = Rotation;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4C950
//		Name   -> Function Engine.GameplayStatics.SpawnSound2D
//		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class UAudioComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UAudioComponent* UGameplayStatics::STATIC_SpawnSound2D(class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSound2D");

	UGameplayStatics_SpawnSound2D_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Sound = Sound;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4C890
//		Name   -> Function Engine.GameplayStatics.SpawnObject
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      ObjectClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class UObject*                                     Outer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UObject*                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UObject* UGameplayStatics::STATIC_SpawnObject(class UClass* ObjectClass, class UObject* Outer)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnObject");

	UGameplayStatics_SpawnObject_Params params {};
	params.ObjectClass = ObjectClass;
	params.Outer = Outer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4C680
//		Name   -> Function Engine.GameplayStatics.SpawnEmitterAttached
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UParticleSystem*                             EmitterTemplate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USceneComponent*                             AttachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EAttachLocation>                LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bAutoDestroy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UParticleSystemComponent*                    ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UParticleSystemComponent* UGameplayStatics::STATIC_SpawnEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<Engine_EAttachLocation> LocationType, bool bAutoDestroy)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnEmitterAttached");

	UGameplayStatics_SpawnEmitterAttached_Params params {};
	params.EmitterTemplate = EmitterTemplate;
	params.AttachToComponent = AttachToComponent;
	params.AttachPointName = AttachPointName;
	params.Location = Location;
	params.Rotation = Rotation;
	params.LocationType = LocationType;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4C4F0
//		Name   -> Function Engine.GameplayStatics.SpawnEmitterAtLocation
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UParticleSystem*                             EmitterTemplate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bAutoDestroy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UParticleSystemComponent*                    ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UParticleSystemComponent* UGameplayStatics::STATIC_SpawnEmitterAtLocation(class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, bool bAutoDestroy)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnEmitterAtLocation");

	UGameplayStatics_SpawnEmitterAtLocation_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.EmitterTemplate = EmitterTemplate;
	params.Location = Location;
	params.Rotation = Rotation;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4C140
//		Name   -> Function Engine.GameplayStatics.SpawnDialogueAttached
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UDialogueWave*                               Dialogue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FDialogueContext                            Context                                                    (ConstParm, Parm, OutParm, ReferenceParm)
//		class USceneComponent*                             AttachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FName                                       AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		TEnumAsByte<Engine_EAttachLocation>                LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		bool                                               bStopWhenAttachedToDestroyed                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class UAudioComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UAudioComponent* UGameplayStatics::STATIC_SpawnDialogueAttached(class UDialogueWave* Dialogue, const struct FDialogueContext& Context, class USceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<Engine_EAttachLocation> LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogueAttached");

	UGameplayStatics_SpawnDialogueAttached_Params params {};
	params.Dialogue = Dialogue;
	params.Context = Context;
	params.AttachToComponent = AttachToComponent;
	params.AttachPointName = AttachPointName;
	params.Location = Location;
	params.Rotation = Rotation;
	params.LocationType = LocationType;
	params.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4BE70
//		Name   -> Function Engine.GameplayStatics.SpawnDialogueAtLocation
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UDialogueWave*                               Dialogue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FDialogueContext                            Context                                                    (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class UAudioComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UAudioComponent* UGameplayStatics::STATIC_SpawnDialogueAtLocation(class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogueAtLocation");

	UGameplayStatics_SpawnDialogueAtLocation_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Dialogue = Dialogue;
	params.Context = Context;
	params.Location = Location;
	params.Rotation = Rotation;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4BC80
//		Name   -> Function Engine.GameplayStatics.SpawnDialogue2D
//		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UDialogueWave*                               Dialogue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FDialogueContext                            Context                                                    (ConstParm, Parm, OutParm, ReferenceParm)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class UAudioComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UAudioComponent* UGameplayStatics::STATIC_SpawnDialogue2D(class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogue2D");

	UGameplayStatics_SpawnDialogue2D_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Dialogue = Dialogue;
	params.Context = Context;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4BA20
//		Name   -> Function Engine.GameplayStatics.SpawnDecalAttached
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          DecalMaterial                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     DecalSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class USceneComponent*                             AttachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EAttachLocation>                LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LifeSpan                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UDecalComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UDecalComponent* UGameplayStatics::STATIC_SpawnDecalAttached(class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, class USceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<Engine_EAttachLocation> LocationType, float LifeSpan)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDecalAttached");

	UGameplayStatics_SpawnDecalAttached_Params params {};
	params.DecalMaterial = DecalMaterial;
	params.DecalSize = DecalSize;
	params.AttachToComponent = AttachToComponent;
	params.AttachPointName = AttachPointName;
	params.Location = Location;
	params.Rotation = Rotation;
	params.LocationType = LocationType;
	params.LifeSpan = LifeSpan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4B840
//		Name   -> Function Engine.GameplayStatics.SpawnDecalAtLocation
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInterface*                          DecalMaterial                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     DecalSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              LifeSpan                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UDecalComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UDecalComponent* UGameplayStatics::STATIC_SpawnDecalAtLocation(class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDecalAtLocation");

	UGameplayStatics_SpawnDecalAtLocation_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.DecalMaterial = DecalMaterial;
	params.DecalSize = DecalSize;
	params.Location = Location;
	params.Rotation = Rotation;
	params.LifeSpan = LifeSpan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C4B600
//		Name   -> Function Engine.GameplayStatics.SetWorldOriginLocation
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FIntVector                                  NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UGameplayStatics::STATIC_SetWorldOriginLocation(class UObject* WorldContextObject, const struct FIntVector& NewLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetWorldOriginLocation");

	UGameplayStatics_SetWorldOriginLocation_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.NewLocation = NewLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47D00
//		Name   -> Function Engine.GameplayStatics.SetGlobalTimeDilation
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TimeDilation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameplayStatics::STATIC_SetGlobalTimeDilation(class UObject* WorldContextObject, float TimeDilation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalTimeDilation");

	UGameplayStatics_SetGlobalTimeDilation_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.TimeDilation = TimeDilation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47C40
//		Name   -> Function Engine.GameplayStatics.SetGamePaused
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bPaused                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_SetGamePaused(class UObject* WorldContextObject, bool bPaused)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGamePaused");

	UGameplayStatics_SetGamePaused_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.bPaused = bPaused;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C450A0
//		Name   -> Function Engine.GameplayStatics.SetBaseSoundMix
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USoundMix*                                   InSoundMix                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameplayStatics::STATIC_SetBaseSoundMix(class UObject* WorldContextObject, class USoundMix* InSoundMix)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetBaseSoundMix");

	UGameplayStatics_SetBaseSoundMix_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.InSoundMix = InSoundMix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C43A60
//		Name   -> Function Engine.GameplayStatics.SaveGameToSlot
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class USaveGame*                                   SaveGameObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     SlotName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_SaveGameToSlot(class USaveGame* SaveGameObject, const struct FString& SlotName, int UserIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SaveGameToSlot");

	UGameplayStatics_SaveGameToSlot_Params params {};
	params.SaveGameObject = SaveGameObject;
	params.SlotName = SlotName;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C438E0
//		Name   -> Function Engine.GameplayStatics.RemovePlayer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class APlayerController*                           Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bDestroyPawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UGameplayStatics::STATIC_RemovePlayer(class APlayerController* Player, bool bDestroyPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.RemovePlayer");

	UGameplayStatics_RemovePlayer_Params params {};
	params.Player = Player;
	params.bDestroyPawn = bDestroyPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C43530
//		Name   -> Function Engine.GameplayStatics.PushSoundMixModifier
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USoundMix*                                   InSoundMixModifier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameplayStatics::STATIC_PushSoundMixModifier(class UObject* WorldContextObject, class USoundMix* InSoundMixModifier)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PushSoundMixModifier");

	UGameplayStatics_PushSoundMixModifier_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.InSoundMixModifier = InSoundMixModifier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C43410
//		Name   -> Function Engine.GameplayStatics.ProjectWorldToScreen
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APlayerController*                           Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     WorldPosition                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ScreenPosition                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_ProjectWorldToScreen(class APlayerController* Player, const struct FVector& WorldPosition, struct FVector2D* ScreenPosition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ProjectWorldToScreen");

	UGameplayStatics_ProjectWorldToScreen_Params params {};
	params.Player = Player;
	params.WorldPosition = WorldPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (ScreenPosition != nullptr)
		*ScreenPosition = params.ScreenPosition;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C43280
//		Name   -> Function Engine.GameplayStatics.PopSoundMixModifier
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USoundMix*                                   InSoundMixModifier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameplayStatics::STATIC_PopSoundMixModifier(class UObject* WorldContextObject, class USoundMix* InSoundMixModifier)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PopSoundMixModifier");

	UGameplayStatics_PopSoundMixModifier_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.InSoundMixModifier = InSoundMixModifier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C43070
//		Name   -> Function Engine.GameplayStatics.PlayWorldCameraShake
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      Shake                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		struct FVector                                     Epicenter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              InnerRadius                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OuterRadius                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bOrientShakeTowardsEpicenter                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UGameplayStatics::STATIC_PlayWorldCameraShake(class UObject* WorldContextObject, class UClass* Shake, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayWorldCameraShake");

	UGameplayStatics_PlayWorldCameraShake_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Shake = Shake;
	params.Epicenter = Epicenter;
	params.InnerRadius = InnerRadius;
	params.OuterRadius = OuterRadius;
	params.Falloff = Falloff;
	params.bOrientShakeTowardsEpicenter = bOrientShakeTowardsEpicenter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C42E20
//		Name   -> Function Engine.GameplayStatics.PlaySoundAtLocation
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
void UGameplayStatics::STATIC_PlaySoundAtLocation(class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySoundAtLocation");

	UGameplayStatics_PlaySoundAtLocation_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Sound = Sound;
	params.Location = Location;
	params.Rotation = Rotation;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C42CA0
//		Name   -> Function Engine.GameplayStatics.PlaySound2D
//		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
void UGameplayStatics::STATIC_PlaySound2D(class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySound2D");

	UGameplayStatics_PlaySound2D_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Sound = Sound;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C425E0
//		Name   -> Function Engine.GameplayStatics.PlayDialogueAtLocation
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UDialogueWave*                               Dialogue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FDialogueContext                            Context                                                    (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
void UGameplayStatics::STATIC_PlayDialogueAtLocation(class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayDialogueAtLocation");

	UGameplayStatics_PlayDialogueAtLocation_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Dialogue = Dialogue;
	params.Context = Context;
	params.Location = Location;
	params.Rotation = Rotation;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C423F0
//		Name   -> Function Engine.GameplayStatics.PlayDialogue2D
//		Flags  -> (Final, BlueprintCosmetic, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UDialogueWave*                               Dialogue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FDialogueContext                            Context                                                    (ConstParm, Parm, OutParm, ReferenceParm)
//		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
void UGameplayStatics::STATIC_PlayDialogue2D(class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayDialogue2D");

	UGameplayStatics_PlayDialogue2D_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Dialogue = Dialogue;
	params.Context = Context;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C42000
//		Name   -> Function Engine.GameplayStatics.ParseOption
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UGameplayStatics::STATIC_ParseOption(const struct FString& Options, const struct FString& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ParseOption");

	UGameplayStatics_ParseOption_Params params {};
	params.Options = Options;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C41E90
//		Name   -> Function Engine.GameplayStatics.OpenLevel
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bAbsolute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FString                                     Options                                                    (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash)
void UGameplayStatics::STATIC_OpenLevel(class UObject* WorldContextObject, const struct FName& LevelName, bool bAbsolute, const struct FString& Options)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.OpenLevel");

	UGameplayStatics_OpenLevel_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.LevelName = LevelName;
	params.bAbsolute = bAbsolute;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C412B0
//		Name   -> Function Engine.GameplayStatics.LoadStreamLevel
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bMakeVisibleAfterLoad                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bShouldBlockOnLoad                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
void UGameplayStatics::STATIC_LoadStreamLevel(class UObject* WorldContextObject, const struct FName& LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, const struct FLatentActionInfo& LatentInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadStreamLevel");

	UGameplayStatics_LoadStreamLevel_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.LevelName = LevelName;
	params.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
	params.bShouldBlockOnLoad = bShouldBlockOnLoad;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C411D0
//		Name   -> Function Engine.GameplayStatics.LoadGameFromSlot
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     SlotName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USaveGame*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class USaveGame* UGameplayStatics::STATIC_LoadGameFromSlot(const struct FString& SlotName, int UserIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadGameFromSlot");

	UGameplayStatics_LoadGameFromSlot_Params params {};
	params.SlotName = SlotName;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40C70
//		Name   -> Function Engine.GameplayStatics.IsGamePaused
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_IsGamePaused(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.IsGamePaused");

	UGameplayStatics_IsGamePaused_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C409E0
//		Name   -> Function Engine.GameplayStatics.HasOption
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     InKey                                                      (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_HasOption(const struct FString& Options, const struct FString& InKey)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.HasOption");

	UGameplayStatics_HasOption_Params params {};
	params.Options = Options;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40890
//		Name   -> Function Engine.GameplayStatics.GrassOverlappingSphereCount
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UStaticMesh*                                 StaticMesh                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     CenterPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UGameplayStatics::STATIC_GrassOverlappingSphereCount(class UObject* WorldContextObject, class UStaticMesh* StaticMesh, const struct FVector& CenterPosition, float Radius)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GrassOverlappingSphereCount");

	UGameplayStatics_GrassOverlappingSphereCount_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.StaticMesh = StaticMesh;
	params.CenterPosition = CenterPosition;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40680
//		Name   -> Function Engine.GameplayStatics.GetWorldOriginLocation
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FIntVector                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FIntVector UGameplayStatics::STATIC_GetWorldOriginLocation(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetWorldOriginLocation");

	UGameplayStatics_GetWorldOriginLocation_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C405F0
//		Name   -> Function Engine.GameplayStatics.GetWorldDeltaSeconds
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UGameplayStatics::STATIC_GetWorldDeltaSeconds(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetWorldDeltaSeconds");

	UGameplayStatics_GetWorldDeltaSeconds_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C400C0
//		Name   -> Function Engine.GameplayStatics.GetSurfaceType
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		TEnumAsByte<Engine_EPhysicalSurface>               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
TEnumAsByte<Engine_EPhysicalSurface> UGameplayStatics::STATIC_GetSurfaceType(const struct FHitResult& Hit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetSurfaceType");

	UGameplayStatics_GetSurfaceType_Params params {};
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40000
//		Name   -> Function Engine.GameplayStatics.GetStreamingLevel
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class ULevelStreaming*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class ULevelStreaming* UGameplayStatics::STATIC_GetStreamingLevel(class UObject* WorldContextObject, const struct FName& PackageName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetStreamingLevel");

	UGameplayStatics_GetStreamingLevel_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F540
//		Name   -> Function Engine.GameplayStatics.GetRealTimeSeconds
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UGameplayStatics::STATIC_GetRealTimeSeconds(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetRealTimeSeconds");

	UGameplayStatics_GetRealTimeSeconds_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F480
//		Name   -> Function Engine.GameplayStatics.GetPlayerPawn
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class APawn*                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APawn* UGameplayStatics::STATIC_GetPlayerPawn(class UObject* WorldContextObject, int PlayerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerPawn");

	UGameplayStatics_GetPlayerPawn_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F3C0
//		Name   -> Function Engine.GameplayStatics.GetPlayerController
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class APlayerController*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APlayerController* UGameplayStatics::STATIC_GetPlayerController(class UObject* WorldContextObject, int PlayerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerController");

	UGameplayStatics_GetPlayerController_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F300
//		Name   -> Function Engine.GameplayStatics.GetPlayerCharacter
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class ACharacter*                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class ACharacter* UGameplayStatics::STATIC_GetPlayerCharacter(class UObject* WorldContextObject, int PlayerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerCharacter");

	UGameplayStatics_GetPlayerCharacter_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F240
//		Name   -> Function Engine.GameplayStatics.GetPlayerCameraManager
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class APlayerCameraManager*                        ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APlayerCameraManager* UGameplayStatics::STATIC_GetPlayerCameraManager(class UObject* WorldContextObject, int PlayerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerCameraManager");

	UGameplayStatics_GetPlayerCameraManager_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F100
//		Name   -> Function Engine.GameplayStatics.GetPlatformName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UGameplayStatics::STATIC_GetPlatformName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlatformName");

	UGameplayStatics_GetPlatformName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3EF30
//		Name   -> Function Engine.GameplayStatics.GetObjectClass
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UClass* UGameplayStatics::STATIC_GetObjectClass(class UObject* Object)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetObjectClass");

	UGameplayStatics_GetObjectClass_Params params {};
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3E7F0
//		Name   -> Function Engine.GameplayStatics.GetKeyValue
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     Pair                                                       (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Key                                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Value                                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
void UGameplayStatics::STATIC_GetKeyValue(const struct FString& Pair, struct FString* Key, struct FString* Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetKeyValue");

	UGameplayStatics_GetKeyValue_Params params {};
	params.Pair = Pair;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Key != nullptr)
		*Key = params.Key;
	if (Value != nullptr)
		*Value = params.Value;

}


// Function:
//		Offset -> 0x02C3E6B0
//		Name   -> Function Engine.GameplayStatics.GetIntOption
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                DefaultValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UGameplayStatics::STATIC_GetIntOption(const struct FString& Options, const struct FString& Key, int DefaultValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetIntOption");

	UGameplayStatics_GetIntOption_Params params {};
	params.Options = Options;
	params.Key = Key;
	params.DefaultValue = DefaultValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DC40
//		Name   -> Function Engine.GameplayStatics.GetGlobalTimeDilation
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UGameplayStatics::STATIC_GetGlobalTimeDilation(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGlobalTimeDilation");

	UGameplayStatics_GetGlobalTimeDilation_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DBC0
//		Name   -> Function Engine.GameplayStatics.GetGameState
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AGameState*                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AGameState* UGameplayStatics::STATIC_GetGameState(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameState");

	UGameplayStatics_GetGameState_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DB40
//		Name   -> Function Engine.GameplayStatics.GetGameMode
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AGameMode*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AGameMode* UGameplayStatics::STATIC_GetGameMode(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameMode");

	UGameplayStatics_GetGameMode_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DAC0
//		Name   -> Function Engine.GameplayStatics.GetGameInstance
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UGameInstance*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UGameInstance* UGameplayStatics::STATIC_GetGameInstance(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameInstance");

	UGameplayStatics_GetGameInstance_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D3E0
//		Name   -> Function Engine.GameplayStatics.GetCurrentLevelName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bRemovePrefixString                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UGameplayStatics::STATIC_GetCurrentLevelName(class UObject* WorldContextObject, bool bRemovePrefixString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetCurrentLevelName");

	UGameplayStatics_GetCurrentLevelName_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.bRemovePrefixString = bRemovePrefixString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3C900
//		Name   -> Function Engine.GameplayStatics.GetAudioTimeSeconds
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UGameplayStatics::STATIC_GetAudioTimeSeconds(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAudioTimeSeconds");

	UGameplayStatics_GetAudioTimeSeconds_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3C4B0
//		Name   -> Function Engine.GameplayStatics.GetAllActorsWithInterface
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      Interface                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
void UGameplayStatics::STATIC_GetAllActorsWithInterface(class UObject* WorldContextObject, class UClass* Interface, TArray<class AActor*>* OutActors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsWithInterface");

	UGameplayStatics_GetAllActorsWithInterface_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Interface = Interface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;

}


// Function:
//		Offset -> 0x02C3C390
//		Name   -> Function Engine.GameplayStatics.GetAllActorsOfClass
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ActorClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
void UGameplayStatics::STATIC_GetAllActorsOfClass(class UObject* WorldContextObject, class UClass* ActorClass, TArray<class AActor*>* OutActors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsOfClass");

	UGameplayStatics_GetAllActorsOfClass_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.ActorClass = ActorClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;

}


// Function:
//		Offset -> 0x02C3C1F0
//		Name   -> Function Engine.GameplayStatics.GetActorArrayBounds
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bOnlyCollidingComponents                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Center                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     BoxExtent                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UGameplayStatics::STATIC_GetActorArrayBounds(TArray<class AActor*> Actors, bool bOnlyCollidingComponents, struct FVector* Center, struct FVector* BoxExtent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorArrayBounds");

	UGameplayStatics_GetActorArrayBounds_Params params {};
	params.Actors = Actors;
	params.bOnlyCollidingComponents = bOnlyCollidingComponents;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Center != nullptr)
		*Center = params.Center;
	if (BoxExtent != nullptr)
		*BoxExtent = params.BoxExtent;

}


// Function:
//		Offset -> 0x02C3C130
//		Name   -> Function Engine.GameplayStatics.GetActorArrayAverageLocation
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UGameplayStatics::STATIC_GetActorArrayAverageLocation(TArray<class AActor*> Actors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorArrayAverageLocation");

	UGameplayStatics_GetActorArrayAverageLocation_Params params {};
	params.Actors = Actors;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3C010
//		Name   -> Function Engine.GameplayStatics.GetAccurateRealTime
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Seconds                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              PartialSeconds                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameplayStatics::STATIC_GetAccurateRealTime(class UObject* WorldContextObject, int* Seconds, float* PartialSeconds)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAccurateRealTime");

	UGameplayStatics_GetAccurateRealTime_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Seconds != nullptr)
		*Seconds = params.Seconds;
	if (PartialSeconds != nullptr)
		*PartialSeconds = params.PartialSeconds;

}


// Function:
//		Offset -> 0x02C3BFA0
//		Name   -> Function Engine.GameplayStatics.FlushLevelStreaming
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameplayStatics::STATIC_FlushLevelStreaming(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FlushLevelStreaming");

	UGameplayStatics_FlushLevelStreaming_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3BE50
//		Name   -> Function Engine.GameplayStatics.FinishSpawningActor
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* UGameplayStatics::STATIC_FinishSpawningActor(class AActor* Actor, const struct FTransform& SpawnTransform)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FinishSpawningActor");

	UGameplayStatics_FinishSpawningActor_Params params {};
	params.Actor = Actor;
	params.SpawnTransform = SpawnTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3BA60
//		Name   -> Function Engine.GameplayStatics.EnableLiveStreaming
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		bool                                               Enable                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UGameplayStatics::STATIC_EnableLiveStreaming(bool Enable)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.EnableLiveStreaming");

	UGameplayStatics_EnableLiveStreaming_Params params {};
	params.Enable = Enable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3B900
//		Name   -> Function Engine.GameplayStatics.DoesSaveGameExist
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     SlotName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_DoesSaveGameExist(const struct FString& SlotName, int UserIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DoesSaveGameExist");

	UGameplayStatics_DoesSaveGameExist_Params params {};
	params.SlotName = SlotName;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3B650
//		Name   -> Function Engine.GameplayStatics.DeprojectScreenToWorld
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APlayerController*                           Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ScreenPosition                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     WorldPosition                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     WorldDirection                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_DeprojectScreenToWorld(class APlayerController* Player, const struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeprojectScreenToWorld");

	UGameplayStatics_DeprojectScreenToWorld_Params params {};
	params.Player = Player;
	params.ScreenPosition = ScreenPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (WorldPosition != nullptr)
		*WorldPosition = params.WorldPosition;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3B570
//		Name   -> Function Engine.GameplayStatics.DeleteGameInSlot
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     SlotName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_DeleteGameInSlot(const struct FString& SlotName, int UserIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeleteGameInSlot");

	UGameplayStatics_DeleteGameInSlot_Params params {};
	params.SlotName = SlotName;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3B4C0
//		Name   -> Function Engine.GameplayStatics.DeactivateReverbEffect
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       TagName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameplayStatics::STATIC_DeactivateReverbEffect(class UObject* WorldContextObject, const struct FName& TagName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeactivateReverbEffect");

	UGameplayStatics_DeactivateReverbEffect_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.TagName = TagName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3B440
//		Name   -> Function Engine.GameplayStatics.CreateSaveGameObjectFromBlueprint
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UBlueprint*                                  SaveGameBlueprint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USaveGame*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class USaveGame* UGameplayStatics::STATIC_CreateSaveGameObjectFromBlueprint(class UBlueprint* SaveGameBlueprint)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreateSaveGameObjectFromBlueprint");

	UGameplayStatics_CreateSaveGameObjectFromBlueprint_Params params {};
	params.SaveGameBlueprint = SaveGameBlueprint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3B3C0
//		Name   -> Function Engine.GameplayStatics.CreateSaveGameObject
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      SaveGameClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class USaveGame*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class USaveGame* UGameplayStatics::STATIC_CreateSaveGameObject(class UClass* SaveGameClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreateSaveGameObject");

	UGameplayStatics_CreateSaveGameObject_Params params {};
	params.SaveGameClass = SaveGameClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3B2D0
//		Name   -> Function Engine.GameplayStatics.CreatePlayer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ControllerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSpawnPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		class APlayerController*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class APlayerController* UGameplayStatics::STATIC_CreatePlayer(class UObject* WorldContextObject, int ControllerId, bool bSpawnPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreatePlayer");

	UGameplayStatics_CreatePlayer_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.ControllerId = ControllerId;
	params.bSpawnPawn = bSpawnPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3A8F0
//		Name   -> Function Engine.GameplayStatics.ClearSoundMixModifiers
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UGameplayStatics::STATIC_ClearSoundMixModifiers(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ClearSoundMixModifiers");

	UGameplayStatics_ClearSoundMixModifiers_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C39F20
//		Name   -> Function Engine.GameplayStatics.BreakHitResult
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		bool                                               bBlockingHit                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bInitialOverlap                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Time                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ImpactPoint                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Normal                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ImpactNormal                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UPhysicalMaterial*                           PhysMat                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      HitActor                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UPrimitiveComponent*                         HitComponent                                               (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       HitBoneName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                HitItem                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     TraceStart                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     TraceEnd                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UGameplayStatics::STATIC_BreakHitResult(const struct FHitResult& Hit, bool* bBlockingHit, bool* bInitialOverlap, float* Time, struct FVector* Location, struct FVector* ImpactPoint, struct FVector* Normal, struct FVector* ImpactNormal, class UPhysicalMaterial** PhysMat, class AActor** HitActor, class UPrimitiveComponent** HitComponent, struct FName* HitBoneName, int* HitItem, struct FVector* TraceStart, struct FVector* TraceEnd)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BreakHitResult");

	UGameplayStatics_BreakHitResult_Params params {};
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (bBlockingHit != nullptr)
		*bBlockingHit = params.bBlockingHit;
	if (bInitialOverlap != nullptr)
		*bInitialOverlap = params.bInitialOverlap;
	if (Time != nullptr)
		*Time = params.Time;
	if (Location != nullptr)
		*Location = params.Location;
	if (ImpactPoint != nullptr)
		*ImpactPoint = params.ImpactPoint;
	if (Normal != nullptr)
		*Normal = params.Normal;
	if (ImpactNormal != nullptr)
		*ImpactNormal = params.ImpactNormal;
	if (PhysMat != nullptr)
		*PhysMat = params.PhysMat;
	if (HitActor != nullptr)
		*HitActor = params.HitActor;
	if (HitComponent != nullptr)
		*HitComponent = params.HitComponent;
	if (HitBoneName != nullptr)
		*HitBoneName = params.HitBoneName;
	if (HitItem != nullptr)
		*HitItem = params.HitItem;
	if (TraceStart != nullptr)
		*TraceStart = params.TraceStart;
	if (TraceEnd != nullptr)
		*TraceEnd = params.TraceEnd;

}


// Function:
//		Offset -> 0x02C39C30
//		Name   -> Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     TossVelocity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     StartLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     EndLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              LaunchSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OverrideGravityZ                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ESuggestProjVelocityTraceOption> TraceOption                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              CollisionRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bFavorHighArc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bDrawDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_BlueprintSuggestProjectileVelocity(class UObject* WorldContextObject, struct FVector* TossVelocity, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, TEnumAsByte<Engine_ESuggestProjVelocityTraceOption> TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity");

	UGameplayStatics_BlueprintSuggestProjectileVelocity_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.StartLocation = StartLocation;
	params.EndLocation = EndLocation;
	params.LaunchSpeed = LaunchSpeed;
	params.OverrideGravityZ = OverrideGravityZ;
	params.TraceOption = TraceOption;
	params.CollisionRadius = CollisionRadius;
	params.bFavorHighArc = bFavorHighArc;
	params.bDrawDebug = bDrawDebug;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (TossVelocity != nullptr)
		*TossVelocity = params.TossVelocity;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C39A20
//		Name   -> Function Engine.GameplayStatics.BeginSpawningActorFromClass
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ActorClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bNoCollisionFail                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* UGameplayStatics::STATIC_BeginSpawningActorFromClass(class UObject* WorldContextObject, class UClass* ActorClass, const struct FTransform& SpawnTransform, bool bNoCollisionFail, class AActor* Owner)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginSpawningActorFromClass");

	UGameplayStatics_BeginSpawningActorFromClass_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.ActorClass = ActorClass;
	params.SpawnTransform = SpawnTransform;
	params.bNoCollisionFail = bNoCollisionFail;
	params.Owner = Owner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C39860
//		Name   -> Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UBlueprint*                                  Blueprint                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bNoCollisionFail                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* UGameplayStatics::STATIC_BeginSpawningActorFromBlueprint(class UObject* WorldContextObject, class UBlueprint* Blueprint, const struct FTransform& SpawnTransform, bool bNoCollisionFail)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint");

	UGameplayStatics_BeginSpawningActorFromBlueprint_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Blueprint = Blueprint;
	params.SpawnTransform = SpawnTransform;
	params.bNoCollisionFail = bNoCollisionFail;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C39660
//		Name   -> Function Engine.GameplayStatics.BeginDeferredActorSpawnFromClass
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ActorClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ESpawnActorCollisionHandlingMethod> CollisionHandlingOverride                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class AActor* UGameplayStatics::STATIC_BeginDeferredActorSpawnFromClass(class UObject* WorldContextObject, class UClass* ActorClass, const struct FTransform& SpawnTransform, TEnumAsByte<Engine_ESpawnActorCollisionHandlingMethod> CollisionHandlingOverride, class AActor* Owner)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginDeferredActorSpawnFromClass");

	UGameplayStatics_BeginDeferredActorSpawnFromClass_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.ActorClass = ActorClass;
	params.SpawnTransform = SpawnTransform;
	params.CollisionHandlingOverride = CollisionHandlingOverride;
	params.Owner = Owner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C39390
//		Name   -> Function Engine.GameplayStatics.AreAnyListenersWithinRange
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              MaximumRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_AreAnyListenersWithinRange(class UObject* WorldContextObject, const struct FVector& Location, float MaximumRange)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.AreAnyListenersWithinRange");

	UGameplayStatics_AreAnyListenersWithinRange_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Location = Location;
	params.MaximumRange = MaximumRange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C38DB0
//		Name   -> Function Engine.GameplayStatics.ApplyRadialDamageWithFalloff
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MinimumDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              DamageInnerRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              DamageOuterRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              DamageFalloff                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		TArray<class AActor*>                              IgnoreActors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AController*                                 InstigatedByController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECollisionChannel>              DamagePreventionChannel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_ApplyRadialDamageWithFalloff(class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, class UClass* DamageTypeClass, TArray<class AActor*> IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, TEnumAsByte<Engine_ECollisionChannel> DamagePreventionChannel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyRadialDamageWithFalloff");

	UGameplayStatics_ApplyRadialDamageWithFalloff_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.BaseDamage = BaseDamage;
	params.MinimumDamage = MinimumDamage;
	params.Origin = Origin;
	params.DamageInnerRadius = DamageInnerRadius;
	params.DamageOuterRadius = DamageOuterRadius;
	params.DamageFalloff = DamageFalloff;
	params.DamageTypeClass = DamageTypeClass;
	params.IgnoreActors = IgnoreActors;
	params.DamageCauser = DamageCauser;
	params.InstigatedByController = InstigatedByController;
	params.DamagePreventionChannel = DamagePreventionChannel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C38AB0
//		Name   -> Function Engine.GameplayStatics.ApplyRadialDamage
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              DamageRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		TArray<class AActor*>                              IgnoreActors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AController*                                 InstigatedByController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bDoFullDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ECollisionChannel>              DamagePreventionChannel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGameplayStatics::STATIC_ApplyRadialDamage(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, class UClass* DamageTypeClass, TArray<class AActor*> IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, TEnumAsByte<Engine_ECollisionChannel> DamagePreventionChannel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyRadialDamage");

	UGameplayStatics_ApplyRadialDamage_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.BaseDamage = BaseDamage;
	params.Origin = Origin;
	params.DamageRadius = DamageRadius;
	params.DamageTypeClass = DamageTypeClass;
	params.IgnoreActors = IgnoreActors;
	params.DamageCauser = DamageCauser;
	params.InstigatedByController = InstigatedByController;
	params.bDoFullDamage = bDoFullDamage;
	params.DamagePreventionChannel = DamagePreventionChannel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C38870
//		Name   -> Function Engine.GameplayStatics.ApplyPointDamage
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     HitFromDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void UGameplayStatics::STATIC_ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, class UClass* DamageTypeClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyPointDamage");

	UGameplayStatics_ApplyPointDamage_Params params {};
	params.DamagedActor = DamagedActor;
	params.BaseDamage = BaseDamage;
	params.HitFromDirection = HitFromDirection;
	params.HitInfo = HitInfo;
	params.EventInstigator = EventInstigator;
	params.DamageCauser = DamageCauser;
	params.DamageTypeClass = DamageTypeClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C386F0
//		Name   -> Function Engine.GameplayStatics.ApplyDamage
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void UGameplayStatics::STATIC_ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, class UClass* DamageTypeClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyDamage");

	UGameplayStatics_ApplyDamage_Params params {};
	params.DamagedActor = DamagedActor;
	params.BaseDamage = BaseDamage;
	params.EventInstigator = EventInstigator;
	params.DamageCauser = DamageCauser;
	params.DamageTypeClass = DamageTypeClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C37700
//		Name   -> Function Engine.GameplayStatics.ActivateReverbEffect
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UReverbEffect*                               ReverbEffect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       TagName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
void UGameplayStatics::STATIC_ActivateReverbEffect(class UObject* WorldContextObject, class UReverbEffect* ReverbEffect, const struct FName& TagName, float Priority, float Volume, float FadeTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ActivateReverbEffect");

	UGameplayStatics_ActivateReverbEffect_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.ReverbEffect = ReverbEffect;
	params.TagName = TagName;
	params.Priority = Priority;
	params.Volume = Volume;
	params.FadeTime = FadeTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UGameplayStatics::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UGameplayStatics::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

void UGPUSortDestData::AfterRead()
{
	UObject::AfterRead();

}

void UGPUSortDestData::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02D782F0
//		Name   -> Function Engine.GPUSortTestLibrary.ValidateGPUTransposeForSize
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UGPUSortDestData*                            TestData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGPUSortTestLibrary::STATIC_ValidateGPUTransposeForSize(class UObject* WorldContext, class UGPUSortDestData* TestData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GPUSortTestLibrary.ValidateGPUTransposeForSize");

	UGPUSortTestLibrary_ValidateGPUTransposeForSize_Params params {};
	params.WorldContext = WorldContext;
	params.TestData = TestData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D78230
//		Name   -> Function Engine.GPUSortTestLibrary.ValidateGPUSortForSize
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UGPUSortDestData*                            TestData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UGPUSortTestLibrary::STATIC_ValidateGPUSortForSize(class UObject* WorldContext, class UGPUSortDestData* TestData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GPUSortTestLibrary.ValidateGPUSortForSize");

	UGPUSortTestLibrary_ValidateGPUSortForSize_Params params {};
	params.WorldContext = WorldContext;
	params.TestData = TestData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76830
//		Name   -> Function Engine.GPUSortTestLibrary.TestGPUTransposeForSize
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UGPUSortDestData*                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UGPUSortDestData* UGPUSortTestLibrary::STATIC_TestGPUTransposeForSize(class UObject* WorldContext, int Size)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GPUSortTestLibrary.TestGPUTransposeForSize");

	UGPUSortTestLibrary_TestGPUTransposeForSize_Params params {};
	params.WorldContext = WorldContext;
	params.Size = Size;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76770
//		Name   -> Function Engine.GPUSortTestLibrary.TestGPUSortForSize
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UGPUSortDestData*                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UGPUSortDestData* UGPUSortTestLibrary::STATIC_TestGPUSortForSize(class UObject* WorldContext, int Size)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.GPUSortTestLibrary.TestGPUSortForSize");

	UGPUSortTestLibrary_TestGPUSortForSize_Params params {};
	params.WorldContext = WorldContext;
	params.Size = Size;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UGPUSortTestLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UGPUSortTestLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D70D30
//		Name   -> Function Engine.KismetArrayLibrary.SetArrayPropertyByName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<int>                                        Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
void UKismetArrayLibrary::STATIC_SetArrayPropertyByName(class UObject* Object, const struct FName& PropertyName, TArray<int> Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.SetArrayPropertyByName");

	UKismetArrayLibrary_SetArrayPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D58FF0
//		Name   -> Function Engine.KismetArrayLibrary.FilterArray
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<class AActor*>                              TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		TArray<class AActor*>                              FilteredArray                                              (Parm, OutParm, ZeroConstructor)
void UKismetArrayLibrary::STATIC_FilterArray(TArray<class AActor*> TargetArray, class UClass* FilterClass, TArray<class AActor*>* FilteredArray)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.FilterArray");

	UKismetArrayLibrary_FilterArray_Params params {};
	params.TargetArray = TargetArray;
	params.FilterClass = FilterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (FilteredArray != nullptr)
		*FilteredArray = params.FilteredArray;

}


// Function:
//		Offset -> 0x02D47CF0
//		Name   -> Function Engine.KismetArrayLibrary.Array_Shuffle
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
void UKismetArrayLibrary::STATIC_Array_Shuffle(TArray<int> TargetArray)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Shuffle");

	UKismetArrayLibrary_Array_Shuffle_Params params {};
	params.TargetArray = TargetArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D47A90
//		Name   -> Function Engine.KismetArrayLibrary.Array_Set
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Item                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSizeToFit                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetArrayLibrary::STATIC_Array_Set(TArray<int> TargetArray, int Index, int Item, bool bSizeToFit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Set");

	UKismetArrayLibrary_Array_Set_Params params {};
	params.TargetArray = TargetArray;
	params.Index = Index;
	params.Item = Item;
	params.bSizeToFit = bSizeToFit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D47970
//		Name   -> Function Engine.KismetArrayLibrary.Array_Resize
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetArrayLibrary::STATIC_Array_Resize(TArray<int> TargetArray, int Size)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Resize");

	UKismetArrayLibrary_Array_Resize_Params params {};
	params.TargetArray = TargetArray;
	params.Size = Size;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D47790
//		Name   -> Function Engine.KismetArrayLibrary.Array_RemoveItem
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                Item                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetArrayLibrary::STATIC_Array_RemoveItem(TArray<int> TargetArray, int Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_RemoveItem");

	UKismetArrayLibrary_Array_RemoveItem_Params params {};
	params.TargetArray = TargetArray;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D47670
//		Name   -> Function Engine.KismetArrayLibrary.Array_Remove
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                IndexToRemove                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetArrayLibrary::STATIC_Array_Remove(TArray<int> TargetArray, int IndexToRemove)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Remove");

	UKismetArrayLibrary_Array_Remove_Params params {};
	params.TargetArray = TargetArray;
	params.IndexToRemove = IndexToRemove;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D47580
//		Name   -> Function Engine.KismetArrayLibrary.Array_Length
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetArrayLibrary::STATIC_Array_Length(TArray<int> TargetArray)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Length");

	UKismetArrayLibrary_Array_Length_Params params {};
	params.TargetArray = TargetArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D47490
//		Name   -> Function Engine.KismetArrayLibrary.Array_LastIndex
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetArrayLibrary::STATIC_Array_LastIndex(TArray<int> TargetArray)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_LastIndex");

	UKismetArrayLibrary_Array_LastIndex_Params params {};
	params.TargetArray = TargetArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D47270
//		Name   -> Function Engine.KismetArrayLibrary.Array_Insert
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                NewItem                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetArrayLibrary::STATIC_Array_Insert(TArray<int> TargetArray, int NewItem, int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Insert");

	UKismetArrayLibrary_Array_Insert_Params params {};
	params.TargetArray = TargetArray;
	params.NewItem = NewItem;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D47060
//		Name   -> Function Engine.KismetArrayLibrary.Array_Get
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Item                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetArrayLibrary::STATIC_Array_Get(TArray<int> TargetArray, int Index, int* Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Get");

	UKismetArrayLibrary_Array_Get_Params params {};
	params.TargetArray = TargetArray;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Item != nullptr)
		*Item = params.Item;

}


// Function:
//		Offset -> 0x02D46E80
//		Name   -> Function Engine.KismetArrayLibrary.Array_Find
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                ItemToFind                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetArrayLibrary::STATIC_Array_Find(TArray<int> TargetArray, int ItemToFind)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Find");

	UKismetArrayLibrary_Array_Find_Params params {};
	params.TargetArray = TargetArray;
	params.ItemToFind = ItemToFind;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D46C90
//		Name   -> Function Engine.KismetArrayLibrary.Array_Contains
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                ItemToFind                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetArrayLibrary::STATIC_Array_Contains(TArray<int> TargetArray, int ItemToFind)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Contains");

	UKismetArrayLibrary_Array_Contains_Params params {};
	params.TargetArray = TargetArray;
	params.ItemToFind = ItemToFind;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D46BB0
//		Name   -> Function Engine.KismetArrayLibrary.Array_Clear
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
void UKismetArrayLibrary::STATIC_Array_Clear(TArray<int> TargetArray)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Clear");

	UKismetArrayLibrary_Array_Clear_Params params {};
	params.TargetArray = TargetArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D46A30
//		Name   -> Function Engine.KismetArrayLibrary.Array_Append
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<int>                                        SourceArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
void UKismetArrayLibrary::STATIC_Array_Append(TArray<int> TargetArray, TArray<int> SourceArray)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Append");

	UKismetArrayLibrary_Array_Append_Params params {};
	params.TargetArray = TargetArray;
	params.SourceArray = SourceArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D46850
//		Name   -> Function Engine.KismetArrayLibrary.Array_AddUnique
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                NewItem                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetArrayLibrary::STATIC_Array_AddUnique(TArray<int> TargetArray, int NewItem)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_AddUnique");

	UKismetArrayLibrary_Array_AddUnique_Params params {};
	params.TargetArray = TargetArray;
	params.NewItem = NewItem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D46670
//		Name   -> Function Engine.KismetArrayLibrary.Array_Add
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<int>                                        TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                NewItem                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetArrayLibrary::STATIC_Array_Add(TArray<int> TargetArray, int NewItem)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Add");

	UKismetArrayLibrary_Array_Add_Params params {};
	params.TargetArray = TargetArray;
	params.NewItem = NewItem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UKismetArrayLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UKismetArrayLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D6B910
//		Name   -> Function Engine.KismetGuidLibrary.Parse_StringToGuid
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     GuidString                                                 (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FGuid                                       OutGuid                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               Success                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetGuidLibrary::STATIC_Parse_StringToGuid(const struct FString& GuidString, struct FGuid* OutGuid, bool* Success)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Parse_StringToGuid");

	UKismetGuidLibrary_Parse_StringToGuid_Params params {};
	params.GuidString = GuidString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutGuid != nullptr)
		*OutGuid = params.OutGuid;
	if (Success != nullptr)
		*Success = params.Success;

}


// Function:
//		Offset -> 0x02D6AAF0
//		Name   -> Function Engine.KismetGuidLibrary.NotEqual_GuidGuid
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FGuid                                       A                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FGuid                                       B                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetGuidLibrary::STATIC_NotEqual_GuidGuid(const struct FGuid& A, const struct FGuid& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.NotEqual_GuidGuid");

	UKismetGuidLibrary_NotEqual_GuidGuid_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A350
//		Name   -> Function Engine.KismetGuidLibrary.NewGuid
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FGuid                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FGuid UKismetGuidLibrary::STATIC_NewGuid()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.NewGuid");

	UKismetGuidLibrary_NewGuid_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5F4A0
//		Name   -> Function Engine.KismetGuidLibrary.IsValid_Guid
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FGuid                                       InGuid                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetGuidLibrary::STATIC_IsValid_Guid(const struct FGuid& InGuid)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.IsValid_Guid");

	UKismetGuidLibrary_IsValid_Guid_Params params {};
	params.InGuid = InGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E730
//		Name   -> Function Engine.KismetGuidLibrary.Invalidate_Guid
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FGuid                                       InGuid                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UKismetGuidLibrary::STATIC_Invalidate_Guid(struct FGuid* InGuid)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Invalidate_Guid");

	UKismetGuidLibrary_Invalidate_Guid_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (InGuid != nullptr)
		*InGuid = params.InGuid;

}


// Function:
//		Offset -> 0x02D577B0
//		Name   -> Function Engine.KismetGuidLibrary.EqualEqual_GuidGuid
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FGuid                                       A                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FGuid                                       B                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetGuidLibrary::STATIC_EqualEqual_GuidGuid(const struct FGuid& A, const struct FGuid& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.EqualEqual_GuidGuid");

	UKismetGuidLibrary_EqualEqual_GuidGuid_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51BF0
//		Name   -> Function Engine.KismetGuidLibrary.Conv_GuidToString
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FGuid                                       InGuid                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetGuidLibrary::STATIC_Conv_GuidToString(const struct FGuid& InGuid)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Conv_GuidToString");

	UKismetGuidLibrary_Conv_GuidToString_Params params {};
	params.InGuid = InGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UKismetGuidLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UKismetGuidLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D6C840
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_PointerEvent_IsTouchEvent(const struct FPointerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent");

	UKismetInputLibrary_PointerEvent_IsTouchEvent_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6C690
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FKey                                        MouseButton                                                (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_PointerEvent_IsMouseButtonDown(const struct FPointerEvent& Input, const struct FKey& MouseButton)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown");

	UKismetInputLibrary_PointerEvent_IsMouseButtonDown_Params params {};
	params.Input = Input;
	params.MouseButton = MouseButton;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6C580
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetInputLibrary::STATIC_PointerEvent_GetWheelDelta(const struct FPointerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta");

	UKismetInputLibrary_PointerEvent_GetWheelDelta_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6C470
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetInputLibrary::STATIC_PointerEvent_GetUserIndex(const struct FPointerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex");

	UKismetInputLibrary_PointerEvent_GetUserIndex_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6C360
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetInputLibrary::STATIC_PointerEvent_GetTouchpadIndex(const struct FPointerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex");

	UKismetInputLibrary_PointerEvent_GetTouchpadIndex_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6C250
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetScreenSpacePosition(const struct FPointerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition");

	UKismetInputLibrary_PointerEvent_GetScreenSpacePosition_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6C140
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetInputLibrary::STATIC_PointerEvent_GetPointerIndex(const struct FPointerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex");

	UKismetInputLibrary_PointerEvent_GetPointerIndex_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6C030
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetLastScreenSpacePosition(const struct FPointerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition");

	UKismetInputLibrary_PointerEvent_GetLastScreenSpacePosition_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6BF20
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetGestureDelta(const struct FPointerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta");

	UKismetInputLibrary_PointerEvent_GetGestureDelta_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6BDD0
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FKey                                        ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FKey UKismetInputLibrary::STATIC_PointerEvent_GetEffectingButton(const struct FPointerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton");

	UKismetInputLibrary_PointerEvent_GetEffectingButton_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6BCC0
//		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetCursorDelta(const struct FPointerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta");

	UKismetInputLibrary_PointerEvent_GetCursorDelta_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62850
//		Name   -> Function Engine.KismetInputLibrary.Key_IsVectorAxis
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_Key_IsVectorAxis(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsVectorAxis");

	UKismetInputLibrary_Key_IsVectorAxis_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D627A0
//		Name   -> Function Engine.KismetInputLibrary.Key_IsMouseButton
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_Key_IsMouseButton(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsMouseButton");

	UKismetInputLibrary_Key_IsMouseButton_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D626F0
//		Name   -> Function Engine.KismetInputLibrary.Key_IsModifierKey
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_Key_IsModifierKey(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsModifierKey");

	UKismetInputLibrary_Key_IsModifierKey_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62640
//		Name   -> Function Engine.KismetInputLibrary.Key_IsKeyboardKey
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_Key_IsKeyboardKey(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsKeyboardKey");

	UKismetInputLibrary_Key_IsKeyboardKey_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62590
//		Name   -> Function Engine.KismetInputLibrary.Key_IsGamepadKey
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_Key_IsGamepadKey(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsGamepadKey");

	UKismetInputLibrary_Key_IsGamepadKey_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D624E0
//		Name   -> Function Engine.KismetInputLibrary.Key_IsFloatAxis
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_Key_IsFloatAxis(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsFloatAxis");

	UKismetInputLibrary_Key_IsFloatAxis_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62410
//		Name   -> Function Engine.KismetInputLibrary.Key_GetDisplayName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetInputLibrary::STATIC_Key_GetDisplayName(const struct FKey& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetDisplayName");

	UKismetInputLibrary_Key_GetDisplayName_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E670
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsShiftDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsShiftDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsShiftDown");

	UKismetInputLibrary_InputEvent_IsShiftDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E5B0
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsRightShiftDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown");

	UKismetInputLibrary_InputEvent_IsRightShiftDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E4F0
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsRightControlDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown");

	UKismetInputLibrary_InputEvent_IsRightControlDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E430
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsRightCommandDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown");

	UKismetInputLibrary_InputEvent_IsRightCommandDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E370
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsRightAltDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown");

	UKismetInputLibrary_InputEvent_IsRightAltDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E2B0
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsRepeat
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsRepeat(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRepeat");

	UKismetInputLibrary_InputEvent_IsRepeat_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E1F0
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsLeftShiftDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown");

	UKismetInputLibrary_InputEvent_IsLeftShiftDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E130
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsLeftControlDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown");

	UKismetInputLibrary_InputEvent_IsLeftControlDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E070
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsLeftCommandDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown");

	UKismetInputLibrary_InputEvent_IsLeftCommandDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5DFB0
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsLeftAltDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown");

	UKismetInputLibrary_InputEvent_IsLeftAltDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5DEF0
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsControlDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsControlDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsControlDown");

	UKismetInputLibrary_InputEvent_IsControlDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5DE30
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsCommandDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsCommandDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsCommandDown");

	UKismetInputLibrary_InputEvent_IsCommandDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5DD70
//		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsAltDown
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_InputEvent_IsAltDown(const struct FInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsAltDown");

	UKismetInputLibrary_InputEvent_IsAltDown_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C760
//		Name   -> Function Engine.KismetInputLibrary.GetUserIndex
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FKeyEvent                                   Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetInputLibrary::STATIC_GetUserIndex(const struct FKeyEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetUserIndex");

	UKismetInputLibrary_GetUserIndex_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B220
//		Name   -> Function Engine.KismetInputLibrary.GetKey
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FKeyEvent                                   Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FKey                                        ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FKey UKismetInputLibrary::STATIC_GetKey(const struct FKeyEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetKey");

	UKismetInputLibrary_GetKey_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A030
//		Name   -> Function Engine.KismetInputLibrary.GetAnalogValue
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FAnalogInputEvent                           Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetInputLibrary::STATIC_GetAnalogValue(const struct FAnalogInputEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetAnalogValue");

	UKismetInputLibrary_GetAnalogValue_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D57A90
//		Name   -> Function Engine.KismetInputLibrary.EqualEqual_KeyKey
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FKey                                        A                                                          (Parm)
//		struct FKey                                        B                                                          (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetInputLibrary::STATIC_EqualEqual_KeyKey(const struct FKey& A, const struct FKey& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.EqualEqual_KeyKey");

	UKismetInputLibrary_EqualEqual_KeyKey_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D50DE0
//		Name   -> Function Engine.KismetInputLibrary.ControllerEvent_GetUserIndex
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FControllerEvent                            Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetInputLibrary::STATIC_ControllerEvent_GetUserIndex(const struct FControllerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.ControllerEvent_GetUserIndex");

	UKismetInputLibrary_ControllerEvent_GetUserIndex_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D50C60
//		Name   -> Function Engine.KismetInputLibrary.ControllerEvent_GetEffectingButton
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FControllerEvent                            Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FKey                                        ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FKey UKismetInputLibrary::STATIC_ControllerEvent_GetEffectingButton(const struct FControllerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.ControllerEvent_GetEffectingButton");

	UKismetInputLibrary_ControllerEvent_GetEffectingButton_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D50B30
//		Name   -> Function Engine.KismetInputLibrary.ControllerEvent_GetAnalogValue
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FControllerEvent                            Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetInputLibrary::STATIC_ControllerEvent_GetAnalogValue(const struct FControllerEvent& Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.ControllerEvent_GetAnalogValue");

	UKismetInputLibrary_ControllerEvent_GetAnalogValue_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4CDB0
//		Name   -> Function Engine.KismetInputLibrary.CalibrateTilt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
void UKismetInputLibrary::STATIC_CalibrateTilt()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.CalibrateTilt");

	UKismetInputLibrary_CalibrateTilt_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UKismetInputLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UKismetInputLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D72360
//		Name   -> Function Engine.KismetMaterialLibrary.SetVectorParameterValue
//		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialParameterCollection*                Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ParameterValue                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UKismetMaterialLibrary::STATIC_SetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const struct FName& ParameterName, const struct FLinearColor& ParameterValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.SetVectorParameterValue");

	UKismetMaterialLibrary_SetVectorParameterValue_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Collection = Collection;
	params.ParameterName = ParameterName;
	params.ParameterValue = ParameterValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71C60
//		Name   -> Function Engine.KismetMaterialLibrary.SetScalarParameterValue
//		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialParameterCollection*                Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ParameterValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMaterialLibrary::STATIC_SetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const struct FName& ParameterName, float ParameterValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.SetScalarParameterValue");

	UKismetMaterialLibrary_SetScalarParameterValue_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Collection = Collection;
	params.ParameterName = ParameterName;
	params.ParameterValue = ParameterValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5C9D0
//		Name   -> Function Engine.KismetMaterialLibrary.GetVectorParameterValue
//		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialParameterCollection*                Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMaterialLibrary::STATIC_GetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const struct FName& ParameterName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.GetVectorParameterValue");

	UKismetMaterialLibrary_GetVectorParameterValue_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Collection = Collection;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BDA0
//		Name   -> Function Engine.KismetMaterialLibrary.GetScalarParameterValue
//		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialParameterCollection*                Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMaterialLibrary::STATIC_GetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const struct FName& ParameterName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.GetScalarParameterValue");

	UKismetMaterialLibrary_GetScalarParameterValue_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Collection = Collection;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53340
//		Name   -> Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance
//		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInterface*                          Parent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInstanceDynamic*                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInstanceDynamic* UKismetMaterialLibrary::STATIC_CreateDynamicMaterialInstance(class UObject* WorldContextObject, class UMaterialInterface* Parent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance");

	UKismetMaterialLibrary_CreateDynamicMaterialInstance_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Parent = Parent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UKismetMaterialLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UKismetMaterialLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D788A0
//		Name   -> Function Engine.KismetMathLibrary.Xor_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Xor_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Xor_IntInt");

	UKismetMathLibrary_Xor_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D781A0
//		Name   -> Function Engine.KismetMathLibrary.VSizeSquared
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_VSizeSquared(const struct FVector& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeSquared");

	UKismetMathLibrary_VSizeSquared_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D78090
//		Name   -> Function Engine.KismetMathLibrary.VSize2DSquared
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_VSize2DSquared(const struct FVector2D& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize2DSquared");

	UKismetMathLibrary_VSize2DSquared_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D78010
//		Name   -> Function Engine.KismetMathLibrary.VSize2D
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_VSize2D(const struct FVector2D& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize2D");

	UKismetMathLibrary_VSize2D_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D78110
//		Name   -> Function Engine.KismetMathLibrary.VSize
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_VSize(const struct FVector& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize");

	UKismetMathLibrary_VSize_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D77ED0
//		Name   -> Function Engine.KismetMathLibrary.VLerp
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_VLerp(const struct FVector& A, const struct FVector& B, float Alpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VLerp");

	UKismetMathLibrary_VLerp_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D77D30
//		Name   -> Function Engine.KismetMathLibrary.VInterpTo_Constant
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_VInterpTo_Constant(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_Constant");

	UKismetMathLibrary_VInterpTo_Constant_Params params {};
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D77B90
//		Name   -> Function Engine.KismetMathLibrary.VInterpTo
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_VInterpTo(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo");

	UKismetMathLibrary_VInterpTo_Params params {};
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D78500
//		Name   -> Function Engine.KismetMathLibrary.Vector2DInterpTo_Constant
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_Vector2DInterpTo_Constant(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2DInterpTo_Constant");

	UKismetMathLibrary_Vector2DInterpTo_Constant_Params params {};
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D783B0
//		Name   -> Function Engine.KismetMathLibrary.Vector2DInterpTo
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_Vector2DInterpTo(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2DInterpTo");

	UKismetMathLibrary_Vector2DInterpTo_Params params {};
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D77990
//		Name   -> Function Engine.KismetMathLibrary.VEase
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EEasingFunc>                    EasingFunc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Steps                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_VEase(const struct FVector& A, const struct FVector& B, float Alpha, TEnumAsByte<Engine_EEasingFunc> EasingFunc, float BlendExp, int Steps)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VEase");

	UKismetMathLibrary_VEase_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;
	params.EasingFunc = EasingFunc;
	params.BlendExp = BlendExp;
	params.Steps = Steps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D77950
//		Name   -> Function Engine.KismetMathLibrary.UtcNow
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FDateTime UKismetMathLibrary::STATIC_UtcNow()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.UtcNow");

	UKismetMathLibrary_UtcNow_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D774B0
//		Name   -> Function Engine.KismetMathLibrary.TransformLocation
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  T                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_TransformLocation(const struct FTransform& T, const struct FVector& Location)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformLocation");

	UKismetMathLibrary_TransformLocation_Params params {};
	params.T = T;
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D77350
//		Name   -> Function Engine.KismetMathLibrary.TransformDirection
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  T                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_TransformDirection(const struct FTransform& T, const struct FVector& Direction)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformDirection");

	UKismetMathLibrary_TransformDirection_Params params {};
	params.T = T;
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D772D0
//		Name   -> Function Engine.KismetMathLibrary.Today
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FDateTime UKismetMathLibrary::STATIC_Today()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Today");

	UKismetMathLibrary_Today_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D764B0
//		Name   -> Function Engine.KismetMathLibrary.TLerp
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  A                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  B                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UKismetMathLibrary::STATIC_TLerp(const struct FTransform& A, const struct FTransform& B, float Alpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TLerp");

	UKismetMathLibrary_TLerp_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76270
//		Name   -> Function Engine.KismetMathLibrary.TInterpTo
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  Current                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  Target                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UKismetMathLibrary::STATIC_TInterpTo(const struct FTransform& Current, const struct FTransform& Target, float DeltaTime, float InterpSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TInterpTo");

	UKismetMathLibrary_TInterpTo_Params params {};
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D770B0
//		Name   -> Function Engine.KismetMathLibrary.TimespanZeroValue
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_TimespanZeroValue()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanZeroValue");

	UKismetMathLibrary_TimespanZeroValue_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76FF0
//		Name   -> Function Engine.KismetMathLibrary.TimespanRatio
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_TimespanRatio(const struct FTimespan& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanRatio");

	UKismetMathLibrary_TimespanRatio_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76FB0
//		Name   -> Function Engine.KismetMathLibrary.TimespanMinValue
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_TimespanMinValue()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanMinValue");

	UKismetMathLibrary_TimespanMinValue_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76F70
//		Name   -> Function Engine.KismetMathLibrary.TimespanMaxValue
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_TimespanMaxValue()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanMaxValue");

	UKismetMathLibrary_TimespanMaxValue_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76E70
//		Name   -> Function Engine.KismetMathLibrary.TimespanFromString
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     TimespanString                                             (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FTimespan                                   Result                                                     (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_TimespanFromString(const struct FString& TimespanString, struct FTimespan* Result)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanFromString");

	UKismetMathLibrary_TimespanFromString_Params params {};
	params.TimespanString = TimespanString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Result != nullptr)
		*Result = params.Result;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75FB0
//		Name   -> Function Engine.KismetMathLibrary.TEase
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  A                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  B                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EEasingFunc>                    EasingFunc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Steps                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UKismetMathLibrary::STATIC_TEase(const struct FTransform& A, const struct FTransform& B, float Alpha, TEnumAsByte<Engine_EEasingFunc> EasingFunc, float BlendExp, int Steps)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TEase");

	UKismetMathLibrary_TEase_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;
	params.EasingFunc = EasingFunc;
	params.BlendExp = BlendExp;
	params.Steps = Steps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D766B0
//		Name   -> Function Engine.KismetMathLibrary.Tan
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Tan(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Tan");

	UKismetMathLibrary_Tan_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75E10
//		Name   -> Function Engine.KismetMathLibrary.Subtract_VectorVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Subtract_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorVector");

	UKismetMathLibrary_Subtract_VectorVector_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75D30
//		Name   -> Function Engine.KismetMathLibrary.Subtract_VectorInt
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Subtract_VectorInt(const struct FVector& A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorInt");

	UKismetMathLibrary_Subtract_VectorInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75C50
//		Name   -> Function Engine.KismetMathLibrary.Subtract_VectorFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Subtract_VectorFloat(const struct FVector& A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorFloat");

	UKismetMathLibrary_Subtract_VectorFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75B90
//		Name   -> Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_Subtract_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D");

	UKismetMathLibrary_Subtract_Vector2DVector2D_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75AD0
//		Name   -> Function Engine.KismetMathLibrary.Subtract_Vector2DFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_Subtract_Vector2DFloat(const struct FVector2D& A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector2DFloat");

	UKismetMathLibrary_Subtract_Vector2DFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75A10
//		Name   -> Function Engine.KismetMathLibrary.Subtract_TimespanTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_Subtract_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_TimespanTimespan");

	UKismetMathLibrary_Subtract_TimespanTimespan_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75950
//		Name   -> Function Engine.KismetMathLibrary.Subtract_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Subtract_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_IntInt");

	UKismetMathLibrary_Subtract_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75890
//		Name   -> Function Engine.KismetMathLibrary.Subtract_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Subtract_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_FloatFloat");

	UKismetMathLibrary_Subtract_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D757D0
//		Name   -> Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		struct FDateTime                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FDateTime UKismetMathLibrary::STATIC_Subtract_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan");

	UKismetMathLibrary_Subtract_DateTimeTimespan_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75710
//		Name   -> Function Engine.KismetMathLibrary.Subtract_DateTimeDateTime
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_Subtract_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DateTimeDateTime");

	UKismetMathLibrary_Subtract_DateTimeDateTime_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75650
//		Name   -> Function Engine.KismetMathLibrary.Subtract_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
unsigned char UKismetMathLibrary::STATIC_Subtract_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_ByteByte");

	UKismetMathLibrary_Subtract_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D752C0
//		Name   -> Function Engine.KismetMathLibrary.Square
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Square(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Square");

	UKismetMathLibrary_Square_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75240
//		Name   -> Function Engine.KismetMathLibrary.Sqrt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Sqrt(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Sqrt");

	UKismetMathLibrary_Sqrt_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D72990
//		Name   -> Function Engine.KismetMathLibrary.Sin
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Sin(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Sin");

	UKismetMathLibrary_Sin_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D72910
//		Name   -> Function Engine.KismetMathLibrary.SignOfInteger
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_SignOfInteger(int A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfInteger");

	UKismetMathLibrary_SignOfInteger_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D72890
//		Name   -> Function Engine.KismetMathLibrary.SignOfFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_SignOfFloat(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfFloat");

	UKismetMathLibrary_SignOfFloat_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D71A90
//		Name   -> Function Engine.KismetMathLibrary.SetRandomStreamSeed
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRandomStream                               Stream                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                NewSeed                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_SetRandomStreamSeed(struct FRandomStream* Stream, int NewSeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SetRandomStreamSeed");

	UKismetMathLibrary_SetRandomStreamSeed_Params params {};
	params.NewSeed = NewSeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Stream != nullptr)
		*Stream = params.Stream;

}


// Function:
//		Offset -> 0x02D70BA0
//		Name   -> Function Engine.KismetMathLibrary.SelectVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_SelectVector(const struct FVector& A, const struct FVector& B, bool bPickA)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectVector");

	UKismetMathLibrary_SelectVector_Params params {};
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D709A0
//		Name   -> Function Engine.KismetMathLibrary.SelectTransform
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  A                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  B                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UKismetMathLibrary::STATIC_SelectTransform(const struct FTransform& A, const struct FTransform& B, bool bPickA)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectTransform");

	UKismetMathLibrary_SelectTransform_Params params {};
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D70810
//		Name   -> Function Engine.KismetMathLibrary.SelectString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     A                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     B                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetMathLibrary::STATIC_SelectString(const struct FString& A, const struct FString& B, bool bPickA)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectString");

	UKismetMathLibrary_SelectString_Params params {};
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D706D0
//		Name   -> Function Engine.KismetMathLibrary.SelectRotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_SelectRotator(const struct FRotator& A, const struct FRotator& B, bool bPickA)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectRotator");

	UKismetMathLibrary_SelectRotator_Params params {};
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D705D0
//		Name   -> Function Engine.KismetMathLibrary.SelectObject
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UObject*                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSelectA                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UObject*                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UObject* UKismetMathLibrary::STATIC_SelectObject(class UObject* A, class UObject* B, bool bSelectA)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectObject");

	UKismetMathLibrary_SelectObject_Params params {};
	params.A = A;
	params.B = B;
	params.bSelectA = bSelectA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D704E0
//		Name   -> Function Engine.KismetMathLibrary.SelectInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_SelectInt(int A, int B, bool bPickA)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectInt");

	UKismetMathLibrary_SelectInt_Params params {};
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D703E0
//		Name   -> Function Engine.KismetMathLibrary.SelectFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_SelectFloat(float A, float B, bool bPickA)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectFloat");

	UKismetMathLibrary_SelectFloat_Params params {};
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D702B0
//		Name   -> Function Engine.KismetMathLibrary.SelectColor
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_SelectColor(const struct FLinearColor& A, const struct FLinearColor& B, bool bPickA)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectColor");

	UKismetMathLibrary_SelectColor_Params params {};
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D701B0
//		Name   -> Function Engine.KismetMathLibrary.SelectClass
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSelectA                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UClass* UKismetMathLibrary::STATIC_SelectClass(class UClass* A, class UClass* B, bool bSelectA)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectClass");

	UKismetMathLibrary_SelectClass_Params params {};
	params.A = A;
	params.B = B;
	params.bSelectA = bSelectA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D70130
//		Name   -> Function Engine.KismetMathLibrary.SeedRandomStream
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRandomStream                               Stream                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm)
void UKismetMathLibrary::STATIC_SeedRandomStream(struct FRandomStream* Stream)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SeedRandomStream");

	UKismetMathLibrary_SeedRandomStream_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Stream != nullptr)
		*Stream = params.Stream;

}


// Function:
//		Offset -> 0x02D700B0
//		Name   -> Function Engine.KismetMathLibrary.Round
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Round(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Round");

	UKismetMathLibrary_Round_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6FFD0
//		Name   -> Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Axis                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_RotatorFromAxisAndAngle(const struct FVector& Axis, float Angle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle");

	UKismetMathLibrary_RotatorFromAxisAndAngle_Params params {};
	params.Axis = Axis;
	params.Angle = Angle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6FE90
//		Name   -> Function Engine.KismetMathLibrary.RotateAngleAxis
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     InVect                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              AngleDeg                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Axis                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_RotateAngleAxis(const struct FVector& InVect, float AngleDeg, const struct FVector& Axis)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RotateAngleAxis");

	UKismetMathLibrary_RotateAngleAxis_Params params {};
	params.InVect = InVect;
	params.AngleDeg = AngleDeg;
	params.Axis = Axis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6DB20
//		Name   -> Function Engine.KismetMathLibrary.RLerp
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bShortestPath                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_RLerp(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RLerp");

	UKismetMathLibrary_RLerp_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;
	params.bShortestPath = bShortestPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6D980
//		Name   -> Function Engine.KismetMathLibrary.RInterpTo_Constant
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_RInterpTo_Constant(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo_Constant");

	UKismetMathLibrary_RInterpTo_Constant_Params params {};
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6D7E0
//		Name   -> Function Engine.KismetMathLibrary.RInterpTo
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_RInterpTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo");

	UKismetMathLibrary_RInterpTo_Params params {};
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6D720
//		Name   -> Function Engine.KismetMathLibrary.RGBToHSV_Vector
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                RGB                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                HSV                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetMathLibrary::STATIC_RGBToHSV_Vector(const struct FLinearColor& RGB, struct FLinearColor* HSV)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBToHSV_Vector");

	UKismetMathLibrary_RGBToHSV_Vector_Params params {};
	params.RGB = RGB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HSV != nullptr)
		*HSV = params.HSV;

}


// Function:
//		Offset -> 0x02D6D530
//		Name   -> Function Engine.KismetMathLibrary.RGBToHSV
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                InColor                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              H                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              S                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              V                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              A                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_RGBToHSV(const struct FLinearColor& InColor, float* H, float* S, float* V, float* A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBToHSV");

	UKismetMathLibrary_RGBToHSV_Params params {};
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (H != nullptr)
		*H = params.H;
	if (S != nullptr)
		*S = params.S;
	if (V != nullptr)
		*V = params.V;
	if (A != nullptr)
		*A = params.A;

}


// Function:
//		Offset -> 0x02D6ED50
//		Name   -> Function Engine.KismetMathLibrary.ResetRandomStream
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
void UKismetMathLibrary::STATIC_ResetRandomStream(const struct FRandomStream& Stream)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetRandomStream");

	UKismetMathLibrary_ResetRandomStream_Params params {};
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6D300
//		Name   -> Function Engine.KismetMathLibrary.REase
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bShortestPath                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EEasingFunc>                    EasingFunc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Steps                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_REase(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath, TEnumAsByte<Engine_EEasingFunc> EasingFunc, float BlendExp, int Steps)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.REase");

	UKismetMathLibrary_REase_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;
	params.bShortestPath = bShortestPath;
	params.EasingFunc = EasingFunc;
	params.BlendExp = BlendExp;
	params.Steps = Steps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E7E0
//		Name   -> Function Engine.KismetMathLibrary.RandomUnitVectorInConeWithYawAndPitch
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     ConeDir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              MaxYawInDegrees                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MaxPitchInDegrees                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_RandomUnitVectorInConeWithYawAndPitch(const struct FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeWithYawAndPitch");

	UKismetMathLibrary_RandomUnitVectorInConeWithYawAndPitch_Params params {};
	params.ConeDir = ConeDir;
	params.MaxYawInDegrees = MaxYawInDegrees;
	params.MaxPitchInDegrees = MaxPitchInDegrees;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E700
//		Name   -> Function Engine.KismetMathLibrary.RandomUnitVectorInCone
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     ConeDir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ConeHalfAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_RandomUnitVectorInCone(const struct FVector& ConeDir, float ConeHalfAngle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInCone");

	UKismetMathLibrary_RandomUnitVectorInCone_Params params {};
	params.ConeDir = ConeDir;
	params.ConeHalfAngle = ConeHalfAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E660
//		Name   -> Function Engine.KismetMathLibrary.RandomUnitVectorFromStream
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_RandomUnitVectorFromStream(const struct FRandomStream& Stream)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorFromStream");

	UKismetMathLibrary_RandomUnitVectorFromStream_Params params {};
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E620
//		Name   -> Function Engine.KismetMathLibrary.RandomUnitVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_RandomUnitVector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVector");

	UKismetMathLibrary_RandomUnitVector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E540
//		Name   -> Function Engine.KismetMathLibrary.RandomRotatorFromStream
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               bRoll                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_RandomRotatorFromStream(bool bRoll, const struct FRandomStream& Stream)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomRotatorFromStream");

	UKismetMathLibrary_RandomRotatorFromStream_Params params {};
	params.bRoll = bRoll;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E4A0
//		Name   -> Function Engine.KismetMathLibrary.RandomRotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               bRoll                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_RandomRotator(bool bRoll)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomRotator");

	UKismetMathLibrary_RandomRotator_Params params {};
	params.bRoll = bRoll;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E3A0
//		Name   -> Function Engine.KismetMathLibrary.RandomPointInBoundingBox
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     BoxExtent                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_RandomPointInBoundingBox(const struct FVector& Origin, const struct FVector& BoxExtent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomPointInBoundingBox");

	UKismetMathLibrary_RandomPointInBoundingBox_Params params {};
	params.Origin = Origin;
	params.BoxExtent = BoxExtent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E2A0
//		Name   -> Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_RandomIntegerInRangeFromStream(int Min, int Max, const struct FRandomStream& Stream)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream");

	UKismetMathLibrary_RandomIntegerInRangeFromStream_Params params {};
	params.Min = Min;
	params.Max = Max;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E1E0
//		Name   -> Function Engine.KismetMathLibrary.RandomIntegerInRange
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_RandomIntegerInRange(int Min, int Max)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerInRange");

	UKismetMathLibrary_RandomIntegerInRange_Params params {};
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E110
//		Name   -> Function Engine.KismetMathLibrary.RandomIntegerFromStream
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_RandomIntegerFromStream(int Max, const struct FRandomStream& Stream)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerFromStream");

	UKismetMathLibrary_RandomIntegerFromStream_Params params {};
	params.Max = Max;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E090
//		Name   -> Function Engine.KismetMathLibrary.RandomInteger
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_RandomInteger(int Max)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger");

	UKismetMathLibrary_RandomInteger_Params params {};
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6DF80
//		Name   -> Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_RandomFloatInRangeFromStream(float Min, float Max, const struct FRandomStream& Stream)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream");

	UKismetMathLibrary_RandomFloatInRangeFromStream_Params params {};
	params.Min = Min;
	params.Max = Max;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6DEC0
//		Name   -> Function Engine.KismetMathLibrary.RandomFloatInRange
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_RandomFloatInRange(float Min, float Max)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatInRange");

	UKismetMathLibrary_RandomFloatInRange_Params params {};
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6DE30
//		Name   -> Function Engine.KismetMathLibrary.RandomFloatFromStream
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_RandomFloatFromStream(const struct FRandomStream& Stream)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatFromStream");

	UKismetMathLibrary_RandomFloatFromStream_Params params {};
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6DE00
//		Name   -> Function Engine.KismetMathLibrary.RandomFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_RandomFloat()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloat");

	UKismetMathLibrary_RandomFloat_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6DD70
//		Name   -> Function Engine.KismetMathLibrary.RandomBoolFromStream
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_RandomBoolFromStream(const struct FRandomStream& Stream)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolFromStream");

	UKismetMathLibrary_RandomBoolFromStream_Params params {};
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6DD40
//		Name   -> Function Engine.KismetMathLibrary.RandomBool
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_RandomBool()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBool");

	UKismetMathLibrary_RandomBool_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6DCC0
//		Name   -> Function Engine.KismetMathLibrary.RadiansToDegrees
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_RadiansToDegrees(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RadiansToDegrees");

	UKismetMathLibrary_RadiansToDegrees_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6D110
//		Name   -> Function Engine.KismetMathLibrary.ProjectVectorOnToVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     V                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_ProjectVectorOnToVector(const struct FVector& V, const struct FVector& Target)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectVectorOnToVector");

	UKismetMathLibrary_ProjectVectorOnToVector_Params params {};
	params.V = V;
	params.Target = Target;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6D020
//		Name   -> Function Engine.KismetMathLibrary.ProjectVectorOnToPlane
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     V                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     PlaneNormal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_ProjectVectorOnToPlane(const struct FVector& V, const struct FVector& PlaneNormal)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectVectorOnToPlane");

	UKismetMathLibrary_ProjectVectorOnToPlane_Params params {};
	params.V = V;
	params.PlaneNormal = PlaneNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6CEE0
//		Name   -> Function Engine.KismetMathLibrary.ProjectPointOnToPlane
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Point                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     PlaneBase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     PlaneNormal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_ProjectPointOnToPlane(const struct FVector& Point, const struct FVector& PlaneBase, const struct FVector& PlaneNormal)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectPointOnToPlane");

	UKismetMathLibrary_ProjectPointOnToPlane_Params params {};
	params.Point = Point;
	params.PlaneBase = PlaneBase;
	params.PlaneNormal = PlaneNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6C950
//		Name   -> Function Engine.KismetMathLibrary.PointsAreCoplanar
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<struct FVector>                             Points                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_PointsAreCoplanar(TArray<struct FVector> Points, float Tolerance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.PointsAreCoplanar");

	UKismetMathLibrary_PointsAreCoplanar_Params params {};
	params.Points = Points;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6BBE0
//		Name   -> Function Engine.KismetMathLibrary.Percent_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Percent_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_IntInt");

	UKismetMathLibrary_Percent_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6BB20
//		Name   -> Function Engine.KismetMathLibrary.Percent_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Percent_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_FloatFloat");

	UKismetMathLibrary_Percent_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6BA60
//		Name   -> Function Engine.KismetMathLibrary.Percent_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
unsigned char UKismetMathLibrary::STATIC_Percent_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_ByteByte");

	UKismetMathLibrary_Percent_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6B6C0
//		Name   -> Function Engine.KismetMathLibrary.Or_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Or_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Or_IntInt");

	UKismetMathLibrary_Or_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6B5F0
//		Name   -> Function Engine.KismetMathLibrary.Now
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FDateTime UKismetMathLibrary::STATIC_Now()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Now");

	UKismetMathLibrary_Now_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6B450
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_VectorVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ErrorTolerance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_VectorVector");

	UKismetMathLibrary_NotEqual_VectorVector_Params params {};
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6B390
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan");

	UKismetMathLibrary_NotEqual_TimespanTimespan_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6AF50
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_RotatorRotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ErrorTolerance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_RotatorRotator");

	UKismetMathLibrary_NotEqual_RotatorRotator_Params params {};
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6AE90
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_ObjectObject
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UObject*                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_ObjectObject(class UObject* A, class UObject* B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ObjectObject");

	UKismetMathLibrary_NotEqual_ObjectObject_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6ADD0
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_NameName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_NameName(const struct FName& A, const struct FName& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_NameName");

	UKismetMathLibrary_NotEqual_NameName_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6AD10
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_IntInt");

	UKismetMathLibrary_NotEqual_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6AA30
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_FloatFloat");

	UKismetMathLibrary_NotEqual_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A980
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime");

	UKismetMathLibrary_NotEqual_DateTimeDateTime_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A8C0
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_ClassClass
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_ClassClass(class UClass* A, class UClass* B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ClassClass");

	UKismetMathLibrary_NotEqual_ClassClass_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A800
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ByteByte");

	UKismetMathLibrary_NotEqual_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A730
//		Name   -> Function Engine.KismetMathLibrary.NotEqual_BoolBool
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NotEqual_BoolBool(bool A, bool B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_BoolBool");

	UKismetMathLibrary_NotEqual_BoolBool_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6B570
//		Name   -> Function Engine.KismetMathLibrary.Not_PreBool
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Not_PreBool(bool A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_PreBool");

	UKismetMathLibrary_Not_PreBool_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A530
//		Name   -> Function Engine.KismetMathLibrary.NormalizeToRange
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              RangeMin                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              RangeMax                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_NormalizeToRange(float Value, float RangeMin, float RangeMax)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizeToRange");

	UKismetMathLibrary_NormalizeToRange_Params params {};
	params.Value = Value;
	params.RangeMin = RangeMin;
	params.RangeMax = RangeMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A640
//		Name   -> Function Engine.KismetMathLibrary.NormalizedDeltaRotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_NormalizedDeltaRotator(const struct FRotator& A, const struct FRotator& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizedDeltaRotator");

	UKismetMathLibrary_NormalizedDeltaRotator_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A4B0
//		Name   -> Function Engine.KismetMathLibrary.NormalizeAxis
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_NormalizeAxis(float Angle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizeAxis");

	UKismetMathLibrary_NormalizeAxis_Params params {};
	params.Angle = Angle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A390
//		Name   -> Function Engine.KismetMathLibrary.Normal2D
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_Normal2D(const struct FVector2D& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normal2D");

	UKismetMathLibrary_Normal2D_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A410
//		Name   -> Function Engine.KismetMathLibrary.Normal
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Normal(const struct FVector& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normal");

	UKismetMathLibrary_Normal_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A2B0
//		Name   -> Function Engine.KismetMathLibrary.NegateVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_NegateVector(const struct FVector& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NegateVector");

	UKismetMathLibrary_NegateVector_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6A210
//		Name   -> Function Engine.KismetMathLibrary.NegateRotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_NegateRotator(const struct FRotator& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NegateRotator");

	UKismetMathLibrary_NegateRotator_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69FD0
//		Name   -> Function Engine.KismetMathLibrary.NearlyEqual_TransformTransform
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  A                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  B                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              LocationTolerance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              RotationTolerance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Scale3DTolerance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NearlyEqual_TransformTransform(const struct FTransform& A, const struct FTransform& B, float LocationTolerance, float RotationTolerance, float Scale3DTolerance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_TransformTransform");

	UKismetMathLibrary_NearlyEqual_TransformTransform_Params params {};
	params.A = A;
	params.B = B;
	params.LocationTolerance = LocationTolerance;
	params.RotationTolerance = RotationTolerance;
	params.Scale3DTolerance = Scale3DTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69EC0
//		Name   -> Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ErrorTolerance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_NearlyEqual_FloatFloat(float A, float B, float ErrorTolerance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat");

	UKismetMathLibrary_NearlyEqual_FloatFloat_Params params {};
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69360
//		Name   -> Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Base                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Exp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_MultiplyMultiply_FloatFloat(float Base, float Exp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat");

	UKismetMathLibrary_MultiplyMultiply_FloatFloat_Params params {};
	params.Base = Base;
	params.Exp = Exp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D692E0
//		Name   -> Function Engine.KismetMathLibrary.MultiplyByPi
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_MultiplyByPi(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyByPi");

	UKismetMathLibrary_MultiplyByPi_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69DD0
//		Name   -> Function Engine.KismetMathLibrary.Multiply_VectorVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Multiply_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorVector");

	UKismetMathLibrary_Multiply_VectorVector_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69CF0
//		Name   -> Function Engine.KismetMathLibrary.Multiply_VectorInt
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Multiply_VectorInt(const struct FVector& A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorInt");

	UKismetMathLibrary_Multiply_VectorInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69C10
//		Name   -> Function Engine.KismetMathLibrary.Multiply_VectorFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Multiply_VectorFloat(const struct FVector& A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorFloat");

	UKismetMathLibrary_Multiply_VectorFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69B50
//		Name   -> Function Engine.KismetMathLibrary.Multiply_Vector2DFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_Multiply_Vector2DFloat(const struct FVector2D& A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector2DFloat");

	UKismetMathLibrary_Multiply_Vector2DFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69A90
//		Name   -> Function Engine.KismetMathLibrary.Multiply_TimespanFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		float                                              Scalar                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_Multiply_TimespanFloat(const struct FTimespan& A, float Scalar)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_TimespanFloat");

	UKismetMathLibrary_Multiply_TimespanFloat_Params params {};
	params.A = A;
	params.Scalar = Scalar;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D699B0
//		Name   -> Function Engine.KismetMathLibrary.Multiply_RotatorInt
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_Multiply_RotatorInt(const struct FRotator& A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_RotatorInt");

	UKismetMathLibrary_Multiply_RotatorInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D698D0
//		Name   -> Function Engine.KismetMathLibrary.Multiply_RotatorFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_Multiply_RotatorFloat(const struct FRotator& A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_RotatorFloat");

	UKismetMathLibrary_Multiply_RotatorFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69800
//		Name   -> Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_Multiply_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor");

	UKismetMathLibrary_Multiply_LinearColorLinearColor_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69730
//		Name   -> Function Engine.KismetMathLibrary.Multiply_LinearColorFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_Multiply_LinearColorFloat(const struct FLinearColor& A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_LinearColorFloat");

	UKismetMathLibrary_Multiply_LinearColorFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69670
//		Name   -> Function Engine.KismetMathLibrary.Multiply_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Multiply_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntInt");

	UKismetMathLibrary_Multiply_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D695A0
//		Name   -> Function Engine.KismetMathLibrary.Multiply_IntFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Multiply_IntFloat(int A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntFloat");

	UKismetMathLibrary_Multiply_IntFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D694E0
//		Name   -> Function Engine.KismetMathLibrary.Multiply_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Multiply_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_FloatFloat");

	UKismetMathLibrary_Multiply_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D69420
//		Name   -> Function Engine.KismetMathLibrary.Multiply_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
unsigned char UKismetMathLibrary::STATIC_Multiply_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_ByteByte");

	UKismetMathLibrary_Multiply_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D68F60
//		Name   -> Function Engine.KismetMathLibrary.MirrorVectorByNormal
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     InVect                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     InNormal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_MirrorVectorByNormal(const struct FVector& InVect, const struct FVector& InNormal)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MirrorVectorByNormal");

	UKismetMathLibrary_MirrorVectorByNormal_Params params {};
	params.InVect = InVect;
	params.InNormal = InNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D68B40
//		Name   -> Function Engine.KismetMathLibrary.MinOfIntArray
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<int>                                        IntArray                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                IndexOfMinValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                MinValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_MinOfIntArray(TArray<int> IntArray, int* IndexOfMinValue, int* MinValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfIntArray");

	UKismetMathLibrary_MinOfIntArray_Params params {};
	params.IntArray = IntArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = params.IndexOfMinValue;
	if (MinValue != nullptr)
		*MinValue = params.MinValue;

}


// Function:
//		Offset -> 0x02D689F0
//		Name   -> Function Engine.KismetMathLibrary.MinOfFloatArray
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<float>                                      FloatArray                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                IndexOfMinValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MinValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_MinOfFloatArray(TArray<float> FloatArray, int* IndexOfMinValue, float* MinValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfFloatArray");

	UKismetMathLibrary_MinOfFloatArray_Params params {};
	params.FloatArray = FloatArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = params.IndexOfMinValue;
	if (MinValue != nullptr)
		*MinValue = params.MinValue;

}


// Function:
//		Offset -> 0x02D688A0
//		Name   -> Function Engine.KismetMathLibrary.MinOfByteArray
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<unsigned char>                              ByteArray                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                IndexOfMinValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      MinValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_MinOfByteArray(TArray<unsigned char> ByteArray, int* IndexOfMinValue, unsigned char* MinValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfByteArray");

	UKismetMathLibrary_MinOfByteArray_Params params {};
	params.ByteArray = ByteArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = params.IndexOfMinValue;
	if (MinValue != nullptr)
		*MinValue = params.MinValue;

}


// Function:
//		Offset -> 0x02D68C90
//		Name   -> Function Engine.KismetMathLibrary.MinimumAreaRectangle
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FVector>                             InVerts                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		struct FVector                                     SampleSurfaceNormal                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     OutRectCenter                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    OutRectRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              OutSideLengthX                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OutSideLengthY                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bDebugDraw                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetMathLibrary::STATIC_MinimumAreaRectangle(class UObject* WorldContextObject, TArray<struct FVector> InVerts, const struct FVector& SampleSurfaceNormal, struct FVector* OutRectCenter, struct FRotator* OutRectRotation, float* OutSideLengthX, float* OutSideLengthY, bool bDebugDraw)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinimumAreaRectangle");

	UKismetMathLibrary_MinimumAreaRectangle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.InVerts = InVerts;
	params.SampleSurfaceNormal = SampleSurfaceNormal;
	params.bDebugDraw = bDebugDraw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutRectCenter != nullptr)
		*OutRectCenter = params.OutRectCenter;
	if (OutRectRotation != nullptr)
		*OutRectRotation = params.OutRectRotation;
	if (OutSideLengthX != nullptr)
		*OutSideLengthX = params.OutSideLengthX;
	if (OutSideLengthY != nullptr)
		*OutSideLengthY = params.OutSideLengthY;

}


// Function:
//		Offset -> 0x02D687E0
//		Name   -> Function Engine.KismetMathLibrary.Min
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Min(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Min");

	UKismetMathLibrary_Min_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D682A0
//		Name   -> Function Engine.KismetMathLibrary.MaxOfIntArray
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<int>                                        IntArray                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                IndexOfMaxValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                MaxValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_MaxOfIntArray(TArray<int> IntArray, int* IndexOfMaxValue, int* MaxValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfIntArray");

	UKismetMathLibrary_MaxOfIntArray_Params params {};
	params.IntArray = IntArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = params.IndexOfMaxValue;
	if (MaxValue != nullptr)
		*MaxValue = params.MaxValue;

}


// Function:
//		Offset -> 0x02D68150
//		Name   -> Function Engine.KismetMathLibrary.MaxOfFloatArray
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<float>                                      FloatArray                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                IndexOfMaxValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MaxValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_MaxOfFloatArray(TArray<float> FloatArray, int* IndexOfMaxValue, float* MaxValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfFloatArray");

	UKismetMathLibrary_MaxOfFloatArray_Params params {};
	params.FloatArray = FloatArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = params.IndexOfMaxValue;
	if (MaxValue != nullptr)
		*MaxValue = params.MaxValue;

}


// Function:
//		Offset -> 0x02D68000
//		Name   -> Function Engine.KismetMathLibrary.MaxOfByteArray
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<unsigned char>                              ByteArray                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                IndexOfMaxValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      MaxValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_MaxOfByteArray(TArray<unsigned char> ByteArray, int* IndexOfMaxValue, unsigned char* MaxValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfByteArray");

	UKismetMathLibrary_MaxOfByteArray_Params params {};
	params.ByteArray = ByteArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = params.IndexOfMaxValue;
	if (MaxValue != nullptr)
		*MaxValue = params.MaxValue;

}


// Function:
//		Offset -> 0x02D67F40
//		Name   -> Function Engine.KismetMathLibrary.Max
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Max(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Max");

	UKismetMathLibrary_Max_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D679D0
//		Name   -> Function Engine.KismetMathLibrary.MapRangeUnclamped
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InRangeA                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InRangeB                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OutRangeA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OutRangeB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_MapRangeUnclamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MapRangeUnclamped");

	UKismetMathLibrary_MapRangeUnclamped_Params params {};
	params.Value = Value;
	params.InRangeA = InRangeA;
	params.InRangeB = InRangeB;
	params.OutRangeA = OutRangeA;
	params.OutRangeB = OutRangeB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D67830
//		Name   -> Function Engine.KismetMathLibrary.MapRangeClamped
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InRangeA                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InRangeB                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OutRangeA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              OutRangeB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_MapRangeClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MapRangeClamped");

	UKismetMathLibrary_MapRangeClamped_Params params {};
	params.Value = Value;
	params.InRangeA = InRangeA;
	params.InRangeB = InRangeB;
	params.OutRangeA = OutRangeA;
	params.OutRangeB = OutRangeB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D67640
//		Name   -> Function Engine.KismetMathLibrary.MakeVector2D
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_MakeVector2D(float X, float Y)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector2D");

	UKismetMathLibrary_MakeVector2D_Params params {};
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D67710
//		Name   -> Function Engine.KismetMathLibrary.MakeVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_MakeVector(float X, float Y, float Z)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector");

	UKismetMathLibrary_MakeVector_Params params {};
	params.X = X;
	params.Y = Y;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D674D0
//		Name   -> Function Engine.KismetMathLibrary.MakeTransform
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UKismetMathLibrary::STATIC_MakeTransform(const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTransform");

	UKismetMathLibrary_MakeTransform_Params params {};
	params.Location = Location;
	params.Rotation = Rotation;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D67350
//		Name   -> Function Engine.KismetMathLibrary.MakeTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Days                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Hours                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Minutes                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Milliseconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_MakeTimespan(int Days, int Hours, int Minutes, int Seconds, int Milliseconds)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTimespan");

	UKismetMathLibrary_MakeTimespan_Params params {};
	params.Days = Days;
	params.Hours = Hours;
	params.Minutes = Minutes;
	params.Seconds = Seconds;
	params.Milliseconds = Milliseconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66FF0
//		Name   -> Function Engine.KismetMathLibrary.MakeRotFromZY
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Z                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Y                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotFromZY(const struct FVector& Z, const struct FVector& Y)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZY");

	UKismetMathLibrary_MakeRotFromZY_Params params {};
	params.Z = Z;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66EF0
//		Name   -> Function Engine.KismetMathLibrary.MakeRotFromZX
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Z                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     X                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotFromZX(const struct FVector& Z, const struct FVector& X)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZX");

	UKismetMathLibrary_MakeRotFromZX_Params params {};
	params.Z = Z;
	params.X = X;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66E50
//		Name   -> Function Engine.KismetMathLibrary.MakeRotFromZ
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Z                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotFromZ(const struct FVector& Z)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZ");

	UKismetMathLibrary_MakeRotFromZ_Params params {};
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66D50
//		Name   -> Function Engine.KismetMathLibrary.MakeRotFromYZ
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Y                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Z                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotFromYZ(const struct FVector& Y, const struct FVector& Z)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromYZ");

	UKismetMathLibrary_MakeRotFromYZ_Params params {};
	params.Y = Y;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66C50
//		Name   -> Function Engine.KismetMathLibrary.MakeRotFromYX
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Y                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     X                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotFromYX(const struct FVector& Y, const struct FVector& X)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromYX");

	UKismetMathLibrary_MakeRotFromYX_Params params {};
	params.Y = Y;
	params.X = X;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66BB0
//		Name   -> Function Engine.KismetMathLibrary.MakeRotFromY
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Y                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotFromY(const struct FVector& Y)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromY");

	UKismetMathLibrary_MakeRotFromY_Params params {};
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66AB0
//		Name   -> Function Engine.KismetMathLibrary.MakeRotFromXZ
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     X                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Z                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotFromXZ(const struct FVector& X, const struct FVector& Z)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromXZ");

	UKismetMathLibrary_MakeRotFromXZ_Params params {};
	params.X = X;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D669B0
//		Name   -> Function Engine.KismetMathLibrary.MakeRotFromXY
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     X                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Y                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotFromXY(const struct FVector& X, const struct FVector& Y)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromXY");

	UKismetMathLibrary_MakeRotFromXY_Params params {};
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66910
//		Name   -> Function Engine.KismetMathLibrary.MakeRotFromX
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     X                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotFromX(const struct FVector& X)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromX");

	UKismetMathLibrary_MakeRotFromX_Params params {};
	params.X = X;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D67230
//		Name   -> Function Engine.KismetMathLibrary.MakeRotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Roll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotator(float Roll, float Pitch, float Yaw)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotator");

	UKismetMathLibrary_MakeRotator_Params params {};
	params.Roll = Roll;
	params.Pitch = Pitch;
	params.Yaw = Yaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D670F0
//		Name   -> Function Engine.KismetMathLibrary.MakeRotationFromAxes
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Forward                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Right                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Up                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_MakeRotationFromAxes(const struct FVector& Forward, const struct FVector& Right, const struct FVector& Up)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotationFromAxes");

	UKismetMathLibrary_MakeRotationFromAxes_Params params {};
	params.Forward = Forward;
	params.Right = Right;
	params.Up = Up;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66880
//		Name   -> Function Engine.KismetMathLibrary.MakeRandomStream
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                InitialSeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRandomStream                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FRandomStream UKismetMathLibrary::STATIC_MakeRandomStream(int InitialSeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRandomStream");

	UKismetMathLibrary_MakeRandomStream_Params params {};
	params.InitialSeed = InitialSeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66770
//		Name   -> Function Engine.KismetMathLibrary.MakePulsatingValue
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              InCurrentTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InPulsesPerSecond                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InPhase                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_MakePulsatingValue(float InCurrentTime, float InPulsesPerSecond, float InPhase)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakePulsatingValue");

	UKismetMathLibrary_MakePulsatingValue_Params params {};
	params.InCurrentTime = InCurrentTime;
	params.InPulsesPerSecond = InPulsesPerSecond;
	params.InPhase = InPhase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66130
//		Name   -> Function Engine.KismetMathLibrary.MakeDateTime
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Year                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Month                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Day                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Hour                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                Minute                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                Second                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                Millisecond                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FDateTime                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FDateTime UKismetMathLibrary::STATIC_MakeDateTime(int Year, int Month, int Day, int Hour, int Minute, int Second, int Millisecond)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeDateTime");

	UKismetMathLibrary_MakeDateTime_Params params {};
	params.Year = Year;
	params.Month = Month;
	params.Day = Day;
	params.Hour = Hour;
	params.Minute = Minute;
	params.Second = Second;
	params.Millisecond = Millisecond;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D65FD0
//		Name   -> Function Engine.KismetMathLibrary.MakeColor
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              R                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              G                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_MakeColor(float R, float G, float B, float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeColor");

	UKismetMathLibrary_MakeColor_Params params {};
	params.R = R;
	params.G = G;
	params.B = B;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D65F50
//		Name   -> Function Engine.KismetMathLibrary.Loge
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Loge(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Loge");

	UKismetMathLibrary_Loge_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D63910
//		Name   -> Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     LineStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     LineEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     PlaneOrigin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     PlaneNormal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              T                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Intersection                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_LinePlaneIntersection_OriginNormal(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& PlaneOrigin, const struct FVector& PlaneNormal, float* T, struct FVector* Intersection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal");

	UKismetMathLibrary_LinePlaneIntersection_OriginNormal_Params params {};
	params.LineStart = LineStart;
	params.LineEnd = LineEnd;
	params.PlaneOrigin = PlaneOrigin;
	params.PlaneNormal = PlaneNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (T != nullptr)
		*T = params.T;
	if (Intersection != nullptr)
		*Intersection = params.Intersection;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D63720
//		Name   -> Function Engine.KismetMathLibrary.LinePlaneIntersection
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     LineStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     LineEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FPlane                                      APlane                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              T                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Intersection                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_LinePlaneIntersection(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FPlane& APlane, float* T, struct FVector* Intersection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinePlaneIntersection");

	UKismetMathLibrary_LinePlaneIntersection_Params params {};
	params.LineStart = LineStart;
	params.LineEnd = LineEnd;
	params.APlane = APlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (T != nullptr)
		*T = params.T;
	if (Intersection != nullptr)
		*Intersection = params.Intersection;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D655B0
//		Name   -> Function Engine.KismetMathLibrary.LinearColorLerpUsingHSV
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_LinearColorLerpUsingHSV(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColorLerpUsingHSV");

	UKismetMathLibrary_LinearColorLerpUsingHSV_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D65490
//		Name   -> Function Engine.KismetMathLibrary.LinearColorLerp
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_LinearColorLerp(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColorLerp");

	UKismetMathLibrary_LinearColorLerp_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D63280
//		Name   -> Function Engine.KismetMathLibrary.LessLess_VectorRotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_LessLess_VectorRotator(const struct FVector& A, const struct FRotator& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessLess_VectorRotator");

	UKismetMathLibrary_LessLess_VectorRotator_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D631C0
//		Name   -> Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_LessEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan");

	UKismetMathLibrary_LessEqual_TimespanTimespan_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D63100
//		Name   -> Function Engine.KismetMathLibrary.LessEqual_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_LessEqual_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_IntInt");

	UKismetMathLibrary_LessEqual_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D63040
//		Name   -> Function Engine.KismetMathLibrary.LessEqual_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_LessEqual_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_FloatFloat");

	UKismetMathLibrary_LessEqual_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62F90
//		Name   -> Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_LessEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime");

	UKismetMathLibrary_LessEqual_DateTimeDateTime_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62ED0
//		Name   -> Function Engine.KismetMathLibrary.LessEqual_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_LessEqual_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_ByteByte");

	UKismetMathLibrary_LessEqual_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D63660
//		Name   -> Function Engine.KismetMathLibrary.Less_TimespanTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Less_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_TimespanTimespan");

	UKismetMathLibrary_Less_TimespanTimespan_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D635A0
//		Name   -> Function Engine.KismetMathLibrary.Less_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Less_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_IntInt");

	UKismetMathLibrary_Less_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D634E0
//		Name   -> Function Engine.KismetMathLibrary.Less_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Less_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_FloatFloat");

	UKismetMathLibrary_Less_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D63430
//		Name   -> Function Engine.KismetMathLibrary.Less_DateTimeDateTime
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Less_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_DateTimeDateTime");

	UKismetMathLibrary_Less_DateTimeDateTime_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D63370
//		Name   -> Function Engine.KismetMathLibrary.Less_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Less_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_ByteByte");

	UKismetMathLibrary_Less_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62DC0
//		Name   -> Function Engine.KismetMathLibrary.Lerp
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Lerp(float A, float B, float Alpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Lerp");

	UKismetMathLibrary_Lerp_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5F230
//		Name   -> Function Engine.KismetMathLibrary.IsPointInBox
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Point                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FBox                                        Box                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_IsPointInBox(const struct FVector& Point, const struct FBox& Box)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsPointInBox");

	UKismetMathLibrary_IsPointInBox_Params params {};
	params.Point = Point;
	params.Box = Box;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5EF70
//		Name   -> Function Engine.KismetMathLibrary.IsMorning
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_IsMorning(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsMorning");

	UKismetMathLibrary_IsMorning_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5EE70
//		Name   -> Function Engine.KismetMathLibrary.IsLeapYear
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Year                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_IsLeapYear(int Year)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsLeapYear");

	UKismetMathLibrary_IsLeapYear_Params params {};
	params.Year = Year;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5ECD0
//		Name   -> Function Engine.KismetMathLibrary.IsAfternoon
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_IsAfternoon(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsAfternoon");

	UKismetMathLibrary_IsAfternoon_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5EBB0
//		Name   -> Function Engine.KismetMathLibrary.InvertTransform
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  T                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UKismetMathLibrary::STATIC_InvertTransform(const struct FTransform& T)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InvertTransform");

	UKismetMathLibrary_InvertTransform_Params params {};
	params.T = T;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5EA30
//		Name   -> Function Engine.KismetMathLibrary.InverseTransformLocation
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  T                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_InverseTransformLocation(const struct FTransform& T, const struct FVector& Location)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformLocation");

	UKismetMathLibrary_InverseTransformLocation_Params params {};
	params.T = T;
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E8D0
//		Name   -> Function Engine.KismetMathLibrary.InverseTransformDirection
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  T                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_InverseTransformDirection(const struct FTransform& T, const struct FVector& Direction)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformDirection");

	UKismetMathLibrary_InverseTransformDirection_Params params {};
	params.T = T;
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5E7C0
//		Name   -> Function Engine.KismetMathLibrary.InverseLerp
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_InverseLerp(float A, float B, float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseLerp");

	UKismetMathLibrary_InverseLerp_Params params {};
	params.A = A;
	params.B = B;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5DBD0
//		Name   -> Function Engine.KismetMathLibrary.InRange_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               InclusiveMin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               InclusiveMax                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_InRange_FloatFloat(float Value, float Min, float Max, bool InclusiveMin, bool InclusiveMax)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_FloatFloat");

	UKismetMathLibrary_InRange_FloatFloat_Params params {};
	params.Value = Value;
	params.Min = Min;
	params.Max = Max;
	params.InclusiveMin = InclusiveMin;
	params.InclusiveMax = InclusiveMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5DB10
//		Name   -> Function Engine.KismetMathLibrary.Hypotenuse
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Hypotenuse(float Width, float Height)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Hypotenuse");

	UKismetMathLibrary_Hypotenuse_Params params {};
	params.Width = Width;
	params.Height = Height;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D8B0
//		Name   -> Function Engine.KismetMathLibrary.HSVToRGB_Vector
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                HSV                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                RGB                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetMathLibrary::STATIC_HSVToRGB_Vector(const struct FLinearColor& HSV, struct FLinearColor* RGB)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGB_Vector");

	UKismetMathLibrary_HSVToRGB_Vector_Params params {};
	params.HSV = HSV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (RGB != nullptr)
		*RGB = params.RGB;

}


// Function:
//		Offset -> 0x02D5D750
//		Name   -> Function Engine.KismetMathLibrary.HSVToRGB
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              H                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              S                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              V                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_HSVToRGB(float H, float S, float V, float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGB");

	UKismetMathLibrary_HSVToRGB_Params params {};
	params.H = H;
	params.S = S;
	params.V = V;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D690
//		Name   -> Function Engine.KismetMathLibrary.GridSnap_Float
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              GridSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_GridSnap_Float(float Location, float GridSize)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GridSnap_Float");

	UKismetMathLibrary_GridSnap_Float_Params params {};
	params.Location = Location;
	params.GridSize = GridSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D1F0
//		Name   -> Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_GreaterGreater_VectorRotator(const struct FVector& A, const struct FRotator& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator");

	UKismetMathLibrary_GreaterGreater_VectorRotator_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D130
//		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_GreaterEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan");

	UKismetMathLibrary_GreaterEqual_TimespanTimespan_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D070
//		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_GreaterEqual_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_IntInt");

	UKismetMathLibrary_GreaterEqual_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5CFB0
//		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_GreaterEqual_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat");

	UKismetMathLibrary_GreaterEqual_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5CF00
//		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_GreaterEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime");

	UKismetMathLibrary_GreaterEqual_DateTimeDateTime_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5CE40
//		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_GreaterEqual_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_ByteByte");

	UKismetMathLibrary_GreaterEqual_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D5D0
//		Name   -> Function Engine.KismetMathLibrary.Greater_TimespanTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Greater_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_TimespanTimespan");

	UKismetMathLibrary_Greater_TimespanTimespan_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D510
//		Name   -> Function Engine.KismetMathLibrary.Greater_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Greater_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_IntInt");

	UKismetMathLibrary_Greater_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D450
//		Name   -> Function Engine.KismetMathLibrary.Greater_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Greater_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_FloatFloat");

	UKismetMathLibrary_Greater_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D3A0
//		Name   -> Function Engine.KismetMathLibrary.Greater_DateTimeDateTime
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Greater_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_DateTimeDateTime");

	UKismetMathLibrary_Greater_DateTimeDateTime_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D2E0
//		Name   -> Function Engine.KismetMathLibrary.Greater_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Greater_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_ByteByte");

	UKismetMathLibrary_Greater_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5CD90
//		Name   -> Function Engine.KismetMathLibrary.GetYear
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetYear(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetYear");

	UKismetMathLibrary_GetYear_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5CC60
//		Name   -> Function Engine.KismetMathLibrary.GetYawPitchFromVector
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     InVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Yaw                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Pitch                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_GetYawPitchFromVector(const struct FVector& InVec, float* Yaw, float* Pitch)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetYawPitchFromVector");

	UKismetMathLibrary_GetYawPitchFromVector_Params params {};
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Yaw != nullptr)
		*Yaw = params.Yaw;
	if (Pitch != nullptr)
		*Pitch = params.Pitch;

}


// Function:
//		Offset -> 0x02D5CBD0
//		Name   -> Function Engine.KismetMathLibrary.GetYawFromVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     InVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_GetYawFromVector(const struct FVector& InVec)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetYawFromVector");

	UKismetMathLibrary_GetYawFromVector_Params params {};
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C910
//		Name   -> Function Engine.KismetMathLibrary.GetVectorArrayAverage
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<struct FVector>                             Vectors                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_GetVectorArrayAverage(TArray<struct FVector> Vectors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetVectorArrayAverage");

	UKismetMathLibrary_GetVectorArrayAverage_Params params {};
	params.Vectors = Vectors;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C6C0
//		Name   -> Function Engine.KismetMathLibrary.GetUpVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_GetUpVector(const struct FRotator& InRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetUpVector");

	UKismetMathLibrary_GetUpVector_Params params {};
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C460
//		Name   -> Function Engine.KismetMathLibrary.GetTotalSeconds
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_GetTotalSeconds(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalSeconds");

	UKismetMathLibrary_GetTotalSeconds_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C3D0
//		Name   -> Function Engine.KismetMathLibrary.GetTotalMinutes
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_GetTotalMinutes(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalMinutes");

	UKismetMathLibrary_GetTotalMinutes_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C340
//		Name   -> Function Engine.KismetMathLibrary.GetTotalMilliseconds
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_GetTotalMilliseconds(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalMilliseconds");

	UKismetMathLibrary_GetTotalMilliseconds_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C2B0
//		Name   -> Function Engine.KismetMathLibrary.GetTotalHours
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_GetTotalHours(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalHours");

	UKismetMathLibrary_GetTotalHours_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C220
//		Name   -> Function Engine.KismetMathLibrary.GetTotalDays
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_GetTotalDays(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalDays");

	UKismetMathLibrary_GetTotalDays_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C1A0
//		Name   -> Function Engine.KismetMathLibrary.GetTimeOfDay
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_GetTimeOfDay(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTimeOfDay");

	UKismetMathLibrary_GetTimeOfDay_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BF00
//		Name   -> Function Engine.KismetMathLibrary.GetSeconds
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetSeconds(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSeconds");

	UKismetMathLibrary_GetSeconds_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BE90
//		Name   -> Function Engine.KismetMathLibrary.GetSecond
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetSecond(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSecond");

	UKismetMathLibrary_GetSecond_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BD00
//		Name   -> Function Engine.KismetMathLibrary.GetRightVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_GetRightVector(const struct FRotator& InRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetRightVector");

	UKismetMathLibrary_GetRightVector_Params params {};
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BA40
//		Name   -> Function Engine.KismetMathLibrary.GetPI
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_GetPI()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPI");

	UKismetMathLibrary_GetPI_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B870
//		Name   -> Function Engine.KismetMathLibrary.GetMonth
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetMonth(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMonth");

	UKismetMathLibrary_GetMonth_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B7F0
//		Name   -> Function Engine.KismetMathLibrary.GetMinutes
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetMinutes(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinutes");

	UKismetMathLibrary_GetMinutes_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B780
//		Name   -> Function Engine.KismetMathLibrary.GetMinute
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetMinute(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinute");

	UKismetMathLibrary_GetMinute_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B6F0
//		Name   -> Function Engine.KismetMathLibrary.GetMinElement
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_GetMinElement(const struct FVector& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinElement");

	UKismetMathLibrary_GetMinElement_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B670
//		Name   -> Function Engine.KismetMathLibrary.GetMilliseconds
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetMilliseconds(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMilliseconds");

	UKismetMathLibrary_GetMilliseconds_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B600
//		Name   -> Function Engine.KismetMathLibrary.GetMillisecond
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetMillisecond(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMillisecond");

	UKismetMathLibrary_GetMillisecond_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B540
//		Name   -> Function Engine.KismetMathLibrary.GetMaxElement
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_GetMaxElement(const struct FVector& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMaxElement");

	UKismetMathLibrary_GetMaxElement_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B1A0
//		Name   -> Function Engine.KismetMathLibrary.GetHours
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetHours(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHours");

	UKismetMathLibrary_GetHours_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B0C0
//		Name   -> Function Engine.KismetMathLibrary.GetHour12
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetHour12(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHour12");

	UKismetMathLibrary_GetHour12_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B130
//		Name   -> Function Engine.KismetMathLibrary.GetHour
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetHour(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHour");

	UKismetMathLibrary_GetHour_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5AEF0
//		Name   -> Function Engine.KismetMathLibrary.GetForwardVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_GetForwardVector(const struct FRotator& InRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetForwardVector");

	UKismetMathLibrary_GetForwardVector_Params params {};
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5AAA0
//		Name   -> Function Engine.KismetMathLibrary.GetDuration
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_GetDuration(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDuration");

	UKismetMathLibrary_GetDuration_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A8D0
//		Name   -> Function Engine.KismetMathLibrary.GetDirectionVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     To                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_GetDirectionVector(const struct FVector& From, const struct FVector& To)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDirectionVector");

	UKismetMathLibrary_GetDirectionVector_Params params {};
	params.From = From;
	params.To = To;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A850
//		Name   -> Function Engine.KismetMathLibrary.GetDays
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetDays(const struct FTimespan& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDays");

	UKismetMathLibrary_GetDays_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A7E0
//		Name   -> Function Engine.KismetMathLibrary.GetDayOfYear
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetDayOfYear(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDayOfYear");

	UKismetMathLibrary_GetDayOfYear_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A770
//		Name   -> Function Engine.KismetMathLibrary.GetDay
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_GetDay(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDay");

	UKismetMathLibrary_GetDay_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A6F0
//		Name   -> Function Engine.KismetMathLibrary.GetDate
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FDateTime                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FDateTime UKismetMathLibrary::STATIC_GetDate(const struct FDateTime& A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDate");

	UKismetMathLibrary_GetDate_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A150
//		Name   -> Function Engine.KismetMathLibrary.GetAxes
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     X                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Y                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Z                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetMathLibrary::STATIC_GetAxes(const struct FRotator& A, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAxes");

	UKismetMathLibrary_GetAxes_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
	if (Z != nullptr)
		*Z = params.Z;

}


// Function:
//		Offset -> 0x02D58F70
//		Name   -> Function Engine.KismetMathLibrary.FTrunc
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_FTrunc(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FTrunc");

	UKismetMathLibrary_FTrunc_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D59D00
//		Name   -> Function Engine.KismetMathLibrary.FromSeconds
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_FromSeconds(float Seconds)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromSeconds");

	UKismetMathLibrary_FromSeconds_Params params {};
	params.Seconds = Seconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D59C70
//		Name   -> Function Engine.KismetMathLibrary.FromMinutes
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Minutes                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_FromMinutes(float Minutes)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromMinutes");

	UKismetMathLibrary_FromMinutes_Params params {};
	params.Minutes = Minutes;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D59BE0
//		Name   -> Function Engine.KismetMathLibrary.FromMilliseconds
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Milliseconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_FromMilliseconds(float Milliseconds)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromMilliseconds");

	UKismetMathLibrary_FromMilliseconds_Params params {};
	params.Milliseconds = Milliseconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D59B50
//		Name   -> Function Engine.KismetMathLibrary.FromHours
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Hours                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_FromHours(float Hours)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromHours");

	UKismetMathLibrary_FromHours_Params params {};
	params.Hours = Hours;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D59AC0
//		Name   -> Function Engine.KismetMathLibrary.FromDays
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Days                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_FromDays(float Days)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromDays");

	UKismetMathLibrary_FromDays_Params params {};
	params.Days = Days;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D599C0
//		Name   -> Function Engine.KismetMathLibrary.Fraction
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Fraction(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Fraction");

	UKismetMathLibrary_Fraction_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D58E60
//		Name   -> Function Engine.KismetMathLibrary.FMod
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Dividend                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Divisor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Remainder                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_FMod(float Dividend, float Divisor, float* Remainder)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMod");

	UKismetMathLibrary_FMod_Params params {};
	params.Dividend = Dividend;
	params.Divisor = Divisor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Remainder != nullptr)
		*Remainder = params.Remainder;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D58DA0
//		Name   -> Function Engine.KismetMathLibrary.FMin
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_FMin(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMin");

	UKismetMathLibrary_FMin_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D58CE0
//		Name   -> Function Engine.KismetMathLibrary.FMax
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_FMax(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMax");

	UKismetMathLibrary_FMax_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D59570
//		Name   -> Function Engine.KismetMathLibrary.FixedTurn
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              InCurrent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InDesired                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InDeltaRate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_FixedTurn(float InCurrent, float InDesired, float InDeltaRate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FixedTurn");

	UKismetMathLibrary_FixedTurn_Params params {};
	params.InCurrent = InCurrent;
	params.InDesired = InDesired;
	params.InDeltaRate = InDeltaRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D58B90
//		Name   -> Function Engine.KismetMathLibrary.FInterpTo_Constant
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_FInterpTo_Constant(float Current, float Target, float DeltaTime, float InterpSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpTo_Constant");

	UKismetMathLibrary_FInterpTo_Constant_Params params {};
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D58A40
//		Name   -> Function Engine.KismetMathLibrary.FInterpTo
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_FInterpTo(float Current, float Target, float DeltaTime, float InterpSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpTo");

	UKismetMathLibrary_FInterpTo_Params params {};
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D588F0
//		Name   -> Function Engine.KismetMathLibrary.FInterpEaseInOut
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Exponent                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_FInterpEaseInOut(float A, float B, float Alpha, float Exponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpEaseInOut");

	UKismetMathLibrary_FInterpEaseInOut_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;
	params.Exponent = Exponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D59150
//		Name   -> Function Engine.KismetMathLibrary.FindLookAtRotation
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     Start                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Target                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_FindLookAtRotation(const struct FVector& Start, const struct FVector& Target)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindLookAtRotation");

	UKismetMathLibrary_FindLookAtRotation_Params params {};
	params.Start = Start;
	params.Target = Target;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D58870
//		Name   -> Function Engine.KismetMathLibrary.FFloor
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_FFloor(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FFloor");

	UKismetMathLibrary_FFloor_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D58760
//		Name   -> Function Engine.KismetMathLibrary.FClamp
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_FClamp(float Value, float Min, float Max)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FClamp");

	UKismetMathLibrary_FClamp_Params params {};
	params.Value = Value;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D586E0
//		Name   -> Function Engine.KismetMathLibrary.FCeil
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_FCeil(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FCeil");

	UKismetMathLibrary_FCeil_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D58660
//		Name   -> Function Engine.KismetMathLibrary.Exp
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Exp(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Exp");

	UKismetMathLibrary_Exp_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D58430
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_VectorVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ErrorTolerance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_VectorVector");

	UKismetMathLibrary_EqualEqual_VectorVector_Params params {};
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D582A0
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_TransformTransform
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  A                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  B                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_TransformTransform(const struct FTransform& A, const struct FTransform& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_TransformTransform");

	UKismetMathLibrary_EqualEqual_TransformTransform_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D581E0
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan");

	UKismetMathLibrary_EqualEqual_TimespanTimespan_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D57DA0
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ErrorTolerance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator");

	UKismetMathLibrary_EqualEqual_RotatorRotator_Params params {};
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D57CE0
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_ObjectObject
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UObject*                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_ObjectObject(class UObject* A, class UObject* B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ObjectObject");

	UKismetMathLibrary_EqualEqual_ObjectObject_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D57C20
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_NameName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_NameName(const struct FName& A, const struct FName& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_NameName");

	UKismetMathLibrary_EqualEqual_NameName_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D579D0
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_IntInt");

	UKismetMathLibrary_EqualEqual_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D576F0
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_FloatFloat");

	UKismetMathLibrary_EqualEqual_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D57640
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime");

	UKismetMathLibrary_EqualEqual_DateTimeDateTime_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D57580
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_ClassClass
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_ClassClass(class UClass* A, class UClass* B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ClassClass");

	UKismetMathLibrary_EqualEqual_ClassClass_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D574C0
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ByteByte");

	UKismetMathLibrary_EqualEqual_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D573F0
//		Name   -> Function Engine.KismetMathLibrary.EqualEqual_BoolBool
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_EqualEqual_BoolBool(bool A, bool B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_BoolBool");

	UKismetMathLibrary_EqualEqual_BoolBool_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D570C0
//		Name   -> Function Engine.KismetMathLibrary.Ease
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EEasingFunc>                    EasingFunc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Steps                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Ease(float A, float B, float Alpha, TEnumAsByte<Engine_EEasingFunc> EasingFunc, float BlendExp, int Steps)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Ease");

	UKismetMathLibrary_Ease_Params params {};
	params.A = A;
	params.B = B;
	params.Alpha = Alpha;
	params.EasingFunc = EasingFunc;
	params.BlendExp = BlendExp;
	params.Steps = Steps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D54C60
//		Name   -> Function Engine.KismetMathLibrary.DotProduct2D
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_DotProduct2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DotProduct2D");

	UKismetMathLibrary_DotProduct2D_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D54D10
//		Name   -> Function Engine.KismetMathLibrary.Dot_VectorVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Dot_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Dot_VectorVector");

	UKismetMathLibrary_Dot_VectorVector_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D54AB0
//		Name   -> Function Engine.KismetMathLibrary.Divide_VectorVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Divide_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorVector");

	UKismetMathLibrary_Divide_VectorVector_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D549D0
//		Name   -> Function Engine.KismetMathLibrary.Divide_VectorInt
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Divide_VectorInt(const struct FVector& A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorInt");

	UKismetMathLibrary_Divide_VectorInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D548F0
//		Name   -> Function Engine.KismetMathLibrary.Divide_VectorFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Divide_VectorFloat(const struct FVector& A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorFloat");

	UKismetMathLibrary_Divide_VectorFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D54830
//		Name   -> Function Engine.KismetMathLibrary.Divide_Vector2DFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_Divide_Vector2DFloat(const struct FVector2D& A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector2DFloat");

	UKismetMathLibrary_Divide_Vector2DFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D54770
//		Name   -> Function Engine.KismetMathLibrary.Divide_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Divide_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_IntInt");

	UKismetMathLibrary_Divide_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D546B0
//		Name   -> Function Engine.KismetMathLibrary.Divide_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Divide_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_FloatFloat");

	UKismetMathLibrary_Divide_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D545F0
//		Name   -> Function Engine.KismetMathLibrary.Divide_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
unsigned char UKismetMathLibrary::STATIC_Divide_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_ByteByte");

	UKismetMathLibrary_Divide_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D541E0
//		Name   -> Function Engine.KismetMathLibrary.DegTan
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_DegTan(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegTan");

	UKismetMathLibrary_DegTan_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D54160
//		Name   -> Function Engine.KismetMathLibrary.DegSin
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_DegSin(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegSin");

	UKismetMathLibrary_DegSin_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D54260
//		Name   -> Function Engine.KismetMathLibrary.DegreesToRadians
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_DegreesToRadians(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegreesToRadians");

	UKismetMathLibrary_DegreesToRadians_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D540E0
//		Name   -> Function Engine.KismetMathLibrary.DegCos
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_DegCos(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegCos");

	UKismetMathLibrary_DegCos_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53FA0
//		Name   -> Function Engine.KismetMathLibrary.DegAtan2
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_DegAtan2(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAtan2");

	UKismetMathLibrary_DegAtan2_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D54060
//		Name   -> Function Engine.KismetMathLibrary.DegAtan
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_DegAtan(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAtan");

	UKismetMathLibrary_DegAtan_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53F20
//		Name   -> Function Engine.KismetMathLibrary.DegAsin
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_DegAsin(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAsin");

	UKismetMathLibrary_DegAsin_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53EA0
//		Name   -> Function Engine.KismetMathLibrary.DegAcos
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_DegAcos(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAcos");

	UKismetMathLibrary_DegAcos_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53BC0
//		Name   -> Function Engine.KismetMathLibrary.DaysInYear
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Year                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_DaysInYear(int Year)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DaysInYear");

	UKismetMathLibrary_DaysInYear_Params params {};
	params.Year = Year;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53B00
//		Name   -> Function Engine.KismetMathLibrary.DaysInMonth
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Year                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Month                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_DaysInMonth(int Year, int Month)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DaysInMonth");

	UKismetMathLibrary_DaysInMonth_Params params {};
	params.Year = Year;
	params.Month = Month;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53AC0
//		Name   -> Function Engine.KismetMathLibrary.DateTimeMinValue
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FDateTime UKismetMathLibrary::STATIC_DateTimeMinValue()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeMinValue");

	UKismetMathLibrary_DateTimeMinValue_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53A80
//		Name   -> Function Engine.KismetMathLibrary.DateTimeMaxValue
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FDateTime UKismetMathLibrary::STATIC_DateTimeMaxValue()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeMaxValue");

	UKismetMathLibrary_DateTimeMaxValue_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53980
//		Name   -> Function Engine.KismetMathLibrary.DateTimeFromString
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     DateTimeString                                             (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FDateTime                                   Result                                                     (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_DateTimeFromString(const struct FString& DateTimeString, struct FDateTime* Result)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeFromString");

	UKismetMathLibrary_DateTimeFromString_Params params {};
	params.DateTimeString = DateTimeString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Result != nullptr)
		*Result = params.Result;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53880
//		Name   -> Function Engine.KismetMathLibrary.DateTimeFromIsoString
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     IsoString                                                  (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FDateTime                                   Result                                                     (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_DateTimeFromIsoString(const struct FString& IsoString, struct FDateTime* Result)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeFromIsoString");

	UKismetMathLibrary_DateTimeFromIsoString_Params params {};
	params.IsoString = IsoString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Result != nullptr)
		*Result = params.Result;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53520
//		Name   -> Function Engine.KismetMathLibrary.CrossProduct2D
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_CrossProduct2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CrossProduct2D");

	UKismetMathLibrary_CrossProduct2D_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D535D0
//		Name   -> Function Engine.KismetMathLibrary.Cross_VectorVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Cross_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Cross_VectorVector");

	UKismetMathLibrary_Cross_VectorVector_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53400
//		Name   -> Function Engine.KismetMathLibrary.CreateVectorFromYawPitch
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Length                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_CreateVectorFromYawPitch(float Yaw, float Pitch, float Length)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CreateVectorFromYawPitch");

	UKismetMathLibrary_CreateVectorFromYawPitch_Params params {};
	params.Yaw = Yaw;
	params.Pitch = Pitch;
	params.Length = Length;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53250
//		Name   -> Function Engine.KismetMathLibrary.Cos
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Cos(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Cos");

	UKismetMathLibrary_Cos_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D530A0
//		Name   -> Function Engine.KismetMathLibrary.ConvertTransformToRelative
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ParentTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UKismetMathLibrary::STATIC_ConvertTransformToRelative(const struct FTransform& Transform, const struct FTransform& ParentTransform)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ConvertTransformToRelative");

	UKismetMathLibrary_ConvertTransformToRelative_Params params {};
	params.Transform = Transform;
	params.ParentTransform = ParentTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D53010
//		Name   -> Function Engine.KismetMathLibrary.Conv_VectorToVector2D
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     InVector                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_Conv_VectorToVector2D(const struct FVector& InVector)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToVector2D");

	UKismetMathLibrary_Conv_VectorToVector2D_Params params {};
	params.InVector = InVector;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52F40
//		Name   -> Function Engine.KismetMathLibrary.Conv_VectorToTransform
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     InLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UKismetMathLibrary::STATIC_Conv_VectorToTransform(const struct FVector& InLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToTransform");

	UKismetMathLibrary_Conv_VectorToTransform_Params params {};
	params.InLocation = InLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52DB0
//		Name   -> Function Engine.KismetMathLibrary.Conv_VectorToRotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     InVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_Conv_VectorToRotator(const struct FVector& InVec)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToRotator");

	UKismetMathLibrary_Conv_VectorToRotator_Params params {};
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52D20
//		Name   -> Function Engine.KismetMathLibrary.Conv_VectorToLinearColor
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     InVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_Conv_VectorToLinearColor(const struct FVector& InVec)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToLinearColor");

	UKismetMathLibrary_Conv_VectorToLinearColor_Params params {};
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52B80
//		Name   -> Function Engine.KismetMathLibrary.Conv_Vector2DToVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   InVector2D                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Conv_Vector2DToVector(const struct FVector2D& InVector2D, float Z)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector2DToVector");

	UKismetMathLibrary_Conv_Vector2DToVector_Params params {};
	params.InVector2D = InVector2D;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D525E0
//		Name   -> Function Engine.KismetMathLibrary.Conv_RotatorToVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Conv_RotatorToVector(const struct FRotator& InRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_RotatorToVector");

	UKismetMathLibrary_Conv_RotatorToVector_Params params {};
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D521F0
//		Name   -> Function Engine.KismetMathLibrary.Conv_LinearColorToVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                InLinearColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Conv_LinearColorToVector(const struct FLinearColor& InLinearColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_LinearColorToVector");

	UKismetMathLibrary_Conv_LinearColorToVector_Params params {};
	params.InLinearColor = InLinearColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52160
//		Name   -> Function Engine.KismetMathLibrary.Conv_LinearColorToColor
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                InLinearColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FColor                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FColor UKismetMathLibrary::STATIC_Conv_LinearColorToColor(const struct FLinearColor& InLinearColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_LinearColorToColor");

	UKismetMathLibrary_Conv_LinearColorToColor_Params params {};
	params.InLinearColor = InLinearColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51DE0
//		Name   -> Function Engine.KismetMathLibrary.Conv_IntToFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Conv_IntToFloat(int InInt)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToFloat");

	UKismetMathLibrary_Conv_IntToFloat_Params params {};
	params.InInt = InInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51D60
//		Name   -> Function Engine.KismetMathLibrary.Conv_IntToByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
unsigned char UKismetMathLibrary::STATIC_Conv_IntToByte(int InInt)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToByte");

	UKismetMathLibrary_Conv_IntToByte_Params params {};
	params.InInt = InInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51CE0
//		Name   -> Function Engine.KismetMathLibrary.Conv_IntToBool
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_Conv_IntToBool(int InInt)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToBool");

	UKismetMathLibrary_Conv_IntToBool_Params params {};
	params.InInt = InInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51B60
//		Name   -> Function Engine.KismetMathLibrary.Conv_FloatToVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Conv_FloatToVector(float InFloat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToVector");

	UKismetMathLibrary_Conv_FloatToVector_Params params {};
	params.InFloat = InFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D517C0
//		Name   -> Function Engine.KismetMathLibrary.Conv_FloatToLinearColor
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_Conv_FloatToLinearColor(float InFloat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToLinearColor");

	UKismetMathLibrary_Conv_FloatToLinearColor_Params params {};
	params.InFloat = InFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51660
//		Name   -> Function Engine.KismetMathLibrary.Conv_ColorToLinearColor
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FColor                                      InColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_Conv_ColorToLinearColor(const struct FColor& InColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ColorToLinearColor");

	UKismetMathLibrary_Conv_ColorToLinearColor_Params params {};
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51460
//		Name   -> Function Engine.KismetMathLibrary.Conv_ByteToInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      InByte                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Conv_ByteToInt(unsigned char InByte)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToInt");

	UKismetMathLibrary_Conv_ByteToInt_Params params {};
	params.InByte = InByte;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D513E0
//		Name   -> Function Engine.KismetMathLibrary.Conv_ByteToFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      InByte                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Conv_ByteToFloat(unsigned char InByte)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToFloat");

	UKismetMathLibrary_Conv_ByteToFloat_Params params {};
	params.InByte = InByte;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D511D0
//		Name   -> Function Engine.KismetMathLibrary.Conv_BoolToInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Conv_BoolToInt(bool InBool)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToInt");

	UKismetMathLibrary_Conv_BoolToInt_Params params {};
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51140
//		Name   -> Function Engine.KismetMathLibrary.Conv_BoolToFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Conv_BoolToFloat(bool InBool)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToFloat");

	UKismetMathLibrary_Conv_BoolToFloat_Params params {};
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D510C0
//		Name   -> Function Engine.KismetMathLibrary.Conv_BoolToByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
unsigned char UKismetMathLibrary::STATIC_Conv_BoolToByte(bool InBool)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToByte");

	UKismetMathLibrary_Conv_BoolToByte_Params params {};
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D507B0
//		Name   -> Function Engine.KismetMathLibrary.ComposeTransforms
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  A                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  B                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UKismetMathLibrary::STATIC_ComposeTransforms(const struct FTransform& A, const struct FTransform& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ComposeTransforms");

	UKismetMathLibrary_ComposeTransforms_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D506C0
//		Name   -> Function Engine.KismetMathLibrary.ComposeRotators
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UKismetMathLibrary::STATIC_ComposeRotators(const struct FRotator& A, const struct FRotator& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ComposeRotators");

	UKismetMathLibrary_ComposeRotators_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4FA30
//		Name   -> Function Engine.KismetMathLibrary.ClassIsChildOf
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      TestClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class UClass*                                      ParentClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_ClassIsChildOf(class UClass* TestClass, class UClass* ParentClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClassIsChildOf");

	UKismetMathLibrary_ClassIsChildOf_Params params {};
	params.TestClass = TestClass;
	params.ParentClass = ParentClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4F910
//		Name   -> Function Engine.KismetMathLibrary.ClampVectorSize
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_ClampVectorSize(const struct FVector& A, float Min, float Max)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampVectorSize");

	UKismetMathLibrary_ClampVectorSize_Params params {};
	params.A = A;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4F890
//		Name   -> Function Engine.KismetMathLibrary.ClampAxis
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_ClampAxis(float Angle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAxis");

	UKismetMathLibrary_ClampAxis_Params params {};
	params.Angle = Angle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4F780
//		Name   -> Function Engine.KismetMathLibrary.ClampAngle
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              AngleDegrees                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MinAngleDegrees                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              MaxAngleDegrees                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_ClampAngle(float AngleDegrees, float MinAngleDegrees, float MaxAngleDegrees)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAngle");

	UKismetMathLibrary_ClampAngle_Params params {};
	params.AngleDegrees = AngleDegrees;
	params.MinAngleDegrees = MinAngleDegrees;
	params.MaxAngleDegrees = MaxAngleDegrees;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4F690
//		Name   -> Function Engine.KismetMathLibrary.Clamp
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Clamp(int Value, int Min, int Max)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Clamp");

	UKismetMathLibrary_Clamp_Params params {};
	params.Value = Value;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4CC30
//		Name   -> Function Engine.KismetMathLibrary.CInterpTo
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UKismetMathLibrary::STATIC_CInterpTo(const struct FLinearColor& Current, const struct FLinearColor& Target, float DeltaTime, float InterpSpeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CInterpTo");

	UKismetMathLibrary_CInterpTo_Params params {};
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4B430
//		Name   -> Function Engine.KismetMathLibrary.BreakVector2D
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   InVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              X                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Y                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_BreakVector2D(const struct FVector2D& InVec, float* X, float* Y)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector2D");

	UKismetMathLibrary_BreakVector2D_Params params {};
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;

}


// Function:
//		Offset -> 0x02D4B550
//		Name   -> Function Engine.KismetMathLibrary.BreakVector
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     InVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              X                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Y                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Z                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_BreakVector(const struct FVector& InVec, float* X, float* Y, float* Z)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector");

	UKismetMathLibrary_BreakVector_Params params {};
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
	if (Z != nullptr)
		*Z = params.Z;

}


// Function:
//		Offset -> 0x02D4B250
//		Name   -> Function Engine.KismetMathLibrary.BreakTransform
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  InTransform                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Scale                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetMathLibrary::STATIC_BreakTransform(const struct FTransform& InTransform, struct FVector* Location, struct FRotator* Rotation, struct FVector* Scale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTransform");

	UKismetMathLibrary_BreakTransform_Params params {};
	params.InTransform = InTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Location != nullptr)
		*Location = params.Location;
	if (Rotation != nullptr)
		*Rotation = params.Rotation;
	if (Scale != nullptr)
		*Scale = params.Scale;

}


// Function:
//		Offset -> 0x02D4B040
//		Name   -> Function Engine.KismetMathLibrary.BreakTimespan
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   InTimespan                                                 (Parm, ZeroConstructor)
//		int                                                Days                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Hours                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Minutes                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Seconds                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Milliseconds                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_BreakTimespan(const struct FTimespan& InTimespan, int* Days, int* Hours, int* Minutes, int* Seconds, int* Milliseconds)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTimespan");

	UKismetMathLibrary_BreakTimespan_Params params {};
	params.InTimespan = InTimespan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Days != nullptr)
		*Days = params.Days;
	if (Hours != nullptr)
		*Hours = params.Hours;
	if (Minutes != nullptr)
		*Minutes = params.Minutes;
	if (Seconds != nullptr)
		*Seconds = params.Seconds;
	if (Milliseconds != nullptr)
		*Milliseconds = params.Milliseconds;

}


// Function:
//		Offset -> 0x02D4AD30
//		Name   -> Function Engine.KismetMathLibrary.BreakRotIntoAxes
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    InRot                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     X                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Y                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Z                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetMathLibrary::STATIC_BreakRotIntoAxes(const struct FRotator& InRot, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRotIntoAxes");

	UKismetMathLibrary_BreakRotIntoAxes_Params params {};
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
	if (Z != nullptr)
		*Z = params.Z;

}


// Function:
//		Offset -> 0x02D4AEB0
//		Name   -> Function Engine.KismetMathLibrary.BreakRotator
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Roll                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Pitch                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Yaw                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_BreakRotator(const struct FRotator& InRot, float* Roll, float* Pitch, float* Yaw)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRotator");

	UKismetMathLibrary_BreakRotator_Params params {};
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Roll != nullptr)
		*Roll = params.Roll;
	if (Pitch != nullptr)
		*Pitch = params.Pitch;
	if (Yaw != nullptr)
		*Yaw = params.Yaw;

}


// Function:
//		Offset -> 0x02D4AC50
//		Name   -> Function Engine.KismetMathLibrary.BreakRandomStream
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRandomStream                               InRandomStream                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		int                                                InitialSeed                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_BreakRandomStream(const struct FRandomStream& InRandomStream, int* InitialSeed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRandomStream");

	UKismetMathLibrary_BreakRandomStream_Params params {};
	params.InRandomStream = InRandomStream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (InitialSeed != nullptr)
		*InitialSeed = params.InitialSeed;

}


// Function:
//		Offset -> 0x02D4A9A0
//		Name   -> Function Engine.KismetMathLibrary.BreakDateTime
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   InDateTime                                                 (Parm, ZeroConstructor)
//		int                                                Year                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Month                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Day                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Hour                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Minute                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Second                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Millisecond                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_BreakDateTime(const struct FDateTime& InDateTime, int* Year, int* Month, int* Day, int* Hour, int* Minute, int* Second, int* Millisecond)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakDateTime");

	UKismetMathLibrary_BreakDateTime_Params params {};
	params.InDateTime = InDateTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Year != nullptr)
		*Year = params.Year;
	if (Month != nullptr)
		*Month = params.Month;
	if (Day != nullptr)
		*Day = params.Day;
	if (Hour != nullptr)
		*Hour = params.Hour;
	if (Minute != nullptr)
		*Minute = params.Minute;
	if (Second != nullptr)
		*Second = params.Second;
	if (Millisecond != nullptr)
		*Millisecond = params.Millisecond;

}


// Function:
//		Offset -> 0x02D4A7B0
//		Name   -> Function Engine.KismetMathLibrary.BreakColor
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                InColor                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              R                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              G                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              A                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetMathLibrary::STATIC_BreakColor(const struct FLinearColor& InColor, float* R, float* G, float* B, float* A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakColor");

	UKismetMathLibrary_BreakColor_Params params {};
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (R != nullptr)
		*R = params.R;
	if (G != nullptr)
		*G = params.G;
	if (B != nullptr)
		*B = params.B;
	if (A != nullptr)
		*A = params.A;

}


// Function:
//		Offset -> 0x02D48DA0
//		Name   -> Function Engine.KismetMathLibrary.BooleanXOR
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_BooleanXOR(bool A, bool B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanXOR");

	UKismetMathLibrary_BooleanXOR_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48CD0
//		Name   -> Function Engine.KismetMathLibrary.BooleanOR
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_BooleanOR(bool A, bool B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanOR");

	UKismetMathLibrary_BooleanOR_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48C00
//		Name   -> Function Engine.KismetMathLibrary.BooleanNOR
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_BooleanNOR(bool A, bool B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanNOR");

	UKismetMathLibrary_BooleanNOR_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48B30
//		Name   -> Function Engine.KismetMathLibrary.BooleanNAND
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_BooleanNAND(bool A, bool B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanNAND");

	UKismetMathLibrary_BooleanNAND_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48A60
//		Name   -> Function Engine.KismetMathLibrary.BooleanAND
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetMathLibrary::STATIC_BooleanAND(bool A, bool B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanAND");

	UKismetMathLibrary_BooleanAND_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48860
//		Name   -> Function Engine.KismetMathLibrary.Atan2
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Atan2(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Atan2");

	UKismetMathLibrary_Atan2_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48920
//		Name   -> Function Engine.KismetMathLibrary.Atan
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Atan(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Atan");

	UKismetMathLibrary_Atan_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D487E0
//		Name   -> Function Engine.KismetMathLibrary.Asin
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Asin(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Asin");

	UKismetMathLibrary_Asin_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D465B0
//		Name   -> Function Engine.KismetMathLibrary.And_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_And_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.And_IntInt");

	UKismetMathLibrary_And_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D464C0
//		Name   -> Function Engine.KismetMathLibrary.Add_VectorVector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Add_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorVector");

	UKismetMathLibrary_Add_VectorVector_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D463E0
//		Name   -> Function Engine.KismetMathLibrary.Add_VectorInt
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Add_VectorInt(const struct FVector& A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorInt");

	UKismetMathLibrary_Add_VectorInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D46300
//		Name   -> Function Engine.KismetMathLibrary.Add_VectorFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UKismetMathLibrary::STATIC_Add_VectorFloat(const struct FVector& A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorFloat");

	UKismetMathLibrary_Add_VectorFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D46240
//		Name   -> Function Engine.KismetMathLibrary.Add_Vector2DVector2D
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_Add_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector2DVector2D");

	UKismetMathLibrary_Add_Vector2DVector2D_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D46180
//		Name   -> Function Engine.KismetMathLibrary.Add_Vector2DFloat
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UKismetMathLibrary::STATIC_Add_Vector2DFloat(const struct FVector2D& A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector2DFloat");

	UKismetMathLibrary_Add_Vector2DFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D460C0
//		Name   -> Function Engine.KismetMathLibrary.Add_TimespanTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FTimespan UKismetMathLibrary::STATIC_Add_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_TimespanTimespan");

	UKismetMathLibrary_Add_TimespanTimespan_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D46000
//		Name   -> Function Engine.KismetMathLibrary.Add_IntInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Add_IntInt(int A, int B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_IntInt");

	UKismetMathLibrary_Add_IntInt_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D45F40
//		Name   -> Function Engine.KismetMathLibrary.Add_FloatFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Add_FloatFloat(float A, float B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_FloatFloat");

	UKismetMathLibrary_Add_FloatFloat_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D45E80
//		Name   -> Function Engine.KismetMathLibrary.Add_DateTimeTimespan
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
//		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
//		struct FDateTime                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
struct FDateTime UKismetMathLibrary::STATIC_Add_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DateTimeTimespan");

	UKismetMathLibrary_Add_DateTimeTimespan_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D45DC0
//		Name   -> Function Engine.KismetMathLibrary.Add_ByteByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
unsigned char UKismetMathLibrary::STATIC_Add_ByteByte(unsigned char A, unsigned char B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_ByteByte");

	UKismetMathLibrary_Add_ByteByte_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D45BC0
//		Name   -> Function Engine.KismetMathLibrary.Acos
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Acos(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Acos");

	UKismetMathLibrary_Acos_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D45B40
//		Name   -> Function Engine.KismetMathLibrary.Abs_Int
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetMathLibrary::STATIC_Abs_Int(int A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs_Int");

	UKismetMathLibrary_Abs_Int_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D45AC0
//		Name   -> Function Engine.KismetMathLibrary.Abs
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetMathLibrary::STATIC_Abs(float A)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs");

	UKismetMathLibrary_Abs_Params params {};
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UKismetMathLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UKismetMathLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D67B70
//		Name   -> Function Engine.KismetNodeHelperLibrary.MarkBit
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		int                                                Data                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetNodeHelperLibrary::STATIC_MarkBit(int* Data, int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.MarkBit");

	UKismetNodeHelperLibrary_MarkBit_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;

}


// Function:
//		Offset -> 0x02D5DA30
//		Name   -> Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		int                                                Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NumBits                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetNodeHelperLibrary::STATIC_HasUnmarkedBit(int Data, int NumBits)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit");

	UKismetNodeHelperLibrary_HasUnmarkedBit_Params params {};
	params.Data = Data;
	params.NumBits = NumBits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5D970
//		Name   -> Function Engine.KismetNodeHelperLibrary.HasMarkedBit
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		int                                                Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NumBits                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetNodeHelperLibrary::STATIC_HasMarkedBit(int Data, int NumBits)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.HasMarkedBit");

	UKismetNodeHelperLibrary_HasMarkedBit_Params params {};
	params.Data = Data;
	params.NumBits = NumBits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C850
//		Name   -> Function Engine.KismetNodeHelperLibrary.GetValidIndex
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UEnum*                                       Enum                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      EnumeratorIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
unsigned char UKismetNodeHelperLibrary::STATIC_GetValidIndex(class UEnum* Enum, unsigned char EnumeratorIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetValidIndex");

	UKismetNodeHelperLibrary_GetValidIndex_Params params {};
	params.Enum = Enum;
	params.EnumeratorIndex = EnumeratorIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C590
//		Name   -> Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		int                                                Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StartIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NumBits                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bRandom                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetNodeHelperLibrary::STATIC_GetUnmarkedBit(int Data, int StartIdx, int NumBits, bool bRandom)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit");

	UKismetNodeHelperLibrary_GetUnmarkedBit_Params params {};
	params.Data = Data;
	params.StartIdx = StartIdx;
	params.NumBits = NumBits;
	params.bRandom = bRandom;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BBB0
//		Name   -> Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		int                                                Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StartIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NumBits                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetNodeHelperLibrary::STATIC_GetRandomUnmarkedBit(int Data, int StartIdx, int NumBits)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit");

	UKismetNodeHelperLibrary_GetRandomUnmarkedBit_Params params {};
	params.Data = Data;
	params.StartIdx = StartIdx;
	params.NumBits = NumBits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5AE00
//		Name   -> Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		int                                                Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                StartIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NumBits                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetNodeHelperLibrary::STATIC_GetFirstUnmarkedBit(int Data, int StartIdx, int NumBits)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit");

	UKismetNodeHelperLibrary_GetFirstUnmarkedBit_Params params {};
	params.Data = Data;
	params.StartIdx = StartIdx;
	params.NumBits = NumBits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5ACE0
//		Name   -> Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UEnum*                                       Enum                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      EnumeratorValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetNodeHelperLibrary::STATIC_GetEnumeratorUserFriendlyName(class UEnum* Enum, unsigned char EnumeratorValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName");

	UKismetNodeHelperLibrary_GetEnumeratorUserFriendlyName_Params params {};
	params.Enum = Enum;
	params.EnumeratorValue = EnumeratorValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5AC20
//		Name   -> Function Engine.KismetNodeHelperLibrary.GetEnumeratorName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UEnum*                                       Enum                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      EnumeratorValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName UKismetNodeHelperLibrary::STATIC_GetEnumeratorName(class UEnum* Enum, unsigned char EnumeratorValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorName");

	UKismetNodeHelperLibrary_GetEnumeratorName_Params params {};
	params.Enum = Enum;
	params.EnumeratorValue = EnumeratorValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4FB70
//		Name   -> Function Engine.KismetNodeHelperLibrary.ClearBit
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		int                                                Data                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetNodeHelperLibrary::STATIC_ClearBit(int* Data, int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.ClearBit");

	UKismetNodeHelperLibrary_ClearBit_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;

}


// Function:
//		Offset -> 0x02D4FAF0
//		Name   -> Function Engine.KismetNodeHelperLibrary.ClearAllBits
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		int                                                Data                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetNodeHelperLibrary::STATIC_ClearAllBits(int* Data)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.ClearAllBits");

	UKismetNodeHelperLibrary_ClearAllBits_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;

}


// Function:
//		Offset -> 0x02D489A0
//		Name   -> Function Engine.KismetNodeHelperLibrary.BitIsMarked
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		int                                                Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetNodeHelperLibrary::STATIC_BitIsMarked(int Data, int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.BitIsMarked");

	UKismetNodeHelperLibrary_BitIsMarked_Params params {};
	params.Data = Data;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UKismetNodeHelperLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UKismetNodeHelperLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D77860
//		Name   -> Function Engine.KismetStringLibrary.TrimTrailing
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_TrimTrailing(const struct FString& SourceString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.TrimTrailing");

	UKismetStringLibrary_TrimTrailing_Params params {};
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D77770
//		Name   -> Function Engine.KismetStringLibrary.Trim
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Trim(const struct FString& SourceString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Trim");

	UKismetStringLibrary_Trim_Params params {};
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D771E0
//		Name   -> Function Engine.KismetStringLibrary.ToUpper
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_ToUpper(const struct FString& SourceString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ToUpper");

	UKismetStringLibrary_ToUpper_Params params {};
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D770F0
//		Name   -> Function Engine.KismetStringLibrary.ToLower
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_ToLower(const struct FString& SourceString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ToLower");

	UKismetStringLibrary_ToLower_Params params {};
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76D90
//		Name   -> Function Engine.KismetStringLibrary.TimeSecondsToString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              InSeconds                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_TimeSecondsToString(float InSeconds)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.TimeSecondsToString");

	UKismetStringLibrary_TimeSecondsToString_Params params {};
	params.InSeconds = InSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D75360
//		Name   -> Function Engine.KismetStringLibrary.StartsWith
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     InPrefix                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TEnumAsByte<CoreUObject_ESearchCase>               SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetStringLibrary::STATIC_StartsWith(const struct FString& SourceString, const struct FString& InPrefix, TEnumAsByte<CoreUObject_ESearchCase> SearchCase)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.StartsWith");

	UKismetStringLibrary_StartsWith_Params params {};
	params.SourceString = SourceString;
	params.InPrefix = InPrefix;
	params.SearchCase = SearchCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D74FF0
//		Name   -> Function Engine.KismetStringLibrary.Split
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     InStr                                                      (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     LeftS                                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     RightS                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
//		TEnumAsByte<CoreUObject_ESearchCase>               SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<CoreUObject_ESearchDir>                SearchDir                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetStringLibrary::STATIC_Split(const struct FString& SourceString, const struct FString& InStr, struct FString* LeftS, struct FString* RightS, TEnumAsByte<CoreUObject_ESearchCase> SearchCase, TEnumAsByte<CoreUObject_ESearchDir> SearchDir)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Split");

	UKismetStringLibrary_Split_Params params {};
	params.SourceString = SourceString;
	params.InStr = InStr;
	params.SearchCase = SearchCase;
	params.SearchDir = SearchDir;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (LeftS != nullptr)
		*LeftS = params.LeftS;
	if (RightS != nullptr)
		*RightS = params.RightS;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6FD60
//		Name   -> Function Engine.KismetStringLibrary.RightPad
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                ChCount                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_RightPad(const struct FString& SourceString, int ChCount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.RightPad");

	UKismetStringLibrary_RightPad_Params params {};
	params.SourceString = SourceString;
	params.ChCount = ChCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6FC30
//		Name   -> Function Engine.KismetStringLibrary.RightChop
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_RightChop(const struct FString& SourceString, int Count)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.RightChop");

	UKismetStringLibrary_RightChop_Params params {};
	params.SourceString = SourceString;
	params.Count = Count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6FB00
//		Name   -> Function Engine.KismetStringLibrary.Right
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Right(const struct FString& SourceString, int Count)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Right");

	UKismetStringLibrary_Right_Params params {};
	params.SourceString = SourceString;
	params.Count = Count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6FA10
//		Name   -> Function Engine.KismetStringLibrary.Reverse
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Reverse(const struct FString& SourceString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Reverse");

	UKismetStringLibrary_Reverse_Params params {};
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6EB20
//		Name   -> Function Engine.KismetStringLibrary.ReplaceInline
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash)
//		struct FString                                     SearchText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReplacementText                                            (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TEnumAsByte<CoreUObject_ESearchCase>               SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetStringLibrary::STATIC_ReplaceInline(struct FString* SourceString, const struct FString& SearchText, const struct FString& ReplacementText, TEnumAsByte<CoreUObject_ESearchCase> SearchCase)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ReplaceInline");

	UKismetStringLibrary_ReplaceInline_Params params {};
	params.SearchText = SearchText;
	params.ReplacementText = ReplacementText;
	params.SearchCase = SearchCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SourceString != nullptr)
		*SourceString = params.SourceString;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6E940
//		Name   -> Function Engine.KismetStringLibrary.Replace
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     From                                                       (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     To                                                         (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TEnumAsByte<CoreUObject_ESearchCase>               SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Replace(const struct FString& SourceString, const struct FString& From, const struct FString& To, TEnumAsByte<CoreUObject_ESearchCase> SearchCase)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Replace");

	UKismetStringLibrary_Replace_Params params {};
	params.SourceString = SourceString;
	params.From = From;
	params.To = To;
	params.SearchCase = SearchCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6B780
//		Name   -> Function Engine.KismetStringLibrary.ParseIntoArray
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Delimiter                                                  (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               CullEmptyStrings                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UKismetStringLibrary::STATIC_ParseIntoArray(const struct FString& SourceString, const struct FString& Delimiter, bool CullEmptyStrings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ParseIntoArray");

	UKismetStringLibrary_ParseIntoArray_Params params {};
	params.SourceString = SourceString;
	params.Delimiter = Delimiter;
	params.CullEmptyStrings = CullEmptyStrings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6B070
//		Name   -> Function Engine.KismetStringLibrary.NotEqual_StrStr
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     A                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     B                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetStringLibrary::STATIC_NotEqual_StrStr(const struct FString& A, const struct FString& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.NotEqual_StrStr");

	UKismetStringLibrary_NotEqual_StrStr_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6B170
//		Name   -> Function Engine.KismetStringLibrary.NotEqual_StriStri
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     A                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     B                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetStringLibrary::STATIC_NotEqual_StriStri(const struct FString& A, const struct FString& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.NotEqual_StriStri");

	UKismetStringLibrary_NotEqual_StriStri_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D68670
//		Name   -> Function Engine.KismetStringLibrary.Mid
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                Start                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Mid(const struct FString& SourceString, int Start, int Count)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Mid");

	UKismetStringLibrary_Mid_Params params {};
	params.SourceString = SourceString;
	params.Start = Start;
	params.Count = Count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D67E00
//		Name   -> Function Engine.KismetStringLibrary.MatchesWildcard
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Wildcard                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TEnumAsByte<CoreUObject_ESearchCase>               SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetStringLibrary::STATIC_MatchesWildcard(const struct FString& SourceString, const struct FString& Wildcard, TEnumAsByte<CoreUObject_ESearchCase> SearchCase)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.MatchesWildcard");

	UKismetStringLibrary_MatchesWildcard_Params params {};
	params.SourceString = SourceString;
	params.Wildcard = Wildcard;
	params.SearchCase = SearchCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62D20
//		Name   -> Function Engine.KismetStringLibrary.Len
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     S                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetStringLibrary::STATIC_Len(const struct FString& S)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Len");

	UKismetStringLibrary_Len_Params params {};
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62BF0
//		Name   -> Function Engine.KismetStringLibrary.LeftPad
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                ChCount                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_LeftPad(const struct FString& SourceString, int ChCount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.LeftPad");

	UKismetStringLibrary_LeftPad_Params params {};
	params.SourceString = SourceString;
	params.ChCount = ChCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62AC0
//		Name   -> Function Engine.KismetStringLibrary.LeftChop
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_LeftChop(const struct FString& SourceString, int Count)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.LeftChop");

	UKismetStringLibrary_LeftChop_Params params {};
	params.SourceString = SourceString;
	params.Count = Count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62990
//		Name   -> Function Engine.KismetStringLibrary.Left
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Left(const struct FString& SourceString, int Count)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Left");

	UKismetStringLibrary_Left_Params params {};
	params.SourceString = SourceString;
	params.Count = Count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5F540
//		Name   -> Function Engine.KismetStringLibrary.JoinStringArray
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<struct FString>                             SourceArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		struct FString                                     Separator                                                  (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_JoinStringArray(TArray<struct FString> SourceArray, const struct FString& Separator)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.JoinStringArray");

	UKismetStringLibrary_JoinStringArray_Params params {};
	params.SourceArray = SourceArray;
	params.Separator = Separator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5F160
//		Name   -> Function Engine.KismetStringLibrary.IsNumeric
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetStringLibrary::STATIC_IsNumeric(const struct FString& SourceString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.IsNumeric");

	UKismetStringLibrary_IsNumeric_Params params {};
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BF80
//		Name   -> Function Engine.KismetStringLibrary.GetSubstring
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                StartIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Length                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_GetSubstring(const struct FString& SourceString, int StartIndex, int Length)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetSubstring");

	UKismetStringLibrary_GetSubstring_Params params {};
	params.SourceString = SourceString;
	params.StartIndex = StartIndex;
	params.Length = Length;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A3D0
//		Name   -> Function Engine.KismetStringLibrary.GetCharacterAsNumber
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetStringLibrary::STATIC_GetCharacterAsNumber(const struct FString& SourceString, int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetCharacterAsNumber");

	UKismetStringLibrary_GetCharacterAsNumber_Params params {};
	params.SourceString = SourceString;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A2D0
//		Name   -> Function Engine.KismetStringLibrary.GetCharacterArrayFromString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UKismetStringLibrary::STATIC_GetCharacterArrayFromString(const struct FString& SourceString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetCharacterArrayFromString");

	UKismetStringLibrary_GetCharacterArrayFromString_Params params {};
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D59250
//		Name   -> Function Engine.KismetStringLibrary.FindSubstring
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SearchIn                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Substring                                                  (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               bUseCase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSearchFromEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                StartPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetStringLibrary::STATIC_FindSubstring(const struct FString& SearchIn, const struct FString& Substring, bool bUseCase, bool bSearchFromEnd, int StartPosition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.FindSubstring");

	UKismetStringLibrary_FindSubstring_Params params {};
	params.SearchIn = SearchIn;
	params.Substring = Substring;
	params.bUseCase = bUseCase;
	params.bSearchFromEnd = bSearchFromEnd;
	params.StartPosition = StartPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D57EC0
//		Name   -> Function Engine.KismetStringLibrary.EqualEqual_StrStr
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     A                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     B                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetStringLibrary::STATIC_EqualEqual_StrStr(const struct FString& A, const struct FString& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EqualEqual_StrStr");

	UKismetStringLibrary_EqualEqual_StrStr_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D57FC0
//		Name   -> Function Engine.KismetStringLibrary.EqualEqual_StriStri
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     A                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     B                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetStringLibrary::STATIC_EqualEqual_StriStri(const struct FString& A, const struct FString& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EqualEqual_StriStri");

	UKismetStringLibrary_EqualEqual_StriStri_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D572B0
//		Name   -> Function Engine.KismetStringLibrary.EndsWith
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     InSuffix                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TEnumAsByte<CoreUObject_ESearchCase>               SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetStringLibrary::STATIC_EndsWith(const struct FString& SourceString, const struct FString& InSuffix, TEnumAsByte<CoreUObject_ESearchCase> SearchCase)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EndsWith");

	UKismetStringLibrary_EndsWith_Params params {};
	params.SourceString = SourceString;
	params.InSuffix = InSuffix;
	params.SearchCase = SearchCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D536C0
//		Name   -> Function Engine.KismetStringLibrary.CullArray
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     SourceString                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TArray<struct FString>                             InArray                                                    (Parm, OutParm, ZeroConstructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetStringLibrary::STATIC_CullArray(const struct FString& SourceString, TArray<struct FString>* InArray)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.CullArray");

	UKismetStringLibrary_CullArray_Params params {};
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (InArray != nullptr)
		*InArray = params.InArray;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52E50
//		Name   -> Function Engine.KismetStringLibrary.Conv_VectorToString
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector                                     InVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_VectorToString(const struct FVector& InVec)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_VectorToString");

	UKismetStringLibrary_Conv_VectorToString_Params params {};
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52C50
//		Name   -> Function Engine.KismetStringLibrary.Conv_Vector2dToString
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FVector2D                                   InVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_Vector2dToString(const struct FVector2D& InVec)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_Vector2dToString");

	UKismetStringLibrary_Conv_Vector2dToString_Params params {};
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52A30
//		Name   -> Function Engine.KismetStringLibrary.Conv_TransformToString
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  InTrans                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_TransformToString(const struct FTransform& InTrans)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_TransformToString");

	UKismetStringLibrary_Conv_TransformToString_Params params {};
	params.InTrans = InTrans;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D527C0
//		Name   -> Function Engine.KismetStringLibrary.Conv_StringToName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     InString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName UKismetStringLibrary::STATIC_Conv_StringToName(const struct FString& InString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToName");

	UKismetStringLibrary_Conv_StringToName_Params params {};
	params.InString = InString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52720
//		Name   -> Function Engine.KismetStringLibrary.Conv_StringToInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     InString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetStringLibrary::STATIC_Conv_StringToInt(const struct FString& InString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToInt");

	UKismetStringLibrary_Conv_StringToInt_Params params {};
	params.InString = InString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52680
//		Name   -> Function Engine.KismetStringLibrary.Conv_StringToFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     InString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetStringLibrary::STATIC_Conv_StringToFloat(const struct FString& InString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToFloat");

	UKismetStringLibrary_Conv_StringToFloat_Params params {};
	params.InString = InString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D524F0
//		Name   -> Function Engine.KismetStringLibrary.Conv_RotatorToString
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_RotatorToString(const struct FRotator& InRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_RotatorToString");

	UKismetStringLibrary_Conv_RotatorToString_Params params {};
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52410
//		Name   -> Function Engine.KismetStringLibrary.Conv_ObjectToString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     InObj                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_ObjectToString(class UObject* InObj)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ObjectToString");

	UKismetStringLibrary_Conv_ObjectToString_Params params {};
	params.InObj = InObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52280
//		Name   -> Function Engine.KismetStringLibrary.Conv_NameToString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_NameToString(const struct FName& InName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_NameToString");

	UKismetStringLibrary_Conv_NameToString_Params params {};
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51E60
//		Name   -> Function Engine.KismetStringLibrary.Conv_IntToString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_IntToString(int InInt)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_IntToString");

	UKismetStringLibrary_Conv_IntToString_Params params {};
	params.InInt = InInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51850
//		Name   -> Function Engine.KismetStringLibrary.Conv_FloatToString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_FloatToString(float InFloat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_FloatToString");

	UKismetStringLibrary_Conv_FloatToString_Params params {};
	params.InFloat = InFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D516E0
//		Name   -> Function Engine.KismetStringLibrary.Conv_ColorToString
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FLinearColor                                InColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_ColorToString(const struct FLinearColor& InColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ColorToString");

	UKismetStringLibrary_Conv_ColorToString_Params params {};
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D514E0
//		Name   -> Function Engine.KismetStringLibrary.Conv_ByteToString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      InByte                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_ByteToString(unsigned char InByte)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ByteToString");

	UKismetStringLibrary_Conv_ByteToString_Params params {};
	params.InByte = InByte;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51250
//		Name   -> Function Engine.KismetStringLibrary.Conv_BoolToString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Conv_BoolToString(bool InBool)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_BoolToString");

	UKismetStringLibrary_Conv_BoolToString_Params params {};
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D50960
//		Name   -> Function Engine.KismetStringLibrary.Concat_StrStr
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     A                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     B                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_Concat_StrStr(const struct FString& A, const struct FString& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Concat_StrStr");

	UKismetStringLibrary_Concat_StrStr_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4C860
//		Name   -> Function Engine.KismetStringLibrary.BuildString_Vector2d
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     AppendTo                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Prefix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FVector2D                                   InVector2D                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     Suffix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_BuildString_Vector2d(const struct FString& AppendTo, const struct FString& Prefix, const struct FVector2D& InVector2D, const struct FString& Suffix)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Vector2d");

	UKismetStringLibrary_BuildString_Vector2d_Params params {};
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InVector2D = InVector2D;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4CA40
//		Name   -> Function Engine.KismetStringLibrary.BuildString_Vector
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     AppendTo                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Prefix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FVector                                     InVector                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     Suffix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_BuildString_Vector(const struct FString& AppendTo, const struct FString& Prefix, const struct FVector& InVector, const struct FString& Suffix)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Vector");

	UKismetStringLibrary_BuildString_Vector_Params params {};
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InVector = InVector;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4C670
//		Name   -> Function Engine.KismetStringLibrary.BuildString_Rotator
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     AppendTo                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Prefix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     Suffix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_BuildString_Rotator(const struct FString& AppendTo, const struct FString& Prefix, const struct FRotator& InRot, const struct FString& Suffix)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Rotator");

	UKismetStringLibrary_BuildString_Rotator_Params params {};
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InRot = InRot;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4C490
//		Name   -> Function Engine.KismetStringLibrary.BuildString_Object
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     AppendTo                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Prefix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		class UObject*                                     InObj                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     Suffix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_BuildString_Object(const struct FString& AppendTo, const struct FString& Prefix, class UObject* InObj, const struct FString& Suffix)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Object");

	UKismetStringLibrary_BuildString_Object_Params params {};
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InObj = InObj;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4C2B0
//		Name   -> Function Engine.KismetStringLibrary.BuildString_Name
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     AppendTo                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Prefix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FName                                       InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     Suffix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_BuildString_Name(const struct FString& AppendTo, const struct FString& Prefix, const struct FName& InName, const struct FString& Suffix)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Name");

	UKismetStringLibrary_BuildString_Name_Params params {};
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InName = InName;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4C0D0
//		Name   -> Function Engine.KismetStringLibrary.BuildString_Int
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     AppendTo                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Prefix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		int                                                InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     Suffix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_BuildString_Int(const struct FString& AppendTo, const struct FString& Prefix, int InInt, const struct FString& Suffix)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Int");

	UKismetStringLibrary_BuildString_Int_Params params {};
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InInt = InInt;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4BEF0
//		Name   -> Function Engine.KismetStringLibrary.BuildString_Float
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     AppendTo                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Prefix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     Suffix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_BuildString_Float(const struct FString& AppendTo, const struct FString& Prefix, float InFloat, const struct FString& Suffix)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Float");

	UKismetStringLibrary_BuildString_Float_Params params {};
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InFloat = InFloat;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4BD10
//		Name   -> Function Engine.KismetStringLibrary.BuildString_Color
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     AppendTo                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Prefix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FLinearColor                                InColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     Suffix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_BuildString_Color(const struct FString& AppendTo, const struct FString& Prefix, const struct FLinearColor& InColor, const struct FString& Suffix)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Color");

	UKismetStringLibrary_BuildString_Color_Params params {};
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InColor = InColor;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4BB30
//		Name   -> Function Engine.KismetStringLibrary.BuildString_Bool
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     AppendTo                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Prefix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     Suffix                                                     (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetStringLibrary::STATIC_BuildString_Bool(const struct FString& AppendTo, const struct FString& Prefix, bool InBool, const struct FString& Suffix)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Bool");

	UKismetStringLibrary_BuildString_Bool_Params params {};
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InBool = InBool;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UKismetStringLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UKismetStringLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D75340
//		Name   -> Function Engine.KismetSystemLibrary.StackTrace
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
void UKismetSystemLibrary::STATIC_StackTrace()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.StackTrace");

	UKismetSystemLibrary_StackTrace_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D74560
//		Name   -> Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects");

	UKismetSystemLibrary_SphereTraceSingleForObjects_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D741B0
//		Name   -> Function Engine.KismetSystemLibrary.SphereTraceSingleByObject_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_ECollisionChannel>>      ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereTraceSingleByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<TEnumAsByte<Engine_ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingleByObject_DEPRECATED");

	UKismetSystemLibrary_SphereTraceSingleByObject_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.ObjectsToTrace = ObjectsToTrace;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D74C80
//		Name   -> Function Engine.KismetSystemLibrary.SphereTraceSingle_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ETraceTypeQuery>                TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereTraceSingle_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingle_NEW");

	UKismetSystemLibrary_SphereTraceSingle_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D74910
//		Name   -> Function Engine.KismetSystemLibrary.SphereTraceSingle_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECollisionChannel>              TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereTraceSingle_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingle_DEPRECATED");

	UKismetSystemLibrary_SphereTraceSingle_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D737E0
//		Name   -> Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects");

	UKismetSystemLibrary_SphereTraceMultiForObjects_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D73470
//		Name   -> Function Engine.KismetSystemLibrary.SphereTraceMultiByObject_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_ECollisionChannel>>      ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereTraceMultiByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<TEnumAsByte<Engine_ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMultiByObject_DEPRECATED");

	UKismetSystemLibrary_SphereTraceMultiByObject_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.ObjectsToTrace = ObjectsToTrace;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D73E80
//		Name   -> Function Engine.KismetSystemLibrary.SphereTraceMulti_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ETraceTypeQuery>                TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereTraceMulti_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMulti_NEW");

	UKismetSystemLibrary_SphereTraceMulti_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D73B50
//		Name   -> Function Engine.KismetSystemLibrary.SphereTraceMulti_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECollisionChannel>              TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereTraceMulti_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMulti_DEPRECATED");

	UKismetSystemLibrary_SphereTraceMulti_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D731E0
//		Name   -> Function Engine.KismetSystemLibrary.SphereOverlapComponents_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     SpherePos                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              SphereRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereOverlapComponents_NEW(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapComponents_NEW");

	UKismetSystemLibrary_SphereOverlapComponents_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.SpherePos = SpherePos;
	params.SphereRadius = SphereRadius;
	params.ObjectTypes = ObjectTypes;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D72F80
//		Name   -> Function Engine.KismetSystemLibrary.SphereOverlapComponents_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     SpherePos                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              SphereRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EOverlapFilterOption>           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereOverlapComponents_DEPRECATED(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TEnumAsByte<Engine_EOverlapFilterOption> Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapComponents_DEPRECATED");

	UKismetSystemLibrary_SphereOverlapComponents_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.SpherePos = SpherePos;
	params.SphereRadius = SphereRadius;
	params.Filter = Filter;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D72CF0
//		Name   -> Function Engine.KismetSystemLibrary.SphereOverlapActors_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     SpherePos                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              SphereRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereOverlapActors_NEW(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapActors_NEW");

	UKismetSystemLibrary_SphereOverlapActors_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.SpherePos = SpherePos;
	params.SphereRadius = SphereRadius;
	params.ObjectTypes = ObjectTypes;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D72A90
//		Name   -> Function Engine.KismetSystemLibrary.SphereOverlapActors_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     SpherePos                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              SphereRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EOverlapFilterOption>           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_SphereOverlapActors_DEPRECATED(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TEnumAsByte<Engine_EOverlapFilterOption> Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapActors_DEPRECATED");

	UKismetSystemLibrary_SphereOverlapActors_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.SpherePos = SpherePos;
	params.SphereRadius = SphereRadius;
	params.Filter = Filter;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D72800
//		Name   -> Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     CategoryName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_ShowPlatformSpecificLeaderboardScreen(const struct FString& CategoryName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen");

	UKismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen_Params params {};
	params.CategoryName = CategoryName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D72790
//		Name   -> Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class APlayerController*                           SpecificPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_ShowPlatformSpecificAchievementsScreen(class APlayerController* SpecificPlayer)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen");

	UKismetSystemLibrary_ShowPlatformSpecificAchievementsScreen_Params params {};
	params.SpecificPlayer = SpecificPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D726E0
//		Name   -> Function Engine.KismetSystemLibrary.ShowAdBanner
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		int                                                AdIdIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bShowOnBottomOfScreen                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_ShowAdBanner(int AdIdIndex, bool bShowOnBottomOfScreen)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowAdBanner");

	UKismetSystemLibrary_ShowAdBanner_Params params {};
	params.AdIdIndex = AdIdIndex;
	params.bShowOnBottomOfScreen = bShowOnBottomOfScreen;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D72620
//		Name   -> Function Engine.KismetSystemLibrary.SetWindowTitle
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FText                                       Title                                                      (ConstParm, Parm, OutParm, ReferenceParm)
void UKismetSystemLibrary::STATIC_SetWindowTitle(const struct FText& Title)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetWindowTitle");

	UKismetSystemLibrary_SetWindowTitle_Params params {};
	params.Title = Title;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D725A0
//		Name   -> Function Engine.KismetSystemLibrary.SetVolumeButtonsHandledBySystem
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_SetVolumeButtonsHandledBySystem(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetVolumeButtonsHandledBySystem");

	UKismetSystemLibrary_SetVolumeButtonsHandledBySystem_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D724A0
//		Name   -> Function Engine.KismetSystemLibrary.SetVectorPropertyByName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_SetVectorPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FVector& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetVectorPropertyByName");

	UKismetSystemLibrary_SetVectorPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D72200
//		Name   -> Function Engine.KismetSystemLibrary.SetTransformPropertyByName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_SetTransformPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FTransform& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetTransformPropertyByName");

	UKismetSystemLibrary_SetTransformPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D720E0
//		Name   -> Function Engine.KismetSystemLibrary.SetTextPropertyByName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FText                                       Value                                                      (ConstParm, Parm, OutParm, ReferenceParm)
void UKismetSystemLibrary::STATIC_SetTextPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FText& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetTextPropertyByName");

	UKismetSystemLibrary_SetTextPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D72020
//		Name   -> Function Engine.KismetSystemLibrary.SetSupressViewportTransitionMessage
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_SetSupressViewportTransitionMessage(class UObject* WorldContextObject, bool bState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSupressViewportTransitionMessage");

	UKismetSystemLibrary_SetSupressViewportTransitionMessage_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.bState = bState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71F30
//		Name   -> Function Engine.KismetSystemLibrary.SetStructurePropertyByName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FGenericStruct                              Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_SetStructurePropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FGenericStruct& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetStructurePropertyByName");

	UKismetSystemLibrary_SetStructurePropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71E20
//		Name   -> Function Engine.KismetSystemLibrary.SetStringPropertyByName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     Value                                                      (Parm, ZeroConstructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_SetStringPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FString& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetStringPropertyByName");

	UKismetSystemLibrary_SetStringPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71B60
//		Name   -> Function Engine.KismetSystemLibrary.SetRotatorPropertyByName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_SetRotatorPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FRotator& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetRotatorPropertyByName");

	UKismetSystemLibrary_SetRotatorPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D719A0
//		Name   -> Function Engine.KismetSystemLibrary.SetObjectPropertyByName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UObject*                                     Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_SetObjectPropertyByName(class UObject* Object, const struct FName& PropertyName, class UObject* Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetObjectPropertyByName");

	UKismetSystemLibrary_SetObjectPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71820
//		Name   -> Function Engine.KismetSystemLibrary.SetNamePropertyByName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_SetNamePropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FName& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetNamePropertyByName");

	UKismetSystemLibrary_SetNamePropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71700
//		Name   -> Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_SetLinearColorPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FLinearColor& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName");

	UKismetSystemLibrary_SetLinearColorPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71610
//		Name   -> Function Engine.KismetSystemLibrary.SetIntPropertyByName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_SetIntPropertyByName(class UObject* Object, const struct FName& PropertyName, int Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetIntPropertyByName");

	UKismetSystemLibrary_SetIntPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71510
//		Name   -> Function Engine.KismetSystemLibrary.SetFloatPropertyByName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_SetFloatPropertyByName(class UObject* Object, const struct FName& PropertyName, float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetFloatPropertyByName");

	UKismetSystemLibrary_SetFloatPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D713A0
//		Name   -> Function Engine.KismetSystemLibrary.SetCollisionProfileNameProperty
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FCollisionProfileName                       Value                                                      (ConstParm, Parm, OutParm, ReferenceParm)
void UKismetSystemLibrary::STATIC_SetCollisionProfileNameProperty(class UObject* Object, const struct FName& PropertyName, const struct FCollisionProfileName& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetCollisionProfileNameProperty");

	UKismetSystemLibrary_SetCollisionProfileNameProperty_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D712B0
//		Name   -> Function Engine.KismetSystemLibrary.SetClassPropertyByName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_SetClassPropertyByName(class UObject* Object, const struct FName& PropertyName, class UClass* Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetClassPropertyByName");

	UKismetSystemLibrary_SetClassPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D711C0
//		Name   -> Function Engine.KismetSystemLibrary.SetBytePropertyByName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_SetBytePropertyByName(class UObject* Object, const struct FName& PropertyName, unsigned char Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetBytePropertyByName");

	UKismetSystemLibrary_SetBytePropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D710C0
//		Name   -> Function Engine.KismetSystemLibrary.SetBoolPropertyByName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_SetBoolPropertyByName(class UObject* Object, const struct FName& PropertyName, bool Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetBoolPropertyByName");

	UKismetSystemLibrary_SetBoolPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D70F70
//		Name   -> Function Engine.KismetSystemLibrary.SetAssetPropertyByName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TAssetPtr<class UObject>                           Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_SetAssetPropertyByName(class UObject* Object, const struct FName& PropertyName, TAssetPtr<class UObject> Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetAssetPropertyByName");

	UKismetSystemLibrary_SetAssetPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D70E20
//		Name   -> Function Engine.KismetSystemLibrary.SetAssetClassPropertyByName
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TAssetPtr<class UClass>                            Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_SetAssetClassPropertyByName(class UObject* Object, const struct FName& PropertyName, TAssetPtr<class UClass> Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetAssetClassPropertyByName");

	UKismetSystemLibrary_SetAssetClassPropertyByName_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6F8F0
//		Name   -> Function Engine.KismetSystemLibrary.RetriggerableDelay
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
void UKismetSystemLibrary::STATIC_RetriggerableDelay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.RetriggerableDelay");

	UKismetSystemLibrary_RetriggerableDelay_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Duration = Duration;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6ECC0
//		Name   -> Function Engine.KismetSystemLibrary.ResetGamepadAssignmentToController
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		int                                                ControllerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_ResetGamepadAssignmentToController(int ControllerId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ResetGamepadAssignmentToController");

	UKismetSystemLibrary_ResetGamepadAssignmentToController_Params params {};
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6ED30
//		Name   -> Function Engine.KismetSystemLibrary.ResetGamepadAssignments
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
void UKismetSystemLibrary::STATIC_ResetGamepadAssignments()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ResetGamepadAssignments");

	UKismetSystemLibrary_ResetGamepadAssignments_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6E920
//		Name   -> Function Engine.KismetSystemLibrary.RegisterForRemoteNotifications
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
void UKismetSystemLibrary::STATIC_RegisterForRemoteNotifications()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.RegisterForRemoteNotifications");

	UKismetSystemLibrary_RegisterForRemoteNotifications_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6D200
//		Name   -> Function Engine.KismetSystemLibrary.QuitGame
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class APlayerController*                           SpecificPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EQuitPreference>                QuitPreference                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_QuitGame(class UObject* WorldContextObject, class APlayerController* SpecificPlayer, TEnumAsByte<Engine_EQuitPreference> QuitPreference)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.QuitGame");

	UKismetSystemLibrary_QuitGame_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.SpecificPlayer = SpecificPlayer;
	params.QuitPreference = QuitPreference;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6CE50
//		Name   -> Function Engine.KismetSystemLibrary.PrintWarning
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     InString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_PrintWarning(const struct FString& InString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintWarning");

	UKismetSystemLibrary_PrintWarning_Params params {};
	params.InString = InString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6CC50
//		Name   -> Function Engine.KismetSystemLibrary.PrintText
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FText                                       InText                                                     (ConstParm, Parm)
//		bool                                               bPrintToScreen                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		bool                                               bPrintToLog                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FLinearColor                                TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_PrintText(class UObject* WorldContextObject, const struct FText& InText, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintText");

	UKismetSystemLibrary_PrintText_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.InText = InText;
	params.bPrintToScreen = bPrintToScreen;
	params.bPrintToLog = bPrintToLog;
	params.TextColor = TextColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6CA50
//		Name   -> Function Engine.KismetSystemLibrary.PrintString
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     InString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               bPrintToScreen                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		bool                                               bPrintToLog                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		struct FLinearColor                                TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_PrintString(class UObject* WorldContextObject, const struct FString& InString, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintString");

	UKismetSystemLibrary_PrintString_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.InString = InString;
	params.bPrintToScreen = bPrintToScreen;
	params.bPrintToLog = bPrintToLog;
	params.TextColor = TextColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.KismetSystemLibrary.OnAssetLoaded__DelegateSignature
//		Flags  -> (Public, Delegate)
// Parameters:
//		class UObject*                                     Loaded                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::OnAssetLoaded__DelegateSignature(class UObject* Loaded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.KismetSystemLibrary.OnAssetLoaded__DelegateSignature");

	UKismetSystemLibrary_OnAssetLoaded__DelegateSignature_Params params {};
	params.Loaded = Loaded;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.KismetSystemLibrary.OnAssetClassLoaded__DelegateSignature
//		Flags  -> (Public, Delegate)
// Parameters:
//		class UClass*                                      Loaded                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void UKismetSystemLibrary::OnAssetClassLoaded__DelegateSignature(class UClass* Loaded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.KismetSystemLibrary.OnAssetClassLoaded__DelegateSignature");

	UKismetSystemLibrary_OnAssetClassLoaded__DelegateSignature_Params params {};
	params.Loaded = Loaded;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D69050
//		Name   -> Function Engine.KismetSystemLibrary.MoveComponentTo
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     TargetRelativeLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    TargetRelativeRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bEaseOut                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bEaseIn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              OverTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EMoveComponentAction>           MoveAction                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
void UKismetSystemLibrary::STATIC_MoveComponentTo(class USceneComponent* Component, const struct FVector& TargetRelativeLocation, const struct FRotator& TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, TEnumAsByte<Engine_EMoveComponentAction> MoveAction, const struct FLatentActionInfo& LatentInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MoveComponentTo");

	UKismetSystemLibrary_MoveComponentTo_Params params {};
	params.Component = Component;
	params.TargetRelativeLocation = TargetRelativeLocation;
	params.TargetRelativeRotation = TargetRelativeRotation;
	params.bEaseOut = bEaseOut;
	params.bEaseIn = bEaseIn;
	params.OverTime = OverTime;
	params.MoveAction = MoveAction;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D666A0
//		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralText
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       Value                                                      (Parm)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetSystemLibrary::STATIC_MakeLiteralText(const struct FText& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralText");

	UKismetSystemLibrary_MakeLiteralText_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D665B0
//		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     Value                                                      (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetSystemLibrary::STATIC_MakeLiteralString(const struct FString& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralString");

	UKismetSystemLibrary_MakeLiteralString_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66520
//		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName UKismetSystemLibrary::STATIC_MakeLiteralName(const struct FName& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralName");

	UKismetSystemLibrary_MakeLiteralName_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D664A0
//		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetSystemLibrary::STATIC_MakeLiteralInt(int Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralInt");

	UKismetSystemLibrary_MakeLiteralInt_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66420
//		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralFloat
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetSystemLibrary::STATIC_MakeLiteralFloat(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralFloat");

	UKismetSystemLibrary_MakeLiteralFloat_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D663A0
//		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralByte
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
unsigned char UKismetSystemLibrary::STATIC_MakeLiteralByte(unsigned char Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralByte");

	UKismetSystemLibrary_MakeLiteralByte_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D66320
//		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralBool
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_MakeLiteralBool(bool Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralBool");

	UKismetSystemLibrary_MakeLiteralBool_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D65890
//		Name   -> Function Engine.KismetSystemLibrary.LoadAssetClass
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TAssetPtr<class UClass>                            AssetClass                                                 (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash)
//		struct FScriptDelegate                             OnLoaded                                                   (Parm, ZeroConstructor, NoDestructor)
//		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
void UKismetSystemLibrary::STATIC_LoadAssetClass(class UObject* WorldContextObject, TAssetPtr<class UClass> AssetClass, const struct FScriptDelegate& OnLoaded, const struct FLatentActionInfo& LatentInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAssetClass");

	UKismetSystemLibrary_LoadAssetClass_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.AssetClass = AssetClass;
	params.OnLoaded = OnLoaded;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D656D0
//		Name   -> Function Engine.KismetSystemLibrary.LoadAsset
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TAssetPtr<class UObject>                           Asset                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash)
//		struct FScriptDelegate                             OnLoaded                                                   (Parm, ZeroConstructor, NoDestructor)
//		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
void UKismetSystemLibrary::STATIC_LoadAsset(class UObject* WorldContextObject, TAssetPtr<class UObject> Asset, const struct FScriptDelegate& OnLoaded, const struct FLatentActionInfo& LatentInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAsset");

	UKismetSystemLibrary_LoadAsset_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Asset = Asset;
	params.OnLoaded = OnLoaded;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D64AE0
//		Name   -> Function Engine.KismetSystemLibrary.LineTraceSingleForObjects
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_LineTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingleForObjects");

	UKismetSystemLibrary_LineTraceSingleForObjects_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D64770
//		Name   -> Function Engine.KismetSystemLibrary.LineTraceSingleByObject_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<TEnumAsByte<Engine_ECollisionChannel>>      ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_LineTraceSingleByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<TEnumAsByte<Engine_ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingleByObject_DEPRECATED");

	UKismetSystemLibrary_LineTraceSingleByObject_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.ObjectsToTrace = ObjectsToTrace;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D65170
//		Name   -> Function Engine.KismetSystemLibrary.LineTraceSingle_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ETraceTypeQuery>                TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_LineTraceSingle_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TEnumAsByte<Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingle_NEW");

	UKismetSystemLibrary_LineTraceSingle_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D64E50
//		Name   -> Function Engine.KismetSystemLibrary.LineTraceSingle_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ECollisionChannel>              TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_LineTraceSingle_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TEnumAsByte<Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingle_DEPRECATED");

	UKismetSystemLibrary_LineTraceSingle_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D63E60
//		Name   -> Function Engine.KismetSystemLibrary.LineTraceMultiForObjects
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_LineTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMultiForObjects");

	UKismetSystemLibrary_LineTraceMultiForObjects_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D63B30
//		Name   -> Function Engine.KismetSystemLibrary.LineTraceMultiByObject_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<TEnumAsByte<Engine_ECollisionChannel>>      ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_LineTraceMultiByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<TEnumAsByte<Engine_ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMultiByObject_DEPRECATED");

	UKismetSystemLibrary_LineTraceMultiByObject_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.ObjectsToTrace = ObjectsToTrace;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D64480
//		Name   -> Function Engine.KismetSystemLibrary.LineTraceMulti_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ETraceTypeQuery>                TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_LineTraceMulti_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TEnumAsByte<Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMulti_NEW");

	UKismetSystemLibrary_LineTraceMulti_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D64190
//		Name   -> Function Engine.KismetSystemLibrary.LineTraceMulti_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ECollisionChannel>              TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_LineTraceMulti_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TEnumAsByte<Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMulti_DEPRECATED");

	UKismetSystemLibrary_LineTraceMulti_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62900
//		Name   -> Function Engine.KismetSystemLibrary.LaunchURL
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_LaunchURL(const struct FString& URL)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LaunchURL");

	UKismetSystemLibrary_LaunchURL_Params params {};
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D62350
//		Name   -> Function Engine.KismetSystemLibrary.K2_UnPauseTimerHandle
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimerHandle                                Handle                                                     (Parm)
void UKismetSystemLibrary::STATIC_K2_UnPauseTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimerHandle");

	UKismetSystemLibrary_K2_UnPauseTimerHandle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D622B0
//		Name   -> Function Engine.KismetSystemLibrary.K2_UnPauseTimerDelegate
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FScriptDelegate                             Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
void UKismetSystemLibrary::STATIC_K2_UnPauseTimerDelegate(const struct FScriptDelegate& Delegate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimerDelegate");

	UKismetSystemLibrary_K2_UnPauseTimerDelegate_Params params {};
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D621D0
//		Name   -> Function Engine.KismetSystemLibrary.K2_UnPauseTimer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_K2_UnPauseTimer(class UObject* Object, const struct FString& FunctionName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimer");

	UKismetSystemLibrary_K2_UnPauseTimer_Params params {};
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D62110
//		Name   -> Function Engine.KismetSystemLibrary.K2_TimerExistsHandle
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimerHandle                                Handle                                                     (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_K2_TimerExistsHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExistsHandle");

	UKismetSystemLibrary_K2_TimerExistsHandle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D62060
//		Name   -> Function Engine.KismetSystemLibrary.K2_TimerExistsDelegate
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FScriptDelegate                             Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_K2_TimerExistsDelegate(const struct FScriptDelegate& Delegate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExistsDelegate");

	UKismetSystemLibrary_K2_TimerExistsDelegate_Params params {};
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D61F70
//		Name   -> Function Engine.KismetSystemLibrary.K2_TimerExists
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_K2_TimerExists(class UObject* Object, const struct FString& FunctionName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExists");

	UKismetSystemLibrary_K2_TimerExists_Params params {};
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D61C10
//		Name   -> Function Engine.KismetSystemLibrary.K2_SetTimerDelegate
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FScriptDelegate                             Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FTimerHandle                                ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FTimerHandle UKismetSystemLibrary::STATIC_K2_SetTimerDelegate(const struct FScriptDelegate& Delegate, float Time, bool bLooping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimerDelegate");

	UKismetSystemLibrary_K2_SetTimerDelegate_Params params {};
	params.Delegate = Delegate;
	params.Time = Time;
	params.bLooping = bLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D61A70
//		Name   -> Function Engine.KismetSystemLibrary.K2_SetTimer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FTimerHandle                                ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FTimerHandle UKismetSystemLibrary::STATIC_K2_SetTimer(class UObject* Object, const struct FString& FunctionName, float Time, bool bLooping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimer");

	UKismetSystemLibrary_K2_SetTimer_Params params {};
	params.Object = Object;
	params.FunctionName = FunctionName;
	params.Time = Time;
	params.bLooping = bLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D61900
//		Name   -> Function Engine.KismetSystemLibrary.K2_PauseTimerHandle
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimerHandle                                Handle                                                     (Parm)
void UKismetSystemLibrary::STATIC_K2_PauseTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimerHandle");

	UKismetSystemLibrary_K2_PauseTimerHandle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D61860
//		Name   -> Function Engine.KismetSystemLibrary.K2_PauseTimerDelegate
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FScriptDelegate                             Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
void UKismetSystemLibrary::STATIC_K2_PauseTimerDelegate(const struct FScriptDelegate& Delegate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimerDelegate");

	UKismetSystemLibrary_K2_PauseTimerDelegate_Params params {};
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D61780
//		Name   -> Function Engine.KismetSystemLibrary.K2_PauseTimer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_K2_PauseTimer(class UObject* Object, const struct FString& FunctionName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimer");

	UKismetSystemLibrary_K2_PauseTimer_Params params {};
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D61700
//		Name   -> Function Engine.KismetSystemLibrary.K2_IsValidTimerHandle
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimerHandle                                Handle                                                     (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_K2_IsValidTimerHandle(const struct FTimerHandle& Handle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsValidTimerHandle");

	UKismetSystemLibrary_K2_IsValidTimerHandle_Params params {};
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D61640
//		Name   -> Function Engine.KismetSystemLibrary.K2_IsTimerPausedHandle
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimerHandle                                Handle                                                     (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_K2_IsTimerPausedHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPausedHandle");

	UKismetSystemLibrary_K2_IsTimerPausedHandle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D61590
//		Name   -> Function Engine.KismetSystemLibrary.K2_IsTimerPausedDelegate
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FScriptDelegate                             Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_K2_IsTimerPausedDelegate(const struct FScriptDelegate& Delegate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPausedDelegate");

	UKismetSystemLibrary_K2_IsTimerPausedDelegate_Params params {};
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D614A0
//		Name   -> Function Engine.KismetSystemLibrary.K2_IsTimerPaused
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_K2_IsTimerPaused(class UObject* Object, const struct FString& FunctionName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPaused");

	UKismetSystemLibrary_K2_IsTimerPaused_Params params {};
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D613E0
//		Name   -> Function Engine.KismetSystemLibrary.K2_IsTimerActiveHandle
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimerHandle                                Handle                                                     (Parm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_K2_IsTimerActiveHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActiveHandle");

	UKismetSystemLibrary_K2_IsTimerActiveHandle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D61330
//		Name   -> Function Engine.KismetSystemLibrary.K2_IsTimerActiveDelegate
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FScriptDelegate                             Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_K2_IsTimerActiveDelegate(const struct FScriptDelegate& Delegate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActiveDelegate");

	UKismetSystemLibrary_K2_IsTimerActiveDelegate_Params params {};
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D61240
//		Name   -> Function Engine.KismetSystemLibrary.K2_IsTimerActive
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_K2_IsTimerActive(class UObject* Object, const struct FString& FunctionName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActive");

	UKismetSystemLibrary_K2_IsTimerActive_Params params {};
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D611A0
//		Name   -> Function Engine.KismetSystemLibrary.K2_InvalidateTimerHandle
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FTimerHandle                                Handle                                                     (Parm, OutParm, ReferenceParm)
//		struct FTimerHandle                                ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FTimerHandle UKismetSystemLibrary::STATIC_K2_InvalidateTimerHandle(struct FTimerHandle* Handle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_InvalidateTimerHandle");

	UKismetSystemLibrary_K2_InvalidateTimerHandle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Handle != nullptr)
		*Handle = params.Handle;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D610D0
//		Name   -> Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeHandle
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimerHandle                                Handle                                                     (Parm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetSystemLibrary::STATIC_K2_GetTimerRemainingTimeHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeHandle");

	UKismetSystemLibrary_K2_GetTimerRemainingTimeHandle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D61020
//		Name   -> Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeDelegate
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FScriptDelegate                             Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetSystemLibrary::STATIC_K2_GetTimerRemainingTimeDelegate(const struct FScriptDelegate& Delegate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeDelegate");

	UKismetSystemLibrary_K2_GetTimerRemainingTimeDelegate_Params params {};
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D60F30
//		Name   -> Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetSystemLibrary::STATIC_K2_GetTimerRemainingTime(class UObject* Object, const struct FString& FunctionName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime");

	UKismetSystemLibrary_K2_GetTimerRemainingTime_Params params {};
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D60E60
//		Name   -> Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeHandle
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimerHandle                                Handle                                                     (Parm)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetSystemLibrary::STATIC_K2_GetTimerElapsedTimeHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeHandle");

	UKismetSystemLibrary_K2_GetTimerElapsedTimeHandle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D60DB0
//		Name   -> Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeDelegate
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FScriptDelegate                             Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetSystemLibrary::STATIC_K2_GetTimerElapsedTimeDelegate(const struct FScriptDelegate& Delegate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeDelegate");

	UKismetSystemLibrary_K2_GetTimerElapsedTimeDelegate_Params params {};
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D60CC0
//		Name   -> Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetSystemLibrary::STATIC_K2_GetTimerElapsedTime(class UObject* Object, const struct FString& FunctionName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime");

	UKismetSystemLibrary_K2_GetTimerElapsedTime_Params params {};
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5F850
//		Name   -> Function Engine.KismetSystemLibrary.K2_ClearTimerHandle
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTimerHandle                                Handle                                                     (Parm)
void UKismetSystemLibrary::STATIC_K2_ClearTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimerHandle");

	UKismetSystemLibrary_K2_ClearTimerHandle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5F7B0
//		Name   -> Function Engine.KismetSystemLibrary.K2_ClearTimerDelegate
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FScriptDelegate                             Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
void UKismetSystemLibrary::STATIC_K2_ClearTimerDelegate(const struct FScriptDelegate& Delegate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimerDelegate");

	UKismetSystemLibrary_K2_ClearTimerDelegate_Params params {};
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5F6D0
//		Name   -> Function Engine.KismetSystemLibrary.K2_ClearTimer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     FunctionName                                               (Parm, ZeroConstructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_K2_ClearTimer(class UObject* Object, const struct FString& FunctionName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimer");

	UKismetSystemLibrary_K2_ClearTimer_Params params {};
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5F420
//		Name   -> Function Engine.KismetSystemLibrary.IsValidClass
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_IsValidClass(class UClass* Class)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidClass");

	UKismetSystemLibrary_IsValidClass_Params params {};
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5F3A0
//		Name   -> Function Engine.KismetSystemLibrary.IsValid
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_IsValid(class UObject* Object)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValid");

	UKismetSystemLibrary_IsValid_Params params {};
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5F320
//		Name   -> Function Engine.KismetSystemLibrary.IsServer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_IsServer(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsServer");

	UKismetSystemLibrary_IsServer_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5F200
//		Name   -> Function Engine.KismetSystemLibrary.IsPackagedForDistribution
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_IsPackagedForDistribution()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsPackagedForDistribution");

	UKismetSystemLibrary_IsPackagedForDistribution_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5EEF0
//		Name   -> Function Engine.KismetSystemLibrary.IsLoggedIn
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APlayerController*                           SpecificPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_IsLoggedIn(class APlayerController* SpecificPlayer)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsLoggedIn");

	UKismetSystemLibrary_IsLoggedIn_Params params {};
	params.SpecificPlayer = SpecificPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5EDC0
//		Name   -> Function Engine.KismetSystemLibrary.IsDedicatedServer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_IsDedicatedServer(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsDedicatedServer");

	UKismetSystemLibrary_IsDedicatedServer_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5ED40
//		Name   -> Function Engine.KismetSystemLibrary.IsControllerAssignedToGamepad
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ControllerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_IsControllerAssignedToGamepad(int ControllerId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsControllerAssignedToGamepad");

	UKismetSystemLibrary_IsControllerAssignedToGamepad_Params params {};
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5DAF0
//		Name   -> Function Engine.KismetSystemLibrary.HideAdBanner
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
void UKismetSystemLibrary::STATIC_HideAdBanner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.HideAdBanner");

	UKismetSystemLibrary_HideAdBanner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5CBA0
//		Name   -> Function Engine.KismetSystemLibrary.GetVolumeButtonsHandledBySystem
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_GetVolumeButtonsHandledBySystem()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetVolumeButtonsHandledBySystem");

	UKismetSystemLibrary_GetVolumeButtonsHandledBySystem_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C4F0
//		Name   -> Function Engine.KismetSystemLibrary.GetUniqueDeviceId
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetSystemLibrary::STATIC_GetUniqueDeviceId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetUniqueDeviceId");

	UKismetSystemLibrary_GetUniqueDeviceId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5C0F0
//		Name   -> Function Engine.KismetSystemLibrary.GetSupportedFullscreenResolutions
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<struct FIntPoint>                           Resolutions                                                (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_GetSupportedFullscreenResolutions(TArray<struct FIntPoint>* Resolutions)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSupportedFullscreenResolutions");

	UKismetSystemLibrary_GetSupportedFullscreenResolutions_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Resolutions != nullptr)
		*Resolutions = params.Resolutions;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BCD0
//		Name   -> Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetSystemLibrary::STATIC_GetRenderingMaterialQualityLevel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel");

	UKismetSystemLibrary_GetRenderingMaterialQualityLevel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BCA0
//		Name   -> Function Engine.KismetSystemLibrary.GetRenderingDetailMode
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetSystemLibrary::STATIC_GetRenderingDetailMode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetRenderingDetailMode");

	UKismetSystemLibrary_GetRenderingDetailMode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BB10
//		Name   -> Function Engine.KismetSystemLibrary.GetPreferredLanguages
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UKismetSystemLibrary::STATIC_GetPreferredLanguages()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPreferredLanguages");

	UKismetSystemLibrary_GetPreferredLanguages_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5BA70
//		Name   -> Function Engine.KismetSystemLibrary.GetPlatformUserName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetSystemLibrary::STATIC_GetPlatformUserName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPlatformUserName");

	UKismetSystemLibrary_GetPlatformUserName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B9C0
//		Name   -> Function Engine.KismetSystemLibrary.GetObjectNameAsCrc32
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetSystemLibrary::STATIC_GetObjectNameAsCrc32(class UObject* Object)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetObjectNameAsCrc32");

	UKismetSystemLibrary_GetObjectNameAsCrc32_Params params {};
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B8E0
//		Name   -> Function Engine.KismetSystemLibrary.GetObjectName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetSystemLibrary::STATIC_GetObjectName(class UObject* Object)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetObjectName");

	UKismetSystemLibrary_GetObjectName_Params params {};
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B5D0
//		Name   -> Function Engine.KismetSystemLibrary.GetMaxShadowCascades
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetSystemLibrary::STATIC_GetMaxShadowCascades()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetMaxShadowCascades");

	UKismetSystemLibrary_GetMaxShadowCascades_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B4A0
//		Name   -> Function Engine.KismetSystemLibrary.GetLocalCurrencySymbol
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetSystemLibrary::STATIC_GetLocalCurrencySymbol()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetLocalCurrencySymbol");

	UKismetSystemLibrary_GetLocalCurrencySymbol_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B400
//		Name   -> Function Engine.KismetSystemLibrary.GetLocalCurrencyCode
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetSystemLibrary::STATIC_GetLocalCurrencyCode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetLocalCurrencyCode");

	UKismetSystemLibrary_GetLocalCurrencyCode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5B030
//		Name   -> Function Engine.KismetSystemLibrary.GetGameTimeInSeconds
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UKismetSystemLibrary::STATIC_GetGameTimeInSeconds(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameTimeInSeconds");

	UKismetSystemLibrary_GetGameTimeInSeconds_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5AF90
//		Name   -> Function Engine.KismetSystemLibrary.GetGameName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetSystemLibrary::STATIC_GetGameName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameName");

	UKismetSystemLibrary_GetGameName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5AB80
//		Name   -> Function Engine.KismetSystemLibrary.GetEngineVersion
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetSystemLibrary::STATIC_GetEngineVersion()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetEngineVersion");

	UKismetSystemLibrary_GetEngineVersion_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A9C0
//		Name   -> Function Engine.KismetSystemLibrary.GetDisplayName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetSystemLibrary::STATIC_GetDisplayName(class UObject* Object)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDisplayName");

	UKismetSystemLibrary_GetDisplayName_Params params {};
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A590
//		Name   -> Function Engine.KismetSystemLibrary.GetComponentBounds
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class USceneComponent*                             Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Origin                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     BoxExtent                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              SphereRadius                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_GetComponentBounds(class USceneComponent* Component, struct FVector* Origin, struct FVector* BoxExtent, float* SphereRadius)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetComponentBounds");

	UKismetSystemLibrary_GetComponentBounds_Params params {};
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Origin != nullptr)
		*Origin = params.Origin;
	if (BoxExtent != nullptr)
		*BoxExtent = params.BoxExtent;
	if (SphereRadius != nullptr)
		*SphereRadius = params.SphereRadius;

}


// Function:
//		Offset -> 0x02D5A4B0
//		Name   -> Function Engine.KismetSystemLibrary.GetClassDisplayName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetSystemLibrary::STATIC_GetClassDisplayName(class UClass* Class)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetClassDisplayName");

	UKismetSystemLibrary_GetClassDisplayName_Params params {};
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5A000
//		Name   -> Function Engine.KismetSystemLibrary.GetAdIDCount
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UKismetSystemLibrary::STATIC_GetAdIDCount()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetAdIDCount");

	UKismetSystemLibrary_GetAdIDCount_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D59EA0
//		Name   -> Function Engine.KismetSystemLibrary.GetActorListFromComponentList
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<class UPrimitiveComponent*>                 ComponentList                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference)
//		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              OutActorList                                               (Parm, OutParm, ZeroConstructor)
void UKismetSystemLibrary::STATIC_GetActorListFromComponentList(TArray<class UPrimitiveComponent*> ComponentList, class UClass* ActorClassFilter, TArray<class AActor*>* OutActorList)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetActorListFromComponentList");

	UKismetSystemLibrary_GetActorListFromComponentList_Params params {};
	params.ComponentList = ComponentList;
	params.ActorClassFilter = ActorClassFilter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActorList != nullptr)
		*OutActorList = params.OutActorList;

}


// Function:
//		Offset -> 0x02D59D90
//		Name   -> Function Engine.KismetSystemLibrary.GetActorBounds
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Origin                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     BoxExtent                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_GetActorBounds(class AActor* Actor, struct FVector* Origin, struct FVector* BoxExtent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetActorBounds");

	UKismetSystemLibrary_GetActorBounds_Params params {};
	params.Actor = Actor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Origin != nullptr)
		*Origin = params.Origin;
	if (BoxExtent != nullptr)
		*BoxExtent = params.BoxExtent;

}


// Function:
//		Offset -> 0x02D597C0
//		Name   -> Function Engine.KismetSystemLibrary.ForceCloseAdBanner
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
void UKismetSystemLibrary::STATIC_ForceCloseAdBanner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ForceCloseAdBanner");

	UKismetSystemLibrary_ForceCloseAdBanner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D59710
//		Name   -> Function Engine.KismetSystemLibrary.FlushPersistentDebugLines
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_FlushPersistentDebugLines(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.FlushPersistentDebugLines");

	UKismetSystemLibrary_FlushPersistentDebugLines_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D59680
//		Name   -> Function Engine.KismetSystemLibrary.FlushDebugStrings
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_FlushDebugStrings(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.FlushDebugStrings");

	UKismetSystemLibrary_FlushDebugStrings_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D58550
//		Name   -> Function Engine.KismetSystemLibrary.ExecuteConsoleCommand
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash)
//		class APlayerController*                           SpecificPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_ExecuteConsoleCommand(class UObject* WorldContextObject, const struct FString& Command, class APlayerController* SpecificPlayer)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ExecuteConsoleCommand");

	UKismetSystemLibrary_ExecuteConsoleCommand_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Command = Command;
	params.SpecificPlayer = SpecificPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D56DB0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugString
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     TextLocation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash)
//		class AActor*                                      TestBaseActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugString(class UObject* WorldContextObject, const struct FVector& TextLocation, const struct FString& Text, class AActor* TestBaseActor, const struct FLinearColor& TextColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugString");

	UKismetSystemLibrary_DrawDebugString_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.TextLocation = TextLocation;
	params.Text = Text;
	params.TestBaseActor = TestBaseActor;
	params.TextColor = TextColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D56BE0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugSphere
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Center                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Segments                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugSphere(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int Segments, const struct FLinearColor& LineColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugSphere");

	UKismetSystemLibrary_DrawDebugSphere_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Center = Center;
	params.Radius = Radius;
	params.Segments = Segments;
	params.LineColor = LineColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D56A50
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugPoint
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Position                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                PointColor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugPoint(class UObject* WorldContextObject, const struct FVector& Position, float Size, const struct FLinearColor& PointColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugPoint");

	UKismetSystemLibrary_DrawDebugPoint_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Position = Position;
	params.Size = Size;
	params.PointColor = PointColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D56880
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugPlane
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FPlane                                      PlaneCoordinates                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                PlaneColor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugPlane(class UObject* WorldContextObject, const struct FPlane& PlaneCoordinates, const struct FVector& Location, float Size, const struct FLinearColor& PlaneColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugPlane");

	UKismetSystemLibrary_DrawDebugPlane_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PlaneCoordinates = PlaneCoordinates;
	params.Location = Location;
	params.Size = Size;
	params.PlaneColor = PlaneColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D566A0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugLine
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     LineStart                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     LineEnd                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugLine(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugLine");

	UKismetSystemLibrary_DrawDebugLine_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.LineStart = LineStart;
	params.LineEnd = LineEnd;
	params.LineColor = LineColor;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D564E0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugFrustum
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  FrustumTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                FrustumColor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugFrustum(class UObject* WorldContextObject, const struct FTransform& FrustumTransform, const struct FLinearColor& FrustumColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFrustum");

	UKismetSystemLibrary_DrawDebugFrustum_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.FrustumTransform = FrustumTransform;
	params.FrustumColor = FrustumColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D56260
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FDebugFloatHistory                          FloatHistory                                               (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FTransform                                  DrawTransform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   DrawSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                DrawColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugFloatHistoryTransform(class UObject* WorldContextObject, const struct FDebugFloatHistory& FloatHistory, const struct FTransform& DrawTransform, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform");

	UKismetSystemLibrary_DrawDebugFloatHistoryTransform_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.FloatHistory = FloatHistory;
	params.DrawTransform = DrawTransform;
	params.DrawSize = DrawSize;
	params.DrawColor = DrawColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D56050
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FDebugFloatHistory                          FloatHistory                                               (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FVector                                     DrawLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   DrawSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                DrawColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugFloatHistoryLocation(class UObject* WorldContextObject, const struct FDebugFloatHistory& FloatHistory, const struct FVector& DrawLocation, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation");

	UKismetSystemLibrary_DrawDebugFloatHistoryLocation_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.FloatHistory = FloatHistory;
	params.DrawLocation = DrawLocation;
	params.DrawSize = DrawSize;
	params.DrawColor = DrawColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D55E40
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCylinder
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Segments                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugCylinder(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, int Segments, const struct FLinearColor& LineColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCylinder");

	UKismetSystemLibrary_DrawDebugCylinder_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.Segments = Segments;
	params.LineColor = LineColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D55CB0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     AxisLoc                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    AxisRot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugCoordinateSystem(class UObject* WorldContextObject, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem");

	UKismetSystemLibrary_DrawDebugCoordinateSystem_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.AxisLoc = AxisLoc;
	params.AxisRot = AxisRot;
	params.Scale = Scale;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D55A10
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Origin                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Direction                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Length                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              AngleWidth                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              AngleHeight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NumSides                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugConeInDegrees(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, const struct FLinearColor& LineColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees");

	UKismetSystemLibrary_DrawDebugConeInDegrees_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Origin = Origin;
	params.Direction = Direction;
	params.Length = Length;
	params.AngleWidth = AngleWidth;
	params.AngleHeight = AngleHeight;
	params.NumSides = NumSides;
	params.LineColor = LineColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D557C0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCone
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Origin                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Direction                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Length                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              AngleWidth                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              AngleHeight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NumSides                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_DrawDebugCone(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, const struct FLinearColor& LineColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCone");

	UKismetSystemLibrary_DrawDebugCone_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Origin = Origin;
	params.Direction = Direction;
	params.Length = Length;
	params.AngleWidth = AngleWidth;
	params.AngleHeight = AngleHeight;
	params.NumSides = NumSides;
	params.LineColor = LineColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D554E0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCircle
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Center                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NumSegments                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     YAxis                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ZAxis                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bDrawAxis                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_DrawDebugCircle(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int NumSegments, const struct FLinearColor& LineColor, float Duration, float Thickness, const struct FVector& YAxis, const struct FVector& ZAxis, bool bDrawAxis)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCircle");

	UKismetSystemLibrary_DrawDebugCircle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Center = Center;
	params.Radius = Radius;
	params.NumSegments = NumSegments;
	params.LineColor = LineColor;
	params.Duration = Duration;
	params.Thickness = Thickness;
	params.YAxis = YAxis;
	params.ZAxis = ZAxis;
	params.bDrawAxis = bDrawAxis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D552C0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCapsule
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Center                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    Rotation                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugCapsule(class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FRotator& Rotation, const struct FLinearColor& LineColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCapsule");

	UKismetSystemLibrary_DrawDebugCapsule_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Center = Center;
	params.HalfHeight = HalfHeight;
	params.Radius = Radius;
	params.Rotation = Rotation;
	params.LineColor = LineColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D551C0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCamera
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class ACameraActor*                                CameraActor                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                CameraColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugCamera(class ACameraActor* CameraActor, const struct FLinearColor& CameraColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCamera");

	UKismetSystemLibrary_DrawDebugCamera_Params params {};
	params.CameraActor = CameraActor;
	params.CameraColor = CameraColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D54FD0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugBox
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Center                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Extent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Rotation                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugBox(class UObject* WorldContextObject, const struct FVector& Center, const struct FVector& Extent, const struct FLinearColor& LineColor, const struct FRotator& Rotation, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugBox");

	UKismetSystemLibrary_DrawDebugBox_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Center = Center;
	params.Extent = Extent;
	params.LineColor = LineColor;
	params.Rotation = Rotation;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D54DF0
//		Name   -> Function Engine.KismetSystemLibrary.DrawDebugArrow
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     LineStart                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     LineEnd                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              ArrowSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_DrawDebugArrow(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FLinearColor& LineColor, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugArrow");

	UKismetSystemLibrary_DrawDebugArrow_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.LineStart = LineStart;
	params.LineEnd = LineEnd;
	params.ArrowSize = ArrowSize;
	params.LineColor = LineColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D54BA0
//		Name   -> Function Engine.KismetSystemLibrary.DoesImplementInterface
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     TestObject                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      Interface                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_DoesImplementInterface(class UObject* TestObject, class UClass* Interface)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DoesImplementInterface");

	UKismetSystemLibrary_DoesImplementInterface_Params params {};
	params.TestObject = TestObject;
	params.Interface = Interface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D542E0
//		Name   -> Function Engine.KismetSystemLibrary.Delay
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
void UKismetSystemLibrary::STATIC_Delay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Delay");

	UKismetSystemLibrary_Delay_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Duration = Duration;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D532D0
//		Name   -> Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     ObjectToModify                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UKismetSystemLibrary::STATIC_CreateCopyForUndoBuffer(class UObject* ObjectToModify)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer");

	UKismetSystemLibrary_CreateCopyForUndoBuffer_Params params {};
	params.ObjectToModify = ObjectToModify;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D520C0
//		Name   -> Function Engine.KismetSystemLibrary.Conv_InterfaceToObject
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UObject* UKismetSystemLibrary::STATIC_Conv_InterfaceToObject()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_InterfaceToObject");

	UKismetSystemLibrary_Conv_InterfaceToObject_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D50FF0
//		Name   -> Function Engine.KismetSystemLibrary.Conv_AssetToObject
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TAssetPtr<class UObject>                           Asset                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash)
//		class UObject*                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UObject* UKismetSystemLibrary::STATIC_Conv_AssetToObject(TAssetPtr<class UObject> Asset)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_AssetToObject");

	UKismetSystemLibrary_Conv_AssetToObject_Params params {};
	params.Asset = Asset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D50F10
//		Name   -> Function Engine.KismetSystemLibrary.Conv_AssetClassToClass
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TAssetPtr<class UClass>                            AssetClass                                                 (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash)
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
class UClass* UKismetSystemLibrary::STATIC_Conv_AssetClassToClass(TAssetPtr<class UClass> AssetClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_AssetClassToClass");

	UKismetSystemLibrary_Conv_AssetClassToClass_Params params {};
	params.AssetClass = AssetClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D50AB0
//		Name   -> Function Engine.KismetSystemLibrary.ControlScreensaver
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		bool                                               bAllowScreenSaver                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UKismetSystemLibrary::STATIC_ControlScreensaver(bool bAllowScreenSaver)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ControlScreensaver");

	UKismetSystemLibrary_ControlScreensaver_Params params {};
	params.bAllowScreenSaver = bAllowScreenSaver;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D50410
//		Name   -> Function Engine.KismetSystemLibrary.ComponentOverlapComponents_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UPrimitiveComponent*                         Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  ComponentTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_ComponentOverlapComponents_NEW(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapComponents_NEW");

	UKismetSystemLibrary_ComponentOverlapComponents_NEW_Params params {};
	params.Component = Component;
	params.ComponentTransform = ComponentTransform;
	params.ObjectTypes = ObjectTypes;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D50190
//		Name   -> Function Engine.KismetSystemLibrary.ComponentOverlapComponents_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UPrimitiveComponent*                         Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  ComponentTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EOverlapFilterOption>           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_ComponentOverlapComponents_DEPRECATED(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, TEnumAsByte<Engine_EOverlapFilterOption> Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapComponents_DEPRECATED");

	UKismetSystemLibrary_ComponentOverlapComponents_DEPRECATED_Params params {};
	params.Component = Component;
	params.ComponentTransform = ComponentTransform;
	params.Filter = Filter;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4FEE0
//		Name   -> Function Engine.KismetSystemLibrary.ComponentOverlapActors_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UPrimitiveComponent*                         Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  ComponentTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_ComponentOverlapActors_NEW(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapActors_NEW");

	UKismetSystemLibrary_ComponentOverlapActors_NEW_Params params {};
	params.Component = Component;
	params.ComponentTransform = ComponentTransform;
	params.ObjectTypes = ObjectTypes;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4FC60
//		Name   -> Function Engine.KismetSystemLibrary.ComponentOverlapActors_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UPrimitiveComponent*                         Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  ComponentTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EOverlapFilterOption>           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_ComponentOverlapActors_DEPRECATED(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, TEnumAsByte<Engine_EOverlapFilterOption> Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapActors_DEPRECATED");

	UKismetSystemLibrary_ComponentOverlapActors_DEPRECATED_Params params {};
	params.Component = Component;
	params.ComponentTransform = ComponentTransform;
	params.Filter = Filter;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4FC40
//		Name   -> Function Engine.KismetSystemLibrary.CollectGarbage
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
void UKismetSystemLibrary::STATIC_CollectGarbage()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CollectGarbage");

	UKismetSystemLibrary_CollectGarbage_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D4EAC0
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects");

	UKismetSystemLibrary_CapsuleTraceSingleForObjects_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4E6D0
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceSingleByObject_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_ECollisionChannel>>      ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleTraceSingleByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<TEnumAsByte<Engine_ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingleByObject_DEPRECATED");

	UKismetSystemLibrary_CapsuleTraceSingleByObject_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ObjectsToTrace = ObjectsToTrace;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4F260
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceSingle_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ETraceTypeQuery>                TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleTraceSingle_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TEnumAsByte<Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingle_NEW");

	UKismetSystemLibrary_CapsuleTraceSingle_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4EEB0
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceSingle_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECollisionChannel>              TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleTraceSingle_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TEnumAsByte<Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingle_DEPRECATED");

	UKismetSystemLibrary_CapsuleTraceSingle_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4DC40
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects");

	UKismetSystemLibrary_CapsuleTraceMultiForObjects_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4D890
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceMultiByObject_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_ECollisionChannel>>      ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleTraceMultiByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<TEnumAsByte<Engine_ECollisionChannel>> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMultiByObject_DEPRECATED");

	UKismetSystemLibrary_CapsuleTraceMultiByObject_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ObjectsToTrace = ObjectsToTrace;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4E360
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceMulti_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ETraceTypeQuery>                TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleTraceMulti_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TEnumAsByte<Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMulti_NEW");

	UKismetSystemLibrary_CapsuleTraceMulti_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4DFF0
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceMulti_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECollisionChannel>              TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleTraceMulti_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TEnumAsByte<Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMulti_DEPRECATED");

	UKismetSystemLibrary_CapsuleTraceMulti_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4D5C0
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleOverlapComponents_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     CapsulePos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleOverlapComponents_NEW(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapComponents_NEW");

	UKismetSystemLibrary_CapsuleOverlapComponents_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.CapsulePos = CapsulePos;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ObjectTypes = ObjectTypes;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4D330
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleOverlapComponents_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     CapsulePos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EOverlapFilterOption>           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleOverlapComponents_DEPRECATED(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TEnumAsByte<Engine_EOverlapFilterOption> Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapComponents_DEPRECATED");

	UKismetSystemLibrary_CapsuleOverlapComponents_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.CapsulePos = CapsulePos;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.Filter = Filter;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4D060
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleOverlapActors_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     CapsulePos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleOverlapActors_NEW(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapActors_NEW");

	UKismetSystemLibrary_CapsuleOverlapActors_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.CapsulePos = CapsulePos;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ObjectTypes = ObjectTypes;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4CDD0
//		Name   -> Function Engine.KismetSystemLibrary.CapsuleOverlapActors_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     CapsulePos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EOverlapFilterOption>           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_CapsuleOverlapActors_DEPRECATED(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TEnumAsByte<Engine_EOverlapFilterOption> Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapActors_DEPRECATED");

	UKismetSystemLibrary_CapsuleOverlapActors_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.CapsulePos = CapsulePos;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.Filter = Filter;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D4A3B0
//		Name   -> Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     HalfSize                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Orientation                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_BoxTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects");

	UKismetSystemLibrary_BoxTraceSingleForObjects_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.HalfSize = HalfSize;
	params.Orientation = Orientation;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D49FF0
//		Name   -> Function Engine.KismetSystemLibrary.BoxTraceSingle
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     HalfSize                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Orientation                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ETraceTypeQuery>                TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FHitResult                                  OutHit                                                     (Parm, OutParm, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_BoxTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TEnumAsByte<Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingle");

	UKismetSystemLibrary_BoxTraceSingle_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.HalfSize = HalfSize;
	params.Orientation = Orientation;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D49C00
//		Name   -> Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     HalfSize                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Orientation                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_BoxTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects");

	UKismetSystemLibrary_BoxTraceMultiForObjects_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.HalfSize = HalfSize;
	params.Orientation = Orientation;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D49870
//		Name   -> Function Engine.KismetSystemLibrary.BoxTraceMulti
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     HalfSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    Orientation                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_ETraceTypeQuery>                TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_EDrawDebugTrace>                DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_BoxTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TEnumAsByte<Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, TEnumAsByte<Engine_EDrawDebugTrace> DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMulti");

	UKismetSystemLibrary_BoxTraceMulti_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.HalfSize = HalfSize;
	params.Orientation = Orientation;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D495D0
//		Name   -> Function Engine.KismetSystemLibrary.BoxOverlapComponents_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     BoxPos                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Extent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_BoxOverlapComponents_NEW(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapComponents_NEW");

	UKismetSystemLibrary_BoxOverlapComponents_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.BoxPos = BoxPos;
	params.Extent = Extent;
	params.ObjectTypes = ObjectTypes;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D49370
//		Name   -> Function Engine.KismetSystemLibrary.BoxOverlapComponents_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     BoxPos                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     Extent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EOverlapFilterOption>           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_BoxOverlapComponents_DEPRECATED(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, TEnumAsByte<Engine_EOverlapFilterOption> Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapComponents_DEPRECATED");

	UKismetSystemLibrary_BoxOverlapComponents_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.BoxPos = BoxPos;
	params.Extent = Extent;
	params.Filter = Filter;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D490D0
//		Name   -> Function Engine.KismetSystemLibrary.BoxOverlapActors_NEW
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     BoxPos                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     BoxExtent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TArray<TEnumAsByte<Engine_EObjectTypeQuery>>       ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_BoxOverlapActors_NEW(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, TArray<TEnumAsByte<Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapActors_NEW");

	UKismetSystemLibrary_BoxOverlapActors_NEW_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.BoxPos = BoxPos;
	params.BoxExtent = BoxExtent;
	params.ObjectTypes = ObjectTypes;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48E70
//		Name   -> Function Engine.KismetSystemLibrary.BoxOverlapActors_DEPRECATED
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     BoxPos                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     BoxExtent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EOverlapFilterOption>           Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetSystemLibrary::STATIC_BoxOverlapActors_DEPRECATED(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, TEnumAsByte<Engine_EOverlapFilterOption> Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapActors_DEPRECATED");

	UKismetSystemLibrary_BoxOverlapActors_DEPRECATED_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.BoxPos = BoxPos;
	params.BoxExtent = BoxExtent;
	params.Filter = Filter;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D45C40
//		Name   -> Function Engine.KismetSystemLibrary.AddFloatHistorySample
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FDebugFloatHistory                          FloatHistory                                               (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FDebugFloatHistory                          ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FDebugFloatHistory UKismetSystemLibrary::STATIC_AddFloatHistorySample(float Value, const struct FDebugFloatHistory& FloatHistory)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.AddFloatHistorySample");

	UKismetSystemLibrary_AddFloatHistorySample_Params params {};
	params.Value = Value;
	params.FloatHistory = FloatHistory;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UKismetSystemLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UKismetSystemLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D76CA0
//		Name   -> Function Engine.KismetTextLibrary.TextTrimTrailing
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_TextTrimTrailing(const struct FText& InText)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimTrailing");

	UKismetTextLibrary_TextTrimTrailing_Params params {};
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76BD0
//		Name   -> Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_TextTrimPrecedingAndTrailing(const struct FText& InText)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing");

	UKismetTextLibrary_TextTrimPrecedingAndTrailing_Params params {};
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76B00
//		Name   -> Function Engine.KismetTextLibrary.TextTrimPreceding
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_TextTrimPreceding(const struct FText& InText)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimPreceding");

	UKismetTextLibrary_TextTrimPreceding_Params params {};
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D76A50
//		Name   -> Function Engine.KismetTextLibrary.TextIsTransient
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetTextLibrary::STATIC_TextIsTransient(const struct FText& InText)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsTransient");

	UKismetTextLibrary_TextIsTransient_Params params {};
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D769A0
//		Name   -> Function Engine.KismetTextLibrary.TextIsEmpty
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetTextLibrary::STATIC_TextIsEmpty(const struct FText& InText)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsEmpty");

	UKismetTextLibrary_TextIsEmpty_Params params {};
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D768F0
//		Name   -> Function Engine.KismetTextLibrary.TextIsCultureInvariant
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetTextLibrary::STATIC_TextIsCultureInvariant(const struct FText& InText)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsCultureInvariant");

	UKismetTextLibrary_TextIsCultureInvariant_Params params {};
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6B270
//		Name   -> Function Engine.KismetTextLibrary.NotEqual_TextText
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       A                                                          (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FText                                       B                                                          (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetTextLibrary::STATIC_NotEqual_TextText(const struct FText& A, const struct FText& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.NotEqual_TextText");

	UKismetTextLibrary_NotEqual_TextText_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6ABF0
//		Name   -> Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       A                                                          (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FText                                       B                                                          (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetTextLibrary::STATIC_NotEqual_IgnoreCase_TextText(const struct FText& A, const struct FText& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText");

	UKismetTextLibrary_NotEqual_IgnoreCase_TextText_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5AB30
//		Name   -> Function Engine.KismetTextLibrary.GetEmptyText
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_GetEmptyText()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.GetEmptyText");

	UKismetTextLibrary_GetEmptyText_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D597E0
//		Name   -> Function Engine.KismetTextLibrary.Format
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       InPattern                                                  (Parm)
//		TArray<struct FFormatTextArgument>                 InArgs                                                     (Parm, ZeroConstructor)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_Format(const struct FText& InPattern, TArray<struct FFormatTextArgument> InArgs)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Format");

	UKismetTextLibrary_Format_Params params {};
	params.InPattern = InPattern;
	params.InArgs = InArgs;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D59410
//		Name   -> Function Engine.KismetTextLibrary.FindTextInLocalizationTable
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     Namespace                                                  (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FText                                       OutText                                                    (Parm, OutParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetTextLibrary::STATIC_FindTextInLocalizationTable(const struct FString& Namespace, const struct FString& Key, struct FText* OutText)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.FindTextInLocalizationTable");

	UKismetTextLibrary_FindTextInLocalizationTable_Params params {};
	params.Namespace = Namespace;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutText != nullptr)
		*OutText = params.OutText;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D580C0
//		Name   -> Function Engine.KismetTextLibrary.EqualEqual_TextText
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       A                                                          (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FText                                       B                                                          (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetTextLibrary::STATIC_EqualEqual_TextText(const struct FText& A, const struct FText& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.EqualEqual_TextText");

	UKismetTextLibrary_EqualEqual_TextText_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D578B0
//		Name   -> Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       A                                                          (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FText                                       B                                                          (ConstParm, Parm, OutParm, ReferenceParm)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UKismetTextLibrary::STATIC_EqualEqual_IgnoreCase_TextText(const struct FText& A, const struct FText& B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText");

	UKismetTextLibrary_EqualEqual_IgnoreCase_TextText_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52930
//		Name   -> Function Engine.KismetTextLibrary.Conv_TextToString
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FText                                       InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UKismetTextLibrary::STATIC_Conv_TextToString(const struct FText& InText)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_TextToString");

	UKismetTextLibrary_Conv_TextToString_Params params {};
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52870
//		Name   -> Function Engine.KismetTextLibrary.Conv_StringToText
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     InString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_Conv_StringToText(const struct FString& InString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_StringToText");

	UKismetTextLibrary_Conv_StringToText_Params params {};
	params.InString = InString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D52360
//		Name   -> Function Engine.KismetTextLibrary.Conv_NameToText
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_Conv_NameToText(const struct FName& InName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_NameToText");

	UKismetTextLibrary_Conv_NameToText_Params params {};
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51F40
//		Name   -> Function Engine.KismetTextLibrary.Conv_IntToText
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUseGrouping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		int                                                MinimumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MaximumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_Conv_IntToText(int Value, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_IntToText");

	UKismetTextLibrary_Conv_IntToText_Params params {};
	params.Value = Value;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51930
//		Name   -> Function Engine.KismetTextLibrary.Conv_FloatToText
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ERoundingMode>                  RoundingMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		bool                                               bUseGrouping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		int                                                MinimumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MaximumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MinimumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MaximumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_Conv_FloatToText(float Value, TEnumAsByte<Engine_ERoundingMode> RoundingMode, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_FloatToText");

	UKismetTextLibrary_Conv_FloatToText_Params params {};
	params.Value = Value;
	params.RoundingMode = RoundingMode;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;
	params.MinimumFractionalDigits = MinimumFractionalDigits;
	params.MaximumFractionalDigits = MaximumFractionalDigits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D515C0
//		Name   -> Function Engine.KismetTextLibrary.Conv_ByteToText
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_Conv_ByteToText(unsigned char Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ByteToText");

	UKismetTextLibrary_Conv_ByteToText_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D51330
//		Name   -> Function Engine.KismetTextLibrary.Conv_BoolToText
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_Conv_BoolToText(bool InBool)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_BoolToText");

	UKismetTextLibrary_Conv_BoolToText_Params params {};
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48720
//		Name   -> Function Engine.KismetTextLibrary.AsTimespan_Timespan
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTimespan                                   InTimespan                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_AsTimespan_Timespan(const struct FTimespan& InTimespan)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimespan_Timespan");

	UKismetTextLibrary_AsTimespan_Timespan_Params params {};
	params.InTimespan = InTimespan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48670
//		Name   -> Function Engine.KismetTextLibrary.AsTime_DateTime
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   In                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_AsTime_DateTime(const struct FDateTime& In)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTime_DateTime");

	UKismetTextLibrary_AsTime_DateTime_Params params {};
	params.In = In;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48440
//		Name   -> Function Engine.KismetTextLibrary.AsPercent_Float
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ERoundingMode>                  RoundingMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		bool                                               bUseGrouping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		int                                                MinimumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MaximumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MinimumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MaximumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_AsPercent_Float(float Value, TEnumAsByte<Engine_ERoundingMode> RoundingMode, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsPercent_Float");

	UKismetTextLibrary_AsPercent_Float_Params params {};
	params.Value = Value;
	params.RoundingMode = RoundingMode;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;
	params.MinimumFractionalDigits = MinimumFractionalDigits;
	params.MaximumFractionalDigits = MaximumFractionalDigits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D482E0
//		Name   -> Function Engine.KismetTextLibrary.AsDateTime_DateTime
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   In                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_AsDateTime_DateTime(const struct FDateTime& In)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsDateTime_DateTime");

	UKismetTextLibrary_AsDateTime_DateTime_Params params {};
	params.In = In;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48390
//		Name   -> Function Engine.KismetTextLibrary.AsDate_DateTime
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDateTime                                   InDateTime                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_AsDate_DateTime(const struct FDateTime& InDateTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsDate_DateTime");

	UKismetTextLibrary_AsDate_DateTime_Params params {};
	params.InDateTime = InDateTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D48060
//		Name   -> Function Engine.KismetTextLibrary.AsCurrency_Integer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ERoundingMode>                  RoundingMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		bool                                               bUseGrouping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		int                                                MinimumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MaximumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MinimumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MaximumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FString                                     CurrencyCode                                               (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_AsCurrency_Integer(int Value, TEnumAsByte<Engine_ERoundingMode> RoundingMode, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits, const struct FString& CurrencyCode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrency_Integer");

	UKismetTextLibrary_AsCurrency_Integer_Params params {};
	params.Value = Value;
	params.RoundingMode = RoundingMode;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;
	params.MinimumFractionalDigits = MinimumFractionalDigits;
	params.MaximumFractionalDigits = MaximumFractionalDigits;
	params.CurrencyCode = CurrencyCode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D47DD0
//		Name   -> Function Engine.KismetTextLibrary.AsCurrency_Float
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ERoundingMode>                  RoundingMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		bool                                               bUseGrouping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
//		int                                                MinimumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MaximumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MinimumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		int                                                MaximumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FString                                     CurrencyCode                                               (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash)
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm)
struct FText UKismetTextLibrary::STATIC_AsCurrency_Float(float Value, TEnumAsByte<Engine_ERoundingMode> RoundingMode, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits, const struct FString& CurrencyCode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrency_Float");

	UKismetTextLibrary_AsCurrency_Float_Params params {};
	params.Value = Value;
	params.RoundingMode = RoundingMode;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;
	params.MinimumFractionalDigits = MinimumFractionalDigits;
	params.MaximumFractionalDigits = MaximumFractionalDigits;
	params.CurrencyCode = CurrencyCode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UKismetTextLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UKismetTextLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D78880
//		Name   -> Function Engine.LoadingPerfBPFuncLib.WriteTimings
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
void ULoadingPerfBPFuncLib::STATIC_WriteTimings()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LoadingPerfBPFuncLib.WriteTimings");

	ULoadingPerfBPFuncLib_WriteTimings_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D67C40
//		Name   -> Function Engine.LoadingPerfBPFuncLib.MarkEndStreaming
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
void ULoadingPerfBPFuncLib::STATIC_MarkEndStreaming()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LoadingPerfBPFuncLib.MarkEndStreaming");

	ULoadingPerfBPFuncLib_MarkEndStreaming_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ULoadingPerfBPFuncLib::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void ULoadingPerfBPFuncLib::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

void UWorldComposition::AfterRead()
{
	UObject::AfterRead();

}

void UWorldComposition::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UNestedWorldComposition::AfterRead()
{
	UWorldComposition::AfterRead();

}

void UNestedWorldComposition::BeforeDelete()
{
	UWorldComposition::BeforeDelete();

}

// Function:
//		Offset -> 0x02D776C0
//		Name   -> Function Engine.NestedWorldCompositionFunctionLib.TriggerManualNestedLevelUnload
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PackageName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNestedWorldCompositionFunctionLib::STATIC_TriggerManualNestedLevelUnload(class UObject* WorldContextObject, const struct FName& PackageName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NestedWorldCompositionFunctionLib.TriggerManualNestedLevelUnload");

	UNestedWorldCompositionFunctionLib_TriggerManualNestedLevelUnload_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D77610
//		Name   -> Function Engine.NestedWorldCompositionFunctionLib.TriggerManualNestedLevelLoad
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PackageName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNestedWorldCompositionFunctionLib::STATIC_TriggerManualNestedLevelLoad(class UObject* WorldContextObject, const struct FName& PackageName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NestedWorldCompositionFunctionLib.TriggerManualNestedLevelLoad");

	UNestedWorldCompositionFunctionLib_TriggerManualNestedLevelLoad_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5F0A0
//		Name   -> Function Engine.NestedWorldCompositionFunctionLib.IsNestedLevelVisibleRecursive
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PackageName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNestedWorldCompositionFunctionLib::STATIC_IsNestedLevelVisibleRecursive(class UObject* WorldContextObject, const struct FName& PackageName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NestedWorldCompositionFunctionLib.IsNestedLevelVisibleRecursive");

	UNestedWorldCompositionFunctionLib_IsNestedLevelVisibleRecursive_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D5EFE0
//		Name   -> Function Engine.NestedWorldCompositionFunctionLib.IsNestedLevelVisible
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PackageName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNestedWorldCompositionFunctionLib::STATIC_IsNestedLevelVisible(class UObject* WorldContextObject, const struct FName& PackageName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NestedWorldCompositionFunctionLib.IsNestedLevelVisible");

	UNestedWorldCompositionFunctionLib_IsNestedLevelVisible_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UNestedWorldCompositionFunctionLib::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UNestedWorldCompositionFunctionLib::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D67D10
//		Name   -> Function Engine.NetPushModelHelpers.MarkPropertyDirtyFromRepIndex
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                RepIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNetPushModelHelpers::STATIC_MarkPropertyDirtyFromRepIndex(class UObject* Object, int RepIndex, const struct FName& PropertyName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NetPushModelHelpers.MarkPropertyDirtyFromRepIndex");

	UNetPushModelHelpers_MarkPropertyDirtyFromRepIndex_Params params {};
	params.Object = Object;
	params.RepIndex = RepIndex;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D67C60
//		Name   -> Function Engine.NetPushModelHelpers.MarkPropertyDirty
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNetPushModelHelpers::STATIC_MarkPropertyDirty(class UObject* Object, const struct FName& PropertyName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NetPushModelHelpers.MarkPropertyDirty");

	UNetPushModelHelpers_MarkPropertyDirty_Params params {};
	params.Object = Object;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UNetPushModelHelpers::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UNetPushModelHelpers::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D6F030
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmitterWithShortQuarterResArea
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ShortQuarterRes                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmitterWithShortQuarterResArea(class UParticleSystemComponent* Component, float ShortQuarterRes)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmitterWithShortQuarterResArea");

	UParticleWarningFunctions_RetrieveInfoOnEmitterWithShortQuarterResArea_Params params {};
	params.Component = Component;
	params.ShortQuarterRes = ShortQuarterRes;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6EF00
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmitterWithLongNearTransition
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LongNearTransition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmitterWithLongNearTransition(class UParticleSystemComponent* Component, float LongNearTransition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmitterWithLongNearTransition");

	UParticleWarningFunctions_RetrieveInfoOnEmitterWithLongNearTransition_Params params {};
	params.Component = Component;
	params.LongNearTransition = LongNearTransition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6EDD0
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmitterWithLongFarTransition
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LongFarTransition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmitterWithLongFarTransition(class UParticleSystemComponent* Component, float LongFarTransition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmitterWithLongFarTransition");

	UParticleWarningFunctions_RetrieveInfoOnEmitterWithLongFarTransition_Params params {};
	params.Component = Component;
	params.LongFarTransition = LongFarTransition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6F810
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithoutPerVertexLighting
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmittersWithoutPerVertexLighting(class UParticleSystemComponent* Component)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithoutPerVertexLighting");

	UParticleWarningFunctions_RetrieveInfoOnEmittersWithoutPerVertexLighting_Params params {};
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6F6E0
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithLowAlphaThreshold
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LowAlphaThreshold                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmittersWithLowAlphaThreshold(class UParticleSystemComponent* Component, float LowAlphaThreshold)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithLowAlphaThreshold");

	UParticleWarningFunctions_RetrieveInfoOnEmittersWithLowAlphaThreshold_Params params {};
	params.Component = Component;
	params.LowAlphaThreshold = LowAlphaThreshold;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6F600
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithLoopZero
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmittersWithLoopZero(class UParticleSystemComponent* Component)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithLoopZero");

	UParticleWarningFunctions_RetrieveInfoOnEmittersWithLoopZero_Params params {};
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6F520
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithKillOnCompleteUnticked
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmittersWithKillOnCompleteUnticked(class UParticleSystemComponent* Component)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithKillOnCompleteUnticked");

	UParticleWarningFunctions_RetrieveInfoOnEmittersWithKillOnCompleteUnticked_Params params {};
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6F400
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithHighSpawnRate
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                HighSpawnRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmittersWithHighSpawnRate(class UParticleSystemComponent* Component, int HighSpawnRate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithHighSpawnRate");

	UParticleWarningFunctions_RetrieveInfoOnEmittersWithHighSpawnRate_Params params {};
	params.Component = Component;
	params.HighSpawnRate = HighSpawnRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6F320
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithDurationZero
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmittersWithDurationZero(class UParticleSystemComponent* Component)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersWithDurationZero");

	UParticleWarningFunctions_RetrieveInfoOnEmittersWithDurationZero_Params params {};
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6F240
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersUsingMaxDrawCount
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmittersUsingMaxDrawCount(class UParticleSystemComponent* Component)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersUsingMaxDrawCount");

	UParticleWarningFunctions_RetrieveInfoOnEmittersUsingMaxDrawCount_Params params {};
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D6F160
//		Name   -> Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersOnCPU
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm)
TArray<struct FString> UParticleWarningFunctions::STATIC_RetrieveInfoOnEmittersOnCPU(class UParticleSystemComponent* Component)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleWarningFunctions.RetrieveInfoOnEmittersOnCPU");

	UParticleWarningFunctions_RetrieveInfoOnEmittersOnCPU_Params params {};
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UParticleWarningFunctions::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UParticleWarningFunctions::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D684A0
//		Name   -> Function Engine.SkeletalMeshMergeBlueprintFunctionLibrary.MergeSkeletalMeshesWithMorphTargets
//		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<class USkeletalMesh*>                       Meshes                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<struct FName>                               MorphTargetNames                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TArray<float>                                      MorphTargetWeights                                         (ConstParm, Parm, ZeroConstructor)
//		class USkeletalMesh*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class USkeletalMesh* USkeletalMeshMergeBlueprintFunctionLibrary::STATIC_MergeSkeletalMeshesWithMorphTargets(TArray<class USkeletalMesh*> Meshes, TArray<struct FName> MorphTargetNames, TArray<float> MorphTargetWeights)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshMergeBlueprintFunctionLibrary.MergeSkeletalMeshesWithMorphTargets");

	USkeletalMeshMergeBlueprintFunctionLibrary_MergeSkeletalMeshesWithMorphTargets_Params params {};
	params.Meshes = Meshes;
	params.MorphTargetNames = MorphTargetNames;
	params.MorphTargetWeights = MorphTargetWeights;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D683F0
//		Name   -> Function Engine.SkeletalMeshMergeBlueprintFunctionLibrary.MergeSkeletalMeshes
//		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<class USkeletalMesh*>                       Meshes                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		class USkeletalMesh*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class USkeletalMesh* USkeletalMeshMergeBlueprintFunctionLibrary::STATIC_MergeSkeletalMeshes(TArray<class USkeletalMesh*> Meshes)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshMergeBlueprintFunctionLibrary.MergeSkeletalMeshes");

	USkeletalMeshMergeBlueprintFunctionLibrary_MergeSkeletalMeshes_Params params {};
	params.Meshes = Meshes;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void USkeletalMeshMergeBlueprintFunctionLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void USkeletalMeshMergeBlueprintFunctionLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

// Function:
//		Offset -> 0x02D65E30
//		Name   -> Function Engine.VisualLoggerKismetLibrary.LogText
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FName                                       LogCategory                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UVisualLoggerKismetLibrary::STATIC_LogText(class UObject* WorldContextObject, const struct FString& Text, const struct FName& LogCategory)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogText");

	UVisualLoggerKismetLibrary_LogText_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Text = Text;
	params.LogCategory = LogCategory;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D65C30
//		Name   -> Function Engine.VisualLoggerKismetLibrary.LogLocation
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FLinearColor                                ObjectColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       LogCategory                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UVisualLoggerKismetLibrary::STATIC_LogLocation(class UObject* WorldContextObject, const struct FVector& Location, const struct FString& Text, const struct FLinearColor& ObjectColor, float Radius, const struct FName& LogCategory)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogLocation");

	UVisualLoggerKismetLibrary_LogLocation_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Location = Location;
	params.Text = Text;
	params.ObjectColor = ObjectColor;
	params.Radius = Radius;
	params.LogCategory = LogCategory;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D65A50
//		Name   -> Function Engine.VisualLoggerKismetLibrary.LogBox
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FBox                                        BoxShape                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FLinearColor                                ObjectColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FName                                       LogCategory                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UVisualLoggerKismetLibrary::STATIC_LogBox(class UObject* WorldContextObject, const struct FBox& BoxShape, const struct FString& Text, const struct FLinearColor& ObjectColor, const struct FName& LogCategory)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogBox");

	UVisualLoggerKismetLibrary_LogBox_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.BoxShape = BoxShape;
	params.Text = Text;
	params.ObjectColor = ObjectColor;
	params.LogCategory = LogCategory;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UVisualLoggerKismetLibrary::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

}

void UVisualLoggerKismetLibrary::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

}

void UAnimBlueprintGeneratedClass::AfterRead()
{
	UBlueprintGeneratedClass::AfterRead();

	READ_PTR_FULL(TargetSkeleton, USkeleton);
}

void UAnimBlueprintGeneratedClass::BeforeDelete()
{
	UBlueprintGeneratedClass::BeforeDelete();

	DELE_PTR_FULL(TargetSkeleton);
}

void URendererSettings::AfterRead()
{
	UDeveloperSettings::AfterRead();

}

void URendererSettings::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

}

void UTextureLODSettings::AfterRead()
{
	UObject::AfterRead();

}

void UTextureLODSettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UDeviceProfile::AfterRead()
{
	UTextureLODSettings::AfterRead();

	READ_PTR_FULL(Parent, UObject);
}

void UDeviceProfile::BeforeDelete()
{
	UTextureLODSettings::BeforeDelete();

	DELE_PTR_FULL(Parent);
}

void UDeviceProfileManager::AfterRead()
{
	UObject::AfterRead();

}

void UDeviceProfileManager::BeforeDelete()
{
	UObject::BeforeDelete();

}

void ULightmassPrimitiveSettingsObject::AfterRead()
{
	UObject::AfterRead();

}

void ULightmassPrimitiveSettingsObject::BeforeDelete()
{
	UObject::BeforeDelete();

}

void ULocalMessage::AfterRead()
{
	UObject::AfterRead();

}

void ULocalMessage::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UEngineMessage::AfterRead()
{
	ULocalMessage::AfterRead();

}

void UEngineMessage::BeforeDelete()
{
	ULocalMessage::BeforeDelete();

}

void UMaterialExpressionAbs::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionAbs::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionActorPositionWS::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionActorPositionWS::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionAdd::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionAdd::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionDepthOfFieldFunction::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDepthOfFieldFunction::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionDesaturation::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDesaturation::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionDistanceFieldGradient::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDistanceFieldGradient::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UParticleModuleRotationRateBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleRotationRateBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleRotationRate::AfterRead()
{
	UParticleModuleRotationRateBase::AfterRead();

}

void UParticleModuleRotationRate::BeforeDelete()
{
	UParticleModuleRotationRateBase::BeforeDelete();

}

void UParticleModuleRotationRate_Seeded::AfterRead()
{
	UParticleModuleRotationRate::AfterRead();

}

void UParticleModuleRotationRate_Seeded::BeforeDelete()
{
	UParticleModuleRotationRate::BeforeDelete();

}

// Function:
//		Offset -> 0x02A2F7B0
//		Name   -> Function Engine.CurveFloat.GetFloatValue
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              InTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UCurveFloat::GetFloatValue(float InTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CurveFloat.GetFloatValue");

	UCurveFloat_GetFloatValue_Params params {};
	params.InTime = InTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UCurveFloat::AfterRead()
{
	UCurveBase::AfterRead();

}

void UCurveFloat::BeforeDelete()
{
	UCurveBase::BeforeDelete();

}

void UForceFeedbackEffect::AfterRead()
{
	UObject::AfterRead();

}

void UForceFeedbackEffect::BeforeDelete()
{
	UObject::BeforeDelete();

}

void ALogVisualizerCameraController::AfterRead()
{
	ADebugCameraController::AfterRead();

	READ_PTR_FULL(PickedActor, AActor);
}

void ALogVisualizerCameraController::BeforeDelete()
{
	ADebugCameraController::BeforeDelete();

	DELE_PTR_FULL(PickedActor);
}

// Function:
//		Offset -> 0x02B3C780
//		Name   -> Function Engine.DecalActor.SetDecalMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          NewDecalMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ADecalActor::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.SetDecalMaterial");

	ADecalActor_SetDecalMaterial_Params params {};
	params.NewDecalMaterial = NewDecalMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B31F80
//		Name   -> Function Engine.DecalActor.GetDecalMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UMaterialInterface*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInterface* ADecalActor::GetDecalMaterial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.GetDecalMaterial");

	ADecalActor_GetDecalMaterial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F480
//		Name   -> Function Engine.DecalActor.CreateDynamicMaterialInstance
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInstanceDynamic*                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInstanceDynamic* ADecalActor::CreateDynamicMaterialInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.CreateDynamicMaterialInstance");

	ADecalActor_CreateDynamicMaterialInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void ADecalActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(Decal, UDecalComponent);
}

void ADecalActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(Decal);
}

void ADestructibleActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(DestructibleComponent, UDestructibleComponent);
}

void ADestructibleActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(DestructibleComponent);
}

void ADocumentationActor::AfterRead()
{
	AActor::AfterRead();

}

void ADocumentationActor::BeforeDelete()
{
	AActor::BeforeDelete();

}

// Function:
//		Offset -> 0x02B40AD0
//		Name   -> Function Engine.Emitter.ToggleActive
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AEmitter::ToggleActive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.ToggleActive");

	AEmitter_ToggleActive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40060
//		Name   -> Function Engine.Emitter.SetVectorParameter
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AEmitter::SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetVectorParameter");

	AEmitter_SetVectorParameter_Params params {};
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3FC60
//		Name   -> Function Engine.Emitter.SetTemplate
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UParticleSystem*                             NewTemplate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AEmitter::SetTemplate(class UParticleSystem* NewTemplate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetTemplate");

	AEmitter_SetTemplate_Params params {};
	params.NewTemplate = NewTemplate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E3A0
//		Name   -> Function Engine.Emitter.SetMaterialParameter
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInterface*                          Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AEmitter::SetMaterialParameter(const struct FName& ParameterName, class UMaterialInterface* Param)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetMaterialParameter");

	AEmitter_SetMaterialParameter_Params params {};
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3CD10
//		Name   -> Function Engine.Emitter.SetFloatParameter
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AEmitter::SetFloatParameter(const struct FName& ParameterName, float Param)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetFloatParameter");

	AEmitter_SetFloatParameter_Params params {};
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3BC70
//		Name   -> Function Engine.Emitter.SetColorParameter
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AEmitter::SetColorParameter(const struct FName& ParameterName, const struct FLinearColor& Param)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetColorParameter");

	AEmitter_SetColorParameter_Params params {};
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B396B0
//		Name   -> Function Engine.Emitter.SetActorParameter
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AEmitter::SetActorParameter(const struct FName& ParameterName, class AActor* Param)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetActorParameter");

	AEmitter_SetActorParameter_Params params {};
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B384A0
//		Name   -> Function Engine.Emitter.OnRep_bCurrentlyActive
//		Flags  -> (Native, Public)
void AEmitter::OnRep_bCurrentlyActive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.OnRep_bCurrentlyActive");

	AEmitter_OnRep_bCurrentlyActive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38170
//		Name   -> Function Engine.Emitter.OnParticleSystemFinished
//		Flags  -> (Native, Public)
// Parameters:
//		class UParticleSystemComponent*                    FinishedComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void AEmitter::OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.OnParticleSystemFinished");

	AEmitter_OnParticleSystemFinished_Params params {};
	params.FinishedComponent = FinishedComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B36B50
//		Name   -> Function Engine.Emitter.IsActive
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool AEmitter::IsActive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.IsActive");

	AEmitter_IsActive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32450
//		Name   -> Function Engine.Emitter.GetEmitterName
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName AEmitter::GetEmitterName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.GetEmitterName");

	AEmitter_GetEmitterName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F6E0
//		Name   -> Function Engine.Emitter.Deactivate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AEmitter::Deactivate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.Deactivate");

	AEmitter_Deactivate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2D090
//		Name   -> Function Engine.Emitter.Activate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AEmitter::Activate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Emitter.Activate");

	AEmitter_Activate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void AEmitter::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(ParticleSystemComponent, UParticleSystemComponent);
}

void AEmitter::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(ParticleSystemComponent);
}

void AEmitterCameraLensEffectBase::AfterRead()
{
	AEmitter::AfterRead();

	READ_PTR_FULL(PS_CameraEffect, UParticleSystem);
	READ_PTR_FULL(PS_CameraEffectNonExtremeContent, UParticleSystem);
	READ_PTR_FULL(BaseCamera, APlayerCameraManager);
}

void AEmitterCameraLensEffectBase::BeforeDelete()
{
	AEmitter::BeforeDelete();

	DELE_PTR_FULL(PS_CameraEffect);
	DELE_PTR_FULL(PS_CameraEffectNonExtremeContent);
	DELE_PTR_FULL(BaseCamera);
}

void ADebugCameraHUD::AfterRead()
{
	AHUD::AfterRead();

}

void ADebugCameraHUD::BeforeDelete()
{
	AHUD::BeforeDelete();

}

void ALogVisualizerHUD::AfterRead()
{
	ADebugCameraHUD::AfterRead();

}

void ALogVisualizerHUD::BeforeDelete()
{
	ADebugCameraHUD::BeforeDelete();

}

void AAtmosphericFog::AfterRead()
{
	AInfo::AfterRead();

	READ_PTR_FULL(AtmosphericFogComponent, UAtmosphericFogComponent);
}

void AAtmosphericFog::BeforeDelete()
{
	AInfo::BeforeDelete();

	DELE_PTR_FULL(AtmosphericFogComponent);
}

// Function:
//		Offset -> 0x02B384C0
//		Name   -> Function Engine.ExponentialHeightFog.OnRep_bEnabled
//		Flags  -> (Native, Public)
void AExponentialHeightFog::OnRep_bEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFog.OnRep_bEnabled");

	AExponentialHeightFog_OnRep_bEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void AExponentialHeightFog::AfterRead()
{
	AInfo::AfterRead();

	READ_PTR_FULL(Component, UExponentialHeightFogComponent);
}

void AExponentialHeightFog::BeforeDelete()
{
	AInfo::BeforeDelete();

	DELE_PTR_FULL(Component);
}

void ANavigationObjectBase::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(CapsuleComponent, UCapsuleComponent);
	READ_PTR_FULL(GoodSprite, UBillboardComponent);
	READ_PTR_FULL(BadSprite, UBillboardComponent);
}

void ANavigationObjectBase::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(CapsuleComponent);
	DELE_PTR_FULL(GoodSprite);
	DELE_PTR_FULL(BadSprite);
}

void APlayerStart::AfterRead()
{
	ANavigationObjectBase::AfterRead();

}

void APlayerStart::BeforeDelete()
{
	ANavigationObjectBase::BeforeDelete();

}

void AGameNetworkManager::AfterRead()
{
	AInfo::AfterRead();

}

void AGameNetworkManager::BeforeDelete()
{
	AInfo::BeforeDelete();

}

void AGameSession::AfterRead()
{
	AInfo::AfterRead();

}

void AGameSession::BeforeDelete()
{
	AInfo::BeforeDelete();

}

// Function:
//		Offset -> 0x02B38500
//		Name   -> Function Engine.SkyLight.OnRep_bEnabled
//		Flags  -> (Native, Public)
void ASkyLight::OnRep_bEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkyLight.OnRep_bEnabled");

	ASkyLight_OnRep_bEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ASkyLight::AfterRead()
{
	AInfo::AfterRead();

	READ_PTR_FULL(LightComponent, USkyLightComponent);
}

void ASkyLight::BeforeDelete()
{
	AInfo::BeforeDelete();

	DELE_PTR_FULL(LightComponent);
}

// Function:
//		Offset -> 0x02B31D10
//		Name   -> Function Engine.WindDirectionalSource.GetComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UWindDirectionalSourceComponent*             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UWindDirectionalSourceComponent* AWindDirectionalSource::GetComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSource.GetComponent");

	AWindDirectionalSource_GetComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void AWindDirectionalSource::AfterRead()
{
	AInfo::AfterRead();

	READ_PTR_FULL(Component, UWindDirectionalSourceComponent);
}

void AWindDirectionalSource::BeforeDelete()
{
	AInfo::BeforeDelete();

	DELE_PTR_FULL(Component);
}

void ALevelBounds::AfterRead()
{
	AActor::AfterRead();

}

void ALevelBounds::BeforeDelete()
{
	AActor::BeforeDelete();

}

// Function:
//		Offset -> 0x02B40B10
//		Name   -> Function Engine.Light.ToggleEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ALight::ToggleEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.ToggleEnabled");

	ALight_ToggleEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D610
//		Name   -> Function Engine.Light.SetLightFunctionScale
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewLightFunctionScale                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ALight::SetLightFunctionScale(const struct FVector& NewLightFunctionScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionScale");

	ALight_SetLightFunctionScale_Params params {};
	params.NewLightFunctionScale = NewLightFunctionScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D510
//		Name   -> Function Engine.Light.SetLightFunctionMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          NewLightFunctionMaterial                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ALight::SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionMaterial");

	ALight_SetLightFunctionMaterial_Params params {};
	params.NewLightFunctionMaterial = NewLightFunctionMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D410
//		Name   -> Function Engine.Light.SetLightFunctionFadeDistance
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewLightFunctionFadeDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ALight::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionFadeDistance");

	ALight_SetLightFunctionFadeDistance_Params params {};
	params.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D1C0
//		Name   -> Function Engine.Light.SetLightColor
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                NewLightColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ALight::SetLightColor(const struct FLinearColor& NewLightColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightColor");

	ALight_SetLightColor_Params params {};
	params.NewLightColor = NewLightColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3CC80
//		Name   -> Function Engine.Light.SetEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bSetEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ALight::SetEnabled(bool bSetEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.SetEnabled");

	ALight_SetEnabled_Params params {};
	params.bSetEnabled = bSetEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B4E0
//		Name   -> Function Engine.Light.SetCastShadows
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ALight::SetCastShadows(bool bNewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.SetCastShadows");

	ALight_SetCastShadows_Params params {};
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B340
//		Name   -> Function Engine.Light.SetBrightness
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewBrightness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ALight::SetBrightness(float NewBrightness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.SetBrightness");

	ALight_SetBrightness_Params params {};
	params.NewBrightness = NewBrightness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B398C0
//		Name   -> Function Engine.Light.SetAffectTranslucentLighting
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ALight::SetAffectTranslucentLighting(bool bNewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.SetAffectTranslucentLighting");

	ALight_SetAffectTranslucentLighting_Params params {};
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B384E0
//		Name   -> Function Engine.Light.OnRep_bEnabled
//		Flags  -> (Native, Public)
void ALight::OnRep_bEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.OnRep_bEnabled");

	ALight_OnRep_bEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B36CA0
//		Name   -> Function Engine.Light.IsEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ALight::IsEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.IsEnabled");

	ALight_IsEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32690
//		Name   -> Function Engine.Light.GetLightColor
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor ALight::GetLightColor()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.GetLightColor");

	ALight_GetLightColor_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B319D0
//		Name   -> Function Engine.Light.GetBrightness
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float ALight::GetBrightness()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Light.GetBrightness");

	ALight_GetBrightness_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void ALight::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(LightComponent, ULightComponent);
}

void ALight::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(LightComponent);
}

void AAmbientLightSource::AfterRead()
{
	ALight::AfterRead();

	READ_PTR_FULL(AmbientLightSourceComponent, UAmbientLightSourceComponent);
}

void AAmbientLightSource::BeforeDelete()
{
	ALight::BeforeDelete();

	DELE_PTR_FULL(AmbientLightSourceComponent);
}

void ADirectionalLight::AfterRead()
{
	ALight::AfterRead();

}

void ADirectionalLight::BeforeDelete()
{
	ALight::BeforeDelete();

}

// Function:
//		Offset -> 0x02B3F320
//		Name   -> Function Engine.PointLight.SetRadius
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewRadius                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APointLight::SetRadius(float NewRadius)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PointLight.SetRadius");

	APointLight_SetRadius_Params params {};
	params.NewRadius = NewRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D310
//		Name   -> Function Engine.PointLight.SetLightFalloffExponent
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewLightFalloffExponent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void APointLight::SetLightFalloffExponent(float NewLightFalloffExponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PointLight.SetLightFalloffExponent");

	APointLight_SetLightFalloffExponent_Params params {};
	params.NewLightFalloffExponent = NewLightFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void APointLight::AfterRead()
{
	ALight::AfterRead();

	READ_PTR_FULL(PointLightComponent, UPointLightComponent);
}

void APointLight::BeforeDelete()
{
	ALight::BeforeDelete();

	DELE_PTR_FULL(PointLightComponent);
}

// Function:
//		Offset -> 0x02B3E7D0
//		Name   -> Function Engine.SpotLight.SetOuterConeAngle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewOuterConeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ASpotLight::SetOuterConeAngle(float NewOuterConeAngle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SpotLight.SetOuterConeAngle");

	ASpotLight_SetOuterConeAngle_Params params {};
	params.NewOuterConeAngle = NewOuterConeAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D0C0
//		Name   -> Function Engine.SpotLight.SetInnerConeAngle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewInnerConeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ASpotLight::SetInnerConeAngle(float NewInnerConeAngle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SpotLight.SetInnerConeAngle");

	ASpotLight_SetInnerConeAngle_Params params {};
	params.NewInnerConeAngle = NewInnerConeAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ASpotLight::AfterRead()
{
	ALight::AfterRead();

	READ_PTR_FULL(SpotLightComponent, USpotLightComponent);
}

void ASpotLight::BeforeDelete()
{
	ALight::BeforeDelete();

	DELE_PTR_FULL(SpotLightComponent);
}

void AGeneratedMeshAreaLight::AfterRead()
{
	ASpotLight::AfterRead();

}

void AGeneratedMeshAreaLight::BeforeDelete()
{
	ASpotLight::BeforeDelete();

}

void ALODActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(StaticMeshComponent, UStaticMeshComponent);
}

void ALODActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(StaticMeshComponent);
}

void AMaterialInstanceActor::AfterRead()
{
	AActor::AfterRead();

}

void AMaterialInstanceActor::BeforeDelete()
{
	AActor::BeforeDelete();

}

// Function:
//		Offset -> 0x02B408A0
//		Name   -> Function Engine.MatineeActor.Stop
//		Flags  -> (Native, Public, BlueprintCallable)
void AMatineeActor::Stop()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Stop");

	AMatineeActor_Stop_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F180
//		Name   -> Function Engine.MatineeActor.SetPosition
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewPosition                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bJump                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AMatineeActor::SetPosition(float NewPosition, bool bJump)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.SetPosition");

	AMatineeActor_SetPosition_Params params {};
	params.NewPosition = NewPosition;
	params.bJump = bJump;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3DFF0
//		Name   -> Function Engine.MatineeActor.SetLoopingState
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewLooping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void AMatineeActor::SetLoopingState(bool bNewLooping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.SetLoopingState");

	AMatineeActor_SetLoopingState_Params params {};
	params.bNewLooping = bNewLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39590
//		Name   -> Function Engine.MatineeActor.Reverse
//		Flags  -> (Native, Public, BlueprintCallable)
void AMatineeActor::Reverse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Reverse");

	AMatineeActor_Reverse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38C40
//		Name   -> Function Engine.MatineeActor.PlayInstantly
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AMatineeActor::PlayInstantly()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.PlayInstantly");

	AMatineeActor_PlayInstantly_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B388E0
//		Name   -> Function Engine.MatineeActor.Play
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
void AMatineeActor::Play(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Play");

	AMatineeActor_Play_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B386C0
//		Name   -> Function Engine.MatineeActor.Pause
//		Flags  -> (Native, Public, BlueprintCallable)
void AMatineeActor::Pause()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Pause");

	AMatineeActor_Pause_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2ED70
//		Name   -> Function Engine.MatineeActor.ChangePlaybackDirection
//		Flags  -> (Native, Public, BlueprintCallable)
void AMatineeActor::ChangePlaybackDirection()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.ChangePlaybackDirection");

	AMatineeActor_ChangePlaybackDirection_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void AMatineeActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(MatineeData, UInterpData);
}

void AMatineeActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(MatineeData);
}

void AMatineeActorCameraAnim::AfterRead()
{
	AMatineeActor::AfterRead();

	READ_PTR_FULL(CameraAnim, UCameraAnim);
}

void AMatineeActorCameraAnim::BeforeDelete()
{
	AMatineeActor::BeforeDelete();

	DELE_PTR_FULL(CameraAnim);
}

void AMergedCollisionActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(MergedCollisionComponent, UMergedCollisionComponent);
}

void AMergedCollisionActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(MergedCollisionComponent);
}

void UNavigationQueryFilter::AfterRead()
{
	UObject::AfterRead();

}

void UNavigationQueryFilter::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UInstancedNavMeshesDataAsset::AfterRead()
{
	UDataAsset::AfterRead();

}

void UInstancedNavMeshesDataAsset::BeforeDelete()
{
	UDataAsset::BeforeDelete();

}

void UParticleComputeShaderData::AfterRead()
{
	UDataAsset::AfterRead();

}

void UParticleComputeShaderData::BeforeDelete()
{
	UDataAsset::BeforeDelete();

}

void UStringArrayDataAsset::AfterRead()
{
	UDataAsset::AfterRead();

}

void UStringArrayDataAsset::BeforeDelete()
{
	UDataAsset::BeforeDelete();

}

void UDestructibleFractureSettings::AfterRead()
{
	UObject::AfterRead();

}

void UDestructibleFractureSettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UAnimationSettings::AfterRead()
{
	UDeveloperSettings::AfterRead();

	READ_PTR_FULL(DefaultCompressionAlgorithm, UClass);
}

void UAnimationSettings::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

	DELE_PTR_FULL(DefaultCompressionAlgorithm);
}

void UInterpTrack::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(TrackInstClass, UClass);
}

void UInterpTrack::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(TrackInstClass);
}

void UInterpTrackFloatBase::AfterRead()
{
	UInterpTrack::AfterRead();

}

void UInterpTrackFloatBase::BeforeDelete()
{
	UInterpTrack::BeforeDelete();

}

void UInterpTrackFade::AfterRead()
{
	UInterpTrackFloatBase::AfterRead();

}

void UInterpTrackFade::BeforeDelete()
{
	UInterpTrackFloatBase::BeforeDelete();

}

void UInterpTrackFloatAnimBPParam::AfterRead()
{
	UInterpTrackFloatBase::AfterRead();

	READ_PTR_FULL(AnimBlueprintClass, UClass);
}

void UInterpTrackFloatAnimBPParam::BeforeDelete()
{
	UInterpTrackFloatBase::BeforeDelete();

	DELE_PTR_FULL(AnimBlueprintClass);
}

void UInterpTrackFloatMaterialParam::AfterRead()
{
	UInterpTrackFloatBase::AfterRead();

}

void UInterpTrackFloatMaterialParam::BeforeDelete()
{
	UInterpTrackFloatBase::BeforeDelete();

}

void UInterpTrackFloatParticleParam::AfterRead()
{
	UInterpTrackFloatBase::AfterRead();

}

void UInterpTrackFloatParticleParam::BeforeDelete()
{
	UInterpTrackFloatBase::BeforeDelete();

}

void UInterpTrackFloatProp::AfterRead()
{
	UInterpTrackFloatBase::AfterRead();

}

void UInterpTrackFloatProp::BeforeDelete()
{
	UInterpTrackFloatBase::BeforeDelete();

}

void UInterpTrackMove::AfterRead()
{
	UInterpTrack::AfterRead();

}

void UInterpTrackMove::BeforeDelete()
{
	UInterpTrack::BeforeDelete();

}

void UParticleModuleColorBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleColorBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleColor::AfterRead()
{
	UParticleModuleColorBase::AfterRead();

}

void UParticleModuleColor::BeforeDelete()
{
	UParticleModuleColorBase::BeforeDelete();

}

void UParticleModuleColor_Seeded::AfterRead()
{
	UParticleModuleColor::AfterRead();

}

void UParticleModuleColor_Seeded::BeforeDelete()
{
	UParticleModuleColor::BeforeDelete();

}

void UParticleModuleColorOverLife::AfterRead()
{
	UParticleModuleColorBase::AfterRead();

}

void UParticleModuleColorOverLife::BeforeDelete()
{
	UParticleModuleColorBase::BeforeDelete();

}

void UParticleModuleColorScaleOverLife::AfterRead()
{
	UParticleModuleColorBase::AfterRead();

}

void UParticleModuleColorScaleOverLife::BeforeDelete()
{
	UParticleModuleColorBase::BeforeDelete();

}

void UParticleModuleMurkyColor::AfterRead()
{
	UParticleModuleColorBase::AfterRead();

}

void UParticleModuleMurkyColor::BeforeDelete()
{
	UParticleModuleColorBase::BeforeDelete();

}

void UParticleModuleEventBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleEventBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleEventGenerator::AfterRead()
{
	UParticleModuleEventBase::AfterRead();

}

void UParticleModuleEventGenerator::BeforeDelete()
{
	UParticleModuleEventBase::BeforeDelete();

}

void UParticleModuleRotationBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleRotationBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleMeshRotation::AfterRead()
{
	UParticleModuleRotationBase::AfterRead();

}

void UParticleModuleMeshRotation::BeforeDelete()
{
	UParticleModuleRotationBase::BeforeDelete();

}

void UParticleModuleMeshRotation_Seeded::AfterRead()
{
	UParticleModuleMeshRotation::AfterRead();

}

void UParticleModuleMeshRotation_Seeded::BeforeDelete()
{
	UParticleModuleMeshRotation::BeforeDelete();

}

void UParticleModuleRotateRotationAxis::AfterRead()
{
	UParticleModuleRotationBase::AfterRead();

}

void UParticleModuleRotateRotationAxis::BeforeDelete()
{
	UParticleModuleRotationBase::BeforeDelete();

}

void UParticleModuleMeshRotationRate::AfterRead()
{
	UParticleModuleRotationRateBase::AfterRead();

}

void UParticleModuleMeshRotationRate::BeforeDelete()
{
	UParticleModuleRotationRateBase::BeforeDelete();

}

void ANavigationData::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(RenderingComp, UPrimitiveComponent);
}

void ANavigationData::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(RenderingComp);
}

void AAbstractNavData::AfterRead()
{
	ANavigationData::AfterRead();

}

void AAbstractNavData::BeforeDelete()
{
	ANavigationData::BeforeDelete();

}

void ANavigationGraph::AfterRead()
{
	ANavigationData::AfterRead();

}

void ANavigationGraph::BeforeDelete()
{
	ANavigationData::BeforeDelete();

}

void ARecastNavMesh::AfterRead()
{
	ANavigationData::AfterRead();

}

void ARecastNavMesh::BeforeDelete()
{
	ANavigationData::BeforeDelete();

}

void ANavigationGraphNode::AfterRead()
{
	AActor::AfterRead();

}

void ANavigationGraphNode::BeforeDelete()
{
	AActor::BeforeDelete();

}

void APlayerStartPIE::AfterRead()
{
	APlayerStart::AfterRead();

}

void APlayerStartPIE::BeforeDelete()
{
	APlayerStart::BeforeDelete();

}

void UNavPathObserverInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UNavPathObserverInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void ANavigationTestingActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(CapsuleComponent, UCapsuleComponent);
	READ_PTR_FULL(InvokerComponent, UNavigationInvokerComponent);
	READ_PTR_FULL(MyNavData, ANavigationData);
	READ_PTR_FULL(OtherActor, ANavigationTestingActor);
	READ_PTR_FULL(FilterClass, UClass);
}

void ANavigationTestingActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(CapsuleComponent);
	DELE_PTR_FULL(InvokerComponent);
	DELE_PTR_FULL(MyNavData);
	DELE_PTR_FULL(OtherActor);
	DELE_PTR_FULL(FilterClass);
}

void UNavLinkDefinition::AfterRead()
{
	UObject::AfterRead();

}

void UNavLinkDefinition::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UNavLinkHostInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UNavLinkHostInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

// Function:
//		Offset -> 0x02B3F700
//		Name   -> Function Engine.NavLinkProxy.SetSmartLinkEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ANavLinkProxy::SetSmartLinkEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.SetSmartLinkEnabled");

	ANavLinkProxy_SetSmartLinkEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B394F0
//		Name   -> Function Engine.NavLinkProxy.ResumePathFollowing
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      Agent                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ANavLinkProxy::ResumePathFollowing(class AActor* Agent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.ResumePathFollowing");

	ANavLinkProxy_ResumePathFollowing_Params params {};
	params.Agent = Agent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.NavLinkProxy.ReceiveSmartLinkReached
//		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
//		class AActor*                                      Agent                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Destination                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void ANavLinkProxy::ReceiveSmartLinkReached(class AActor* Agent, const struct FVector& Destination)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.ReceiveSmartLinkReached");

	ANavLinkProxy_ReceiveSmartLinkReached_Params params {};
	params.Agent = Agent;
	params.Destination = Destination;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37200
//		Name   -> Function Engine.NavLinkProxy.IsSmartLinkEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ANavLinkProxy::IsSmartLinkEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.IsSmartLinkEnabled");

	ANavLinkProxy_IsSmartLinkEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36880
//		Name   -> Function Engine.NavLinkProxy.HasMovingAgents
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ANavLinkProxy::HasMovingAgents()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.HasMovingAgents");

	ANavLinkProxy_HasMovingAgents_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void ANavLinkProxy::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(SmartLinkComp, UNavLinkCustomComponent);
}

void ANavLinkProxy::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(SmartLinkComp);
}

void ANote::AfterRead()
{
	AActor::AfterRead();

}

void ANote::BeforeDelete()
{
	AActor::BeforeDelete();

}

// Function:
//		Offset -> 0x02B33250
//		Name   -> Function Engine.ParticleSystem.GetNumLODs
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UParticleSystem::GetNumLODs()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystem.GetNumLODs");

	UParticleSystem_GetNumLODs_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F1E0
//		Name   -> Function Engine.ParticleSystem.ContainsEmitterType
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      TypeData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UParticleSystem::ContainsEmitterType(class UClass* TypeData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystem.ContainsEmitterType");

	UParticleSystem_ContainsEmitterType_Params params {};
	params.TypeData = TypeData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UParticleSystem::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(PreviewComponent, UParticleSystemComponent);
	READ_PTR_FULL(CurveEdSetup, UInterpCurveEdSetup);
}

void UParticleSystem::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(PreviewComponent);
	DELE_PTR_FULL(CurveEdSetup);
}

void UParticleSystemAggregateTickSettings::AfterRead()
{
	UObject::AfterRead();

}

void UParticleSystemAggregateTickSettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void AParticleEventManager::AfterRead()
{
	AActor::AfterRead();

}

void AParticleEventManager::BeforeDelete()
{
	AActor::BeforeDelete();

}

void UInterface_CollisionDataProvider::AfterRead()
{
	UInterface::AfterRead();

}

void UInterface_CollisionDataProvider::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UMeshPatchAsset::AfterRead()
{
	UObject::AfterRead();

}

void UMeshPatchAsset::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02B37140
//		Name   -> Function Engine.SkeletalMesh.IsSectionUsingCloth
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                InSectionIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bCheckCorrespondingSections                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USkeletalMesh::IsSectionUsingCloth(int InSectionIndex, bool bCheckCorrespondingSections)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.IsSectionUsingCloth");

	USkeletalMesh_IsSectionUsingCloth_Params params {};
	params.InSectionIndex = InSectionIndex;
	params.bCheckCorrespondingSections = bCheckCorrespondingSections;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33280
//		Name   -> Function Engine.SkeletalMesh.GetNumLODsBP
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int USkeletalMesh::GetNumLODsBP()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetNumLODsBP");

	USkeletalMesh_GetNumLODsBP_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B311C0
//		Name   -> Function Engine.SkeletalMesh.FindSocket
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class USkeletalMeshSocket*                         ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class USkeletalMeshSocket* USkeletalMesh::FindSocket(const struct FName& InSocketName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.FindSocket");

	USkeletalMesh_FindSocket_Params params {};
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void USkeletalMesh::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(Skeleton, USkeleton);
	READ_PTR_FULL(BodySetup, UBodySetup);
	READ_PTR_FULL(PhysicsAsset, UPhysicsAsset);
	READ_PTR_FULL(Characterization, UHIKCharacterization);
	READ_PTR_FULL(DeformablesPhysicsAsset, UPhysicsAsset);
}

void USkeletalMesh::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(Skeleton);
	DELE_PTR_FULL(BodySetup);
	DELE_PTR_FULL(PhysicsAsset);
	DELE_PTR_FULL(Characterization);
	DELE_PTR_FULL(DeformablesPhysicsAsset);
}

void UAnimationAsset::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(Skeleton, USkeleton);
}

void UAnimationAsset::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(Skeleton);
}

// Function:
//		Offset -> 0x02B40F50
//		Name   -> Function Engine.DefaultPawn.TurnAtRate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ADefaultPawn::TurnAtRate(float Rate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.TurnAtRate");

	ADefaultPawn_TurnAtRate_Params params {};
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40ED0
//		Name   -> Function Engine.DefaultPawn.Turn
//		Flags  -> (Final, Native, Private, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ADefaultPawn::Turn(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.Turn");

	ADefaultPawn_Turn_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37C80
//		Name   -> Function Engine.DefaultPawn.MoveUp_World
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ADefaultPawn::MoveUp_World(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveUp_World");

	ADefaultPawn_MoveUp_World_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37C00
//		Name   -> Function Engine.DefaultPawn.MoveRight
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ADefaultPawn::MoveRight(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveRight");

	ADefaultPawn_MoveRight_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37B80
//		Name   -> Function Engine.DefaultPawn.MoveForward
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ADefaultPawn::MoveForward(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveForward");

	ADefaultPawn_MoveForward_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37B00
//		Name   -> Function Engine.DefaultPawn.LookUpAtRate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ADefaultPawn::LookUpAtRate(float Rate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.LookUpAtRate");

	ADefaultPawn_LookUpAtRate_Params params {};
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37A80
//		Name   -> Function Engine.DefaultPawn.LookUp
//		Flags  -> (Final, Native, Private, BlueprintCallable)
// Parameters:
//		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void ADefaultPawn::LookUp(float Val)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.LookUp");

	ADefaultPawn_LookUp_Params params {};
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ADefaultPawn::AfterRead()
{
	APawn::AfterRead();

	READ_PTR_FULL(MovementComponent, UPawnMovementComponent);
	READ_PTR_FULL(CollisionComponent, USphereComponent);
	READ_PTR_FULL(MeshComponent, UStaticMeshComponent);
}

void ADefaultPawn::BeforeDelete()
{
	APawn::BeforeDelete();

	DELE_PTR_FULL(MovementComponent);
	DELE_PTR_FULL(CollisionComponent);
	DELE_PTR_FULL(MeshComponent);
}

void ASpectatorPawn::AfterRead()
{
	ADefaultPawn::AfterRead();

}

void ASpectatorPawn::BeforeDelete()
{
	ADefaultPawn::BeforeDelete();

}

void AReflectionCapture::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(CaptureComponent, UReflectionCaptureComponent);
}

void AReflectionCapture::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(CaptureComponent);
}

void ABoxReflectionCapture::AfterRead()
{
	AReflectionCapture::AfterRead();

}

void ABoxReflectionCapture::BeforeDelete()
{
	AReflectionCapture::BeforeDelete();

}

void APlaneReflectionCapture::AfterRead()
{
	AReflectionCapture::AfterRead();

}

void APlaneReflectionCapture::BeforeDelete()
{
	AReflectionCapture::BeforeDelete();

}

void ASphereReflectionCapture::AfterRead()
{
	AReflectionCapture::AfterRead();

	READ_PTR_FULL(DrawCaptureRadius, UDrawSphereComponent);
}

void ASphereReflectionCapture::BeforeDelete()
{
	AReflectionCapture::BeforeDelete();

	DELE_PTR_FULL(DrawCaptureRadius);
}

void ARigidBodyBase::AfterRead()
{
	AActor::AfterRead();

}

void ARigidBodyBase::BeforeDelete()
{
	AActor::BeforeDelete();

}

void APhysicsConstraintActor::AfterRead()
{
	ARigidBodyBase::AfterRead();

	READ_PTR_FULL(ConstraintComp, UPhysicsConstraintComponent);
	READ_PTR_FULL(ConstraintActor1, AActor);
	READ_PTR_FULL(ConstraintActor2, AActor);
}

void APhysicsConstraintActor::BeforeDelete()
{
	ARigidBodyBase::BeforeDelete();

	DELE_PTR_FULL(ConstraintComp);
	DELE_PTR_FULL(ConstraintActor1);
	DELE_PTR_FULL(ConstraintActor2);
}

void APhysicsThruster::AfterRead()
{
	ARigidBodyBase::AfterRead();

	READ_PTR_FULL(ThrusterComponent, UPhysicsThrusterComponent);
}

void APhysicsThruster::BeforeDelete()
{
	ARigidBodyBase::BeforeDelete();

	DELE_PTR_FULL(ThrusterComponent);
}

// Function:
//		Offset -> 0x02B40B30
//		Name   -> Function Engine.RadialForceActor.ToggleForce
//		Flags  -> (Native, Public, BlueprintCallable)
void ARadialForceActor::ToggleForce()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.ToggleForce");

	ARadialForceActor_ToggleForce_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B31250
//		Name   -> Function Engine.RadialForceActor.FireImpulse
//		Flags  -> (Native, Public, BlueprintCallable)
void ARadialForceActor::FireImpulse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.FireImpulse");

	ARadialForceActor_FireImpulse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B30CC0
//		Name   -> Function Engine.RadialForceActor.EnableForce
//		Flags  -> (Native, Public, BlueprintCallable)
void ARadialForceActor::EnableForce()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.EnableForce");

	ARadialForceActor_EnableForce_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2F8D0
//		Name   -> Function Engine.RadialForceActor.DisableForce
//		Flags  -> (Native, Public, BlueprintCallable)
void ARadialForceActor::DisableForce()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.DisableForce");

	ARadialForceActor_DisableForce_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ARadialForceActor::AfterRead()
{
	ARigidBodyBase::AfterRead();

	READ_PTR_FULL(ForceComponent, URadialForceComponent);
}

void ARadialForceActor::BeforeDelete()
{
	ARigidBodyBase::BeforeDelete();

	DELE_PTR_FULL(ForceComponent);
}

void ASceneCapture::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(MeshComp, UStaticMeshComponent);
}

void ASceneCapture::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(MeshComp);
}

// Function:
//		Offset -> 0x02B37FB0
//		Name   -> Function Engine.SceneCapture2D.OnInterpToggle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ASceneCapture2D::OnInterpToggle(bool bEnable)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneCapture2D.OnInterpToggle");

	ASceneCapture2D_OnInterpToggle_Params params {};
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ASceneCapture2D::AfterRead()
{
	ASceneCapture::AfterRead();

	READ_PTR_FULL(CaptureComponent2D, USceneCaptureComponent2D);
	READ_PTR_FULL(DrawFrustum, UDrawFrustumComponent);
}

void ASceneCapture2D::BeforeDelete()
{
	ASceneCapture::BeforeDelete();

	DELE_PTR_FULL(CaptureComponent2D);
	DELE_PTR_FULL(DrawFrustum);
}

// Function:
//		Offset -> 0x02B38040
//		Name   -> Function Engine.SceneCaptureCube.OnInterpToggle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void ASceneCaptureCube::OnInterpToggle(bool bEnable)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureCube.OnInterpToggle");

	ASceneCaptureCube_OnInterpToggle_Params params {};
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ASceneCaptureCube::AfterRead()
{
	ASceneCapture::AfterRead();

	READ_PTR_FULL(CaptureComponentCube, USceneCaptureComponentCube);
	READ_PTR_FULL(DrawFrustum, UDrawFrustumComponent);
}

void ASceneCaptureCube::BeforeDelete()
{
	ASceneCapture::BeforeDelete();

	DELE_PTR_FULL(CaptureComponentCube);
	DELE_PTR_FULL(DrawFrustum);
}

void AServerOnlyTestActor::AfterRead()
{
	AActor::AfterRead();

}

void AServerOnlyTestActor::BeforeDelete()
{
	AActor::BeforeDelete();

}

// Function:
//		Offset -> 0x02B41060
//		Name   -> Function Engine.SkinnedMeshComponent.UnHideBoneByName
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkinnedMeshComponent::UnHideBoneByName(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.UnHideBoneByName");

	USkinnedMeshComponent_UnHideBoneByName_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40D10
//		Name   -> Function Engine.SkinnedMeshComponent.TransformToBoneSpace
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     InPosition                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    InRotation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     OutPosition                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkinnedMeshComponent::TransformToBoneSpace(const struct FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.TransformToBoneSpace");

	USkinnedMeshComponent_TransformToBoneSpace_Params params {};
	params.BoneName = BoneName;
	params.InPosition = InPosition;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutPosition != nullptr)
		*OutPosition = params.OutPosition;
	if (OutRotation != nullptr)
		*OutRotation = params.OutRotation;

}


// Function:
//		Offset -> 0x02B40B50
//		Name   -> Function Engine.SkinnedMeshComponent.TransformFromBoneSpace
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     InPosition                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    InRotation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     OutPosition                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkinnedMeshComponent::TransformFromBoneSpace(const struct FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.TransformFromBoneSpace");

	USkinnedMeshComponent_TransformFromBoneSpace_Params params {};
	params.BoneName = BoneName;
	params.InPosition = InPosition;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutPosition != nullptr)
		*OutPosition = params.OutPosition;
	if (OutRotation != nullptr)
		*OutRotation = params.OutRotation;

}


// Function:
//		Offset -> 0x02B3F670
//		Name   -> Function Engine.SkinnedMeshComponent.SetSkeletalMesh
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class USkeletalMesh*                               NewMesh                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkinnedMeshComponent::SetSkeletalMesh(class USkeletalMesh* NewMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkeletalMesh");

	USkinnedMeshComponent_SetSkeletalMesh_Params params {};
	params.NewMesh = NewMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3EA80
//		Name   -> Function Engine.SkinnedMeshComponent.SetPhysicsAsset
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UPhysicsAsset*                               NewPhysicsAsset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bForceReInit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkinnedMeshComponent::SetPhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReInit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetPhysicsAsset");

	USkinnedMeshComponent_SetPhysicsAsset_Params params {};
	params.NewPhysicsAsset = NewPhysicsAsset;
	params.bForceReInit = bForceReInit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E250
//		Name   -> Function Engine.SkinnedMeshComponent.SetMasterPoseComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USkinnedMeshComponent*                       NewMasterBoneComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkinnedMeshComponent::SetMasterPoseComponent(class USkinnedMeshComponent* NewMasterBoneComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetMasterPoseComponent");

	USkinnedMeshComponent_SetMasterPoseComponent_Params params {};
	params.NewMasterBoneComponent = NewMasterBoneComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C380
//		Name   -> Function Engine.SkinnedMeshComponent.SetCustomDepthMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkinnedMeshComponent::SetCustomDepthMaterial(class UMaterialInterface* Material)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetCustomDepthMaterial");

	USkinnedMeshComponent_SetCustomDepthMaterial_Params params {};
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B383C0
//		Name   -> Function Engine.SkinnedMeshComponent.OnRep_SkeletalMesh
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class USkeletalMesh*                               OldMesh                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkinnedMeshComponent::OnRep_SkeletalMesh(class USkeletalMesh* OldMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.OnRep_SkeletalMesh");

	USkinnedMeshComponent_OnRep_SkeletalMesh_Params params {};
	params.OldMesh = OldMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B36B80
//		Name   -> Function Engine.SkinnedMeshComponent.IsBoneHiddenByName
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USkinnedMeshComponent::IsBoneHiddenByName(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsBoneHiddenByName");

	USkinnedMeshComponent_IsBoneHiddenByName_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B368B0
//		Name   -> Function Engine.SkinnedMeshComponent.HideBoneByName
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EPhysBodyOp>                    PhysBodyOption                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkinnedMeshComponent::HideBoneByName(const struct FName& BoneName, TEnumAsByte<Engine_EPhysBodyOp> PhysBodyOption)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.HideBoneByName");

	USkinnedMeshComponent_HideBoneByName_Params params {};
	params.BoneName = BoneName;
	params.PhysBodyOption = PhysBodyOption;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B35490
//		Name   -> Function Engine.SkinnedMeshComponent.GetSocketBoneName
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName USkinnedMeshComponent::GetSocketBoneName(const struct FName& InSocketName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetSocketBoneName");

	USkinnedMeshComponent_GetSocketBoneName_Params params {};
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B337A0
//		Name   -> Function Engine.SkinnedMeshComponent.GetParentBone
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName USkinnedMeshComponent::GetParentBone(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetParentBone");

	USkinnedMeshComponent_GetParentBone_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31F50
//		Name   -> Function Engine.SkinnedMeshComponent.GetCustomDepthMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UMaterialInterface*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaterialInterface* USkinnedMeshComponent::GetCustomDepthMaterial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetCustomDepthMaterial");

	USkinnedMeshComponent_GetCustomDepthMaterial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31940
//		Name   -> Function Engine.SkinnedMeshComponent.GetBoneName
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                BoneIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
struct FName USkinnedMeshComponent::GetBoneName(int BoneIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetBoneName");

	USkinnedMeshComponent_GetBoneName_Params params {};
	params.BoneIndex = BoneIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B318B0
//		Name   -> Function Engine.SkinnedMeshComponent.GetBoneIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int USkinnedMeshComponent::GetBoneIndex(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetBoneIndex");

	USkinnedMeshComponent_GetBoneIndex_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2E990
//		Name   -> Function Engine.SkinnedMeshComponent.BoneIsChildOf
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       ParentBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USkinnedMeshComponent::BoneIsChildOf(const struct FName& BoneName, const struct FName& ParentBoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.BoneIsChildOf");

	USkinnedMeshComponent_BoneIsChildOf_Params params {};
	params.BoneName = BoneName;
	params.ParentBoneName = ParentBoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void USkinnedMeshComponent::AfterRead()
{
	UMeshComponent::AfterRead();

	READ_PTR_FULL(SkeletalMesh, USkeletalMesh);
	READ_PTR_FULL(CustomDepthMaterial, UMaterialInterface);
	READ_PTR_FULL(PhysicsAssetOverride, UPhysicsAsset);
}

void USkinnedMeshComponent::BeforeDelete()
{
	UMeshComponent::BeforeDelete();

	DELE_PTR_FULL(SkeletalMesh);
	DELE_PTR_FULL(CustomDepthMaterial);
	DELE_PTR_FULL(PhysicsAssetOverride);
}

// Function:
//		Offset -> 0x02B3DDA0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearZLimit
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ELinearConstraintMotion>        ConstraintType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LimitSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsConstraintComponent::SetLinearZLimit(TEnumAsByte<Engine_ELinearConstraintMotion> ConstraintType, float LimitSize)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearZLimit");

	UPhysicsConstraintComponent_SetLinearZLimit_Params params {};
	params.ConstraintType = ConstraintType;
	params.LimitSize = LimitSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3DCE0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearYLimit
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ELinearConstraintMotion>        ConstraintType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LimitSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsConstraintComponent::SetLinearYLimit(TEnumAsByte<Engine_ELinearConstraintMotion> ConstraintType, float LimitSize)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearYLimit");

	UPhysicsConstraintComponent_SetLinearYLimit_Params params {};
	params.ConstraintType = ConstraintType;
	params.LimitSize = LimitSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3DC20
//		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearXLimit
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ELinearConstraintMotion>        ConstraintType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LimitSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsConstraintComponent::SetLinearXLimit(TEnumAsByte<Engine_ELinearConstraintMotion> ConstraintType, float LimitSize)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearXLimit");

	UPhysicsConstraintComponent_SetLinearXLimit_Params params {};
	params.ConstraintType = ConstraintType;
	params.LimitSize = LimitSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3DB90
//		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget
//		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     InVelTarget                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetLinearVelocityTarget(const struct FVector& InVelTarget)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget");

	UPhysicsConstraintComponent_SetLinearVelocityTarget_Params params {};
	params.InVelTarget = InVelTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3DA70
//		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnableDriveX                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bEnableDriveY                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bEnableDriveZ                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive");

	UPhysicsConstraintComponent_SetLinearVelocityDrive_Params params {};
	params.bEnableDriveX = bEnableDriveX;
	params.bEnableDriveY = bEnableDriveY;
	params.bEnableDriveZ = bEnableDriveZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D9E0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget
//		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     InPosTarget                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetLinearPositionTarget(const struct FVector& InPosTarget)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget");

	UPhysicsConstraintComponent_SetLinearPositionTarget_Params params {};
	params.InPosTarget = InPosTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D8C0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnableDriveX                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bEnableDriveY                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bEnableDriveZ                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive");

	UPhysicsConstraintComponent_SetLinearPositionDrive_Params params {};
	params.bEnableDriveX = bEnableDriveX;
	params.bEnableDriveY = bEnableDriveY;
	params.bEnableDriveZ = bEnableDriveZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3D7B0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearDriveParams
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InSpring                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InDamping                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InForceLimit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsConstraintComponent::SetLinearDriveParams(float InSpring, float InDamping, float InForceLimit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearDriveParams");

	UPhysicsConstraintComponent_SetLinearDriveParams_Params params {};
	params.InSpring = InSpring;
	params.InDamping = InDamping;
	params.InForceLimit = InForceLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C8E0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetDisableCollision
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bDisableCollision                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetDisableCollision(bool bDisableCollision)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetDisableCollision");

	UPhysicsConstraintComponent_SetDisableCollision_Params params {};
	params.bDisableCollision = bDisableCollision;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C230
//		Name   -> Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition
//		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EConstraintFrame>               Frame                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     RefPosition                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetConstraintReferencePosition(TEnumAsByte<Engine_EConstraintFrame> Frame, const struct FVector& RefPosition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition");

	UPhysicsConstraintComponent_SetConstraintReferencePosition_Params params {};
	params.Frame = Frame;
	params.RefPosition = RefPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3C110
//		Name   -> Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation
//		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EConstraintFrame>               Frame                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     PriAxis                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     SecAxis                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetConstraintReferenceOrientation(TEnumAsByte<Engine_EConstraintFrame> Frame, const struct FVector& PriAxis, const struct FVector& SecAxis)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation");

	UPhysicsConstraintComponent_SetConstraintReferenceOrientation_Params params {};
	params.Frame = Frame;
	params.PriAxis = PriAxis;
	params.SecAxis = SecAxis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3BFE0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame
//		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EConstraintFrame>               Frame                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  RefFrame                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetConstraintReferenceFrame(TEnumAsByte<Engine_EConstraintFrame> Frame, const struct FTransform& RefFrame)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame");

	UPhysicsConstraintComponent_SetConstraintReferenceFrame_Params params {};
	params.Frame = Frame;
	params.RefFrame = RefFrame;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3BE10
//		Name   -> Function Engine.PhysicsConstraintComponent.SetConstrainedComponents
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		class UPrimitiveComponent*                         Component1                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       BoneName1                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UPrimitiveComponent*                         Component2                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       BoneName2                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsConstraintComponent::SetConstrainedComponents(class UPrimitiveComponent* Component1, const struct FName& BoneName1, class UPrimitiveComponent* Component2, const struct FName& BoneName2)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstrainedComponents");

	UPhysicsConstraintComponent_SetConstrainedComponents_Params params {};
	params.Component1 = Component1;
	params.BoneName1 = BoneName1;
	params.Component2 = Component2;
	params.BoneName2 = BoneName2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A830
//		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget
//		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     InVelTarget                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetAngularVelocityTarget(const struct FVector& InVelTarget)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget");

	UPhysicsConstraintComponent_SetAngularVelocityTarget_Params params {};
	params.InVelTarget = InVelTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A760
//		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnableSwingDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bEnableTwistDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive");

	UPhysicsConstraintComponent_SetAngularVelocityDrive_Params params {};
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A6A0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EAngularConstraintMotion>       ConstraintType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TwistLimitAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsConstraintComponent::SetAngularTwistLimit(TEnumAsByte<Engine_EAngularConstraintMotion> ConstraintType, float TwistLimitAngle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit");

	UPhysicsConstraintComponent_SetAngularTwistLimit_Params params {};
	params.ConstraintType = ConstraintType;
	params.TwistLimitAngle = TwistLimitAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A5E0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EAngularConstraintMotion>       MotionType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Swing2LimitAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsConstraintComponent::SetAngularSwing2Limit(TEnumAsByte<Engine_EAngularConstraintMotion> MotionType, float Swing2LimitAngle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit");

	UPhysicsConstraintComponent_SetAngularSwing2Limit_Params params {};
	params.MotionType = MotionType;
	params.Swing2LimitAngle = Swing2LimitAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A520
//		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EAngularConstraintMotion>       MotionType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Swing1LimitAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsConstraintComponent::SetAngularSwing1Limit(TEnumAsByte<Engine_EAngularConstraintMotion> MotionType, float Swing1LimitAngle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit");

	UPhysicsConstraintComponent_SetAngularSwing1Limit_Params params {};
	params.MotionType = MotionType;
	params.Swing1LimitAngle = Swing1LimitAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A490
//		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget
//		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    InPosTarget                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetAngularOrientationTarget(const struct FRotator& InPosTarget)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget");

	UPhysicsConstraintComponent_SetAngularOrientationTarget_Params params {};
	params.InPosTarget = InPosTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A3C0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnableSwingDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bEnableTwistDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive");

	UPhysicsConstraintComponent_SetAngularOrientationDrive_Params params {};
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A2B0
//		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularDriveParams
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InSpring                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InDamping                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InForceLimit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPhysicsConstraintComponent::SetAngularDriveParams(float InSpring, float InDamping, float InForceLimit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularDriveParams");

	UPhysicsConstraintComponent_SetAngularDriveParams_Params params {};
	params.InSpring = InSpring;
	params.InDamping = InDamping;
	params.InForceLimit = InForceLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B31F20
//		Name   -> Function Engine.PhysicsConstraintComponent.GetCurrentTwist
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UPhysicsConstraintComponent::GetCurrentTwist()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentTwist");

	UPhysicsConstraintComponent_GetCurrentTwist_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31EF0
//		Name   -> Function Engine.PhysicsConstraintComponent.GetCurrentSwing2
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UPhysicsConstraintComponent::GetCurrentSwing2()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentSwing2");

	UPhysicsConstraintComponent_GetCurrentSwing2_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31EC0
//		Name   -> Function Engine.PhysicsConstraintComponent.GetCurrentSwing1
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UPhysicsConstraintComponent::GetCurrentSwing1()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentSwing1");

	UPhysicsConstraintComponent_GetCurrentSwing1_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31D40
//		Name   -> Function Engine.PhysicsConstraintComponent.GetConstraintForce
//		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     OutLinearForce                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     OutAngularForce                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPhysicsConstraintComponent::GetConstraintForce(struct FVector* OutLinearForce, struct FVector* OutAngularForce)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetConstraintForce");

	UPhysicsConstraintComponent_GetConstraintForce_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutLinearForce != nullptr)
		*OutLinearForce = params.OutLinearForce;
	if (OutAngularForce != nullptr)
		*OutAngularForce = params.OutAngularForce;

}


// Function:
//		Offset -> 0x02B2EA50
//		Name   -> Function Engine.PhysicsConstraintComponent.BreakConstraint
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
void UPhysicsConstraintComponent::BreakConstraint()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.BreakConstraint");

	UPhysicsConstraintComponent_BreakConstraint_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UPhysicsConstraintComponent::AfterRead()
{
	USceneComponent::AfterRead();

	READ_PTR_FULL(ConstraintActor1, AActor);
	READ_PTR_FULL(ConstraintActor2, AActor);
	READ_PTR_FULL(ConstraintSetup, UPhysicsConstraintTemplate);
}

void UPhysicsConstraintComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

	DELE_PTR_FULL(ConstraintActor1);
	DELE_PTR_FULL(ConstraintActor2);
	DELE_PTR_FULL(ConstraintSetup);
}

void USkeleton::AfterRead()
{
	UObject::AfterRead();

}

void USkeleton::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02B317A0
//		Name   -> Function Engine.Interface_Animatable.GetAnimInstance
//		Flags  -> (RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UAnimInstance*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UAnimInstance* UInterface_Animatable::GetAnimInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Interface_Animatable.GetAnimInstance");

	UInterface_Animatable_GetAnimInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UInterface_Animatable::AfterRead()
{
	UInterface::AfterRead();

}

void UInterface_Animatable::BeforeDelete()
{
	UInterface::BeforeDelete();

}

// Function:
//		Offset -> 0x02B410E0
//		Name   -> Function Engine.SkeletalMeshComponent.UnbindClothFromMasterPoseComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bRestoreSimulationSpace                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::UnbindClothFromMasterPoseComponent(bool bRestoreSimulationSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.UnbindClothFromMasterPoseComponent");

	USkeletalMeshComponent_UnbindClothFromMasterPoseComponent_Params params {};
	params.bRestoreSimulationSpace = bRestoreSimulationSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B408C0
//		Name   -> Function Engine.SkeletalMeshComponent.Stop
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USkeletalMeshComponent::Stop()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.Stop");

	USkeletalMeshComponent_Stop_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F250
//		Name   -> Function Engine.SkeletalMeshComponent.SetPosition
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InPos                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bFireNotifies                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::SetPosition(float InPos, bool bFireNotifies)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPosition");

	USkeletalMeshComponent_SetPosition_Params params {};
	params.InPos = InPos;
	params.bFireNotifies = bFireNotifies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3F100
//		Name   -> Function Engine.SkeletalMeshComponent.SetPlayRate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkeletalMeshComponent::SetPlayRate(float Rate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPlayRate");

	USkeletalMeshComponent_SetPlayRate_Params params {};
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3EB50
//		Name   -> Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              PhysicsBlendWeight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkeletalMeshComponent::SetPhysicsBlendWeight(float PhysicsBlendWeight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight");

	USkeletalMeshComponent_SetPhysicsBlendWeight_Params params {};
	params.PhysicsBlendWeight = PhysicsBlendWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E5A0
//		Name   -> Function Engine.SkeletalMeshComponent.SetMorphTarget
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       MorphTargetName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bRemoveZeroWeight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::SetMorphTarget(const struct FName& MorphTargetName, float Value, bool bRemoveZeroWeight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetMorphTarget");

	USkeletalMeshComponent_SetMorphTarget_Params params {};
	params.MorphTargetName = MorphTargetName;
	params.Value = Value;
	params.bRemoveZeroWeight = bRemoveZeroWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3CBF0
//		Name   -> Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewBlendPhysics                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::SetEnablePhysicsBlending(bool bNewBlendPhysics)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending");

	USkeletalMeshComponent_SetEnablePhysicsBlending_Params params {};
	params.bNewBlendPhysics = bNewBlendPhysics;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3B920
//		Name   -> Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkeletalMeshComponent::SetClothMaxDistanceScale(float Scale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale");

	USkeletalMeshComponent_SetClothMaxDistanceScale_Params params {};
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A8C0
//		Name   -> Function Engine.SkeletalMeshComponent.SetAnimInstanceClass
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      NewClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkeletalMeshComponent::SetAnimInstanceClass(class UClass* NewClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimInstanceClass");

	USkeletalMeshComponent_SetAnimInstanceClass_Params params {};
	params.NewClass = NewClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A9C0
//		Name   -> Function Engine.SkeletalMeshComponent.SetAnimationMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EAnimationMode>                 InAnimationMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkeletalMeshComponent::SetAnimationMode(TEnumAsByte<Engine_EAnimationMode> InAnimationMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimationMode");

	USkeletalMeshComponent_SetAnimationMode_Params params {};
	params.InAnimationMode = InAnimationMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A940
//		Name   -> Function Engine.SkeletalMeshComponent.SetAnimation
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimationAsset*                             NewAnimToPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USkeletalMeshComponent::SetAnimation(class UAnimationAsset* NewAnimToPlay)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimation");

	USkeletalMeshComponent_SetAnimation_Params params {};
	params.NewAnimToPlay = NewAnimToPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3A030
//		Name   -> Function Engine.SkeletalMeshComponent.SetAllMotorsAngularVelocityDrive
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnableSwingDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bEnableTwistDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSkipCustomPhysicsType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularVelocityDrive");

	USkeletalMeshComponent_SetAllMotorsAngularVelocityDrive_Params params {};
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39F10
//		Name   -> Function Engine.SkeletalMeshComponent.SetAllMotorsAngularPositionDrive
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnableSwingDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bEnableTwistDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bSkipCustomPhysicsType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularPositionDrive");

	USkeletalMeshComponent_SetAllMotorsAngularPositionDrive_Params params {};
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39DB0
//		Name   -> Function Engine.SkeletalMeshComponent.SetAllMotorsAngularDriveParams
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InSpring                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InDamping                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InForceLimit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSkipCustomPhysicsType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, bool bSkipCustomPhysicsType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularDriveParams");

	USkeletalMeshComponent_SetAllMotorsAngularDriveParams_Params params {};
	params.InSpring = InSpring;
	params.InDamping = InDamping;
	params.InForceLimit = InForceLimit;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39CA0
//		Name   -> Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewSimulate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::SetAllBodiesSimulatePhysics(bool bNewSimulate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics");

	USkeletalMeshComponent_SetAllBodiesSimulatePhysics_Params params {};
	params.bNewSimulate = bNewSimulate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39BD0
//		Name   -> Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              PhysicsBlendWeight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSkipCustomPhysicsType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight");

	USkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight_Params params {};
	params.PhysicsBlendWeight = PhysicsBlendWeight;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39B00
//		Name   -> Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FName                                       InBoneName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bNewSimulate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::SetAllBodiesBelowSimulatePhysics(const struct FName& InBoneName, bool bNewSimulate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics");

	USkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics_Params params {};
	params.InBoneName = InBoneName;
	params.bNewSimulate = bNewSimulate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B399E0
//		Name   -> Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FName                                       InBoneName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              PhysicsBlendWeight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSkipCustomPhysicsType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::SetAllBodiesBelowPhysicsBlendWeight(const struct FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight");

	USkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight_Params params {};
	params.InBoneName = InBoneName;
	params.PhysicsBlendWeight = PhysicsBlendWeight;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39450
//		Name   -> Function Engine.SkeletalMeshComponent.ResetClothTeleportMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USkeletalMeshComponent::ResetClothTeleportMode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetClothTeleportMode");

	USkeletalMeshComponent_ResetClothTeleportMode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39430
//		Name   -> Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USkeletalMeshComponent::ResetAllBodiesSimulatePhysics()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics");

	USkeletalMeshComponent_ResetAllBodiesSimulatePhysics_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38B70
//		Name   -> Function Engine.SkeletalMeshComponent.PlayAnimation
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimationAsset*                             NewAnimToPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::PlayAnimation(class UAnimationAsset* NewAnimToPlay, bool bLooping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.PlayAnimation");

	USkeletalMeshComponent_PlayAnimation_Params params {};
	params.NewAnimToPlay = NewAnimToPlay;
	params.bLooping = bLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B389D0
//		Name   -> Function Engine.SkeletalMeshComponent.Play
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::Play(bool bLooping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.Play");

	USkeletalMeshComponent_Play_Params params {};
	params.bLooping = bLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B370B0
//		Name   -> Function Engine.SkeletalMeshComponent.IsPlaying
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool USkeletalMeshComponent::IsPlaying()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsPlaying");

	USkeletalMeshComponent_IsPlaying_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34080
//		Name   -> Function Engine.SkeletalMeshComponent.GetPosition
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USkeletalMeshComponent::GetPosition()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPosition");

	USkeletalMeshComponent_GetPosition_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34050
//		Name   -> Function Engine.SkeletalMeshComponent.GetPlayRate
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USkeletalMeshComponent::GetPlayRate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPlayRate");

	USkeletalMeshComponent_GetPlayRate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32F60
//		Name   -> Function Engine.SkeletalMeshComponent.GetMorphTarget
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       MorphTargetName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USkeletalMeshComponent::GetMorphTarget(const struct FName& MorphTargetName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetMorphTarget");

	USkeletalMeshComponent_GetMorphTarget_Params params {};
	params.MorphTargetName = MorphTargetName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31BE0
//		Name   -> Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USkeletalMeshComponent::GetClothMaxDistanceScale()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale");

	USkeletalMeshComponent_GetClothMaxDistanceScale_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B317D0
//		Name   -> Function Engine.SkeletalMeshComponent.GetAnimInstance
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UAnimInstance*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UAnimInstance* USkeletalMeshComponent::GetAnimInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimInstance");

	USkeletalMeshComponent_GetAnimInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31810
//		Name   -> Function Engine.SkeletalMeshComponent.GetAnimationMode
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_EAnimationMode>                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
TEnumAsByte<Engine_EAnimationMode> USkeletalMeshComponent::GetAnimationMode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimationMode");

	USkeletalMeshComponent_GetAnimationMode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B31290
//		Name   -> Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USkeletalMeshComponent::ForceClothNextUpdateTeleportAndReset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset");

	USkeletalMeshComponent_ForceClothNextUpdateTeleportAndReset_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B31270
//		Name   -> Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USkeletalMeshComponent::ForceClothNextUpdateTeleport()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport");

	USkeletalMeshComponent_ForceClothNextUpdateTeleport_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2EE30
//		Name   -> Function Engine.SkeletalMeshComponent.ClearMorphTargets
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USkeletalMeshComponent::ClearMorphTargets()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ClearMorphTargets");

	USkeletalMeshComponent_ClearMorphTargets_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2E970
//		Name   -> Function Engine.SkeletalMeshComponent.BindClothToMasterPoseComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USkeletalMeshComponent::BindClothToMasterPoseComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BindClothToMasterPoseComponent");

	USkeletalMeshComponent_BindClothToMasterPoseComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B2CF70
//		Name   -> Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FName                                       InBoneName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              AddPhysicsBlendWeight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSkipCustomPhysicsType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshComponent::AccumulateAllBodiesBelowPhysicsBlendWeight(const struct FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight");

	USkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight_Params params {};
	params.InBoneName = InBoneName;
	params.AddPhysicsBlendWeight = AddPhysicsBlendWeight;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void USkeletalMeshComponent::AfterRead()
{
	USkinnedMeshComponent::AfterRead();

	READ_PTR_FULL(AnimBlueprintGeneratedClass, UClass);
	READ_PTR_FULL(AnimScriptInstance, UAnimInstance);
	READ_PTR_FULL(BodySetup, UBodySetup);
}

void USkeletalMeshComponent::BeforeDelete()
{
	USkinnedMeshComponent::BeforeDelete();

	DELE_PTR_FULL(AnimBlueprintGeneratedClass);
	DELE_PTR_FULL(AnimScriptInstance);
	DELE_PTR_FULL(BodySetup);
}

void UMatineeAnimInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UMatineeAnimInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

// Function:
//		Offset -> 0x02B38360
//		Name   -> Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset
//		Flags  -> (Native, Public)
void ASkeletalMeshActor::OnRep_ReplicatedPhysAsset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset");

	ASkeletalMeshActor_OnRep_ReplicatedPhysAsset_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38340
//		Name   -> Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh
//		Flags  -> (Native, Public)
void ASkeletalMeshActor::OnRep_ReplicatedMesh()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh");

	ASkeletalMeshActor_OnRep_ReplicatedMesh_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38320
//		Name   -> Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1
//		Flags  -> (Native, Public)
void ASkeletalMeshActor::OnRep_ReplicatedMaterial1()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1");

	ASkeletalMeshActor_OnRep_ReplicatedMaterial1_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38300
//		Name   -> Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0
//		Flags  -> (Native, Public)
void ASkeletalMeshActor::OnRep_ReplicatedMaterial0()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0");

	ASkeletalMeshActor_OnRep_ReplicatedMaterial0_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void ASkeletalMeshActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(SkeletalMeshComponent, USkeletalMeshComponent);
	READ_PTR_FULL(ReplicatedMesh, USkeletalMesh);
	READ_PTR_FULL(ReplicatedPhysAsset, UPhysicsAsset);
	READ_PTR_FULL(ReplicatedMaterial0, UMaterialInterface);
	READ_PTR_FULL(ReplicatedMaterial1, UMaterialInterface);
}

void ASkeletalMeshActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(SkeletalMeshComponent);
	DELE_PTR_FULL(ReplicatedMesh);
	DELE_PTR_FULL(ReplicatedPhysAsset);
	DELE_PTR_FULL(ReplicatedMaterial0);
	DELE_PTR_FULL(ReplicatedMaterial1);
}

void ASplineMeshActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(SplineMeshComponent, USplineMeshComponent);
}

void ASplineMeshActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(SplineMeshComponent);
}

void ACoveredMeshActor::AfterRead()
{
	AStaticMeshActor::AfterRead();

	READ_PTR_FULL(InstancedCoverageMeshComponent, UInstancedCoverageMeshComponent);
}

void ACoveredMeshActor::BeforeDelete()
{
	AStaticMeshActor::BeforeDelete();

	DELE_PTR_FULL(InstancedCoverageMeshComponent);
}

void AStreamingProbe::AfterRead()
{
	AActor::AfterRead();

}

void AStreamingProbe::BeforeDelete()
{
	AActor::BeforeDelete();

}

void ATargetPoint::AfterRead()
{
	AActor::AfterRead();

}

void ATargetPoint::BeforeDelete()
{
	AActor::BeforeDelete();

}

void ATextRenderActor::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(TextRender, UTextRenderComponent);
}

void ATextRenderActor::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(TextRender);
}

void ATriggerBase::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(CollisionComponent, UShapeComponent);
	READ_PTR_FULL(SpriteComponent, UBillboardComponent);
}

void ATriggerBase::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(CollisionComponent);
	DELE_PTR_FULL(SpriteComponent);
}

void ATriggerBox::AfterRead()
{
	ATriggerBase::AfterRead();

}

void ATriggerBox::BeforeDelete()
{
	ATriggerBase::BeforeDelete();

}

void ATriggerCapsule::AfterRead()
{
	ATriggerBase::AfterRead();

}

void ATriggerCapsule::BeforeDelete()
{
	ATriggerBase::BeforeDelete();

}

void ATriggerSphere::AfterRead()
{
	ATriggerBase::AfterRead();

}

void ATriggerSphere::BeforeDelete()
{
	ATriggerBase::BeforeDelete();

}

void AVectorFieldVolume::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(VectorFieldComponent, UVectorFieldComponent);
}

void AVectorFieldVolume::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(VectorFieldComponent);
}

void AWaterEmissionVolume::AfterRead()
{
	AActor::AfterRead();

	READ_PTR_FULL(WaterEmissionVolumeComponent, UWaterEmissionVolumeComponent);
}

void AWaterEmissionVolume::BeforeDelete()
{
	AActor::BeforeDelete();

	DELE_PTR_FULL(WaterEmissionVolumeComponent);
}

void UComponentWithTestInterface::AfterRead()
{
	UActorComponent::AfterRead();

}

void UComponentWithTestInterface::BeforeDelete()
{
	UActorComponent::BeforeDelete();

}

void UAnotherComponentWithTestInterface::AfterRead()
{
	UActorComponent::AfterRead();

}

void UAnotherComponentWithTestInterface::BeforeDelete()
{
	UActorComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.ApplicationLifecycleComponent.ApplicationLifetimeDelegate__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate)
void UApplicationLifecycleComponent::ApplicationLifetimeDelegate__DelegateSignature()
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.ApplicationLifecycleComponent.ApplicationLifetimeDelegate__DelegateSignature");

	UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UApplicationLifecycleComponent::AfterRead()
{
	UActorComponent::AfterRead();

}

void UApplicationLifecycleComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02B41170
//		Name   -> Function Engine.AggregatorInterface.UnregisterAggregatable
//		Flags  -> (Native, Public, BlueprintCallable)
void UAggregatorInterface::UnregisterAggregatable()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AggregatorInterface.UnregisterAggregatable");

	UAggregatorInterface_UnregisterAggregatable_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39060
//		Name   -> Function Engine.AggregatorInterface.RegisterAggregatable
//		Flags  -> (Native, Public, BlueprintCallable)
void UAggregatorInterface::RegisterAggregatable()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AggregatorInterface.RegisterAggregatable");

	UAggregatorInterface_RegisterAggregatable_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UAggregatorInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UAggregatorInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

// Function:
//		Offset -> 0x02B41210
//		Name   -> Function Engine.ComponentAggregatorComponent.UnregisterAggregatable
//		Flags  -> (Native, Public, BlueprintCallable)
void UComponentAggregatorComponent::UnregisterAggregatable()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ComponentAggregatorComponent.UnregisterAggregatable");

	UComponentAggregatorComponent_UnregisterAggregatable_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B39100
//		Name   -> Function Engine.ComponentAggregatorComponent.RegisterAggregatable
//		Flags  -> (Native, Public, BlueprintCallable)
void UComponentAggregatorComponent::RegisterAggregatable()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ComponentAggregatorComponent.RegisterAggregatable");

	UComponentAggregatorComponent_RegisterAggregatable_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UComponentAggregatorComponent::AfterRead()
{
	UActorComponent::AfterRead();

}

void UComponentAggregatorComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02B40A10
//		Name   -> Function Engine.InterpToMovementComponent.StopSimulating
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
void UInterpToMovementComponent::StopSimulating(const struct FHitResult& HitResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.StopSimulating");

	UInterpToMovementComponent_StopSimulating_Params params {};
	params.HitResult = HitResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitEndDelegate__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
//		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UInterpToMovementComponent::OnInterpToWaitEndDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitEndDelegate__DelegateSignature");

	UInterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature_Params params {};
	params.ImpactResult = ImpactResult;
	params.Time = Time;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitBeginDelegate__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
//		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UInterpToMovementComponent::OnInterpToWaitBeginDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitBeginDelegate__DelegateSignature");

	UInterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature_Params params {};
	params.ImpactResult = ImpactResult;
	params.Time = Time;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.InterpToMovementComponent.OnInterpToStopDelegate__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
//		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UInterpToMovementComponent::OnInterpToStopDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToStopDelegate__DelegateSignature");

	UInterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature_Params params {};
	params.ImpactResult = ImpactResult;
	params.Time = Time;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.InterpToMovementComponent.OnInterpToReverseDelegate__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
//		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UInterpToMovementComponent::OnInterpToReverseDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToReverseDelegate__DelegateSignature");

	UInterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature_Params params {};
	params.ImpactResult = ImpactResult;
	params.Time = Time;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.InterpToMovementComponent.OnInterpToResetDelegate__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
//		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UInterpToMovementComponent::OnInterpToResetDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToResetDelegate__DelegateSignature");

	UInterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature_Params params {};
	params.ImpactResult = ImpactResult;
	params.Time = Time;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UInterpToMovementComponent::AfterRead()
{
	UMovementComponent::AfterRead();

}

void UInterpToMovementComponent::BeforeDelete()
{
	UMovementComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02B412B0
//		Name   -> Function Engine.NavigationSystem.UnregisterNavigationInvoker
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      Invoker                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNavigationSystem::UnregisterNavigationInvoker(class AActor* Invoker)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.UnregisterNavigationInvoker");

	UNavigationSystem_UnregisterNavigationInvoker_Params params {};
	params.Invoker = Invoker;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B40690
//		Name   -> Function Engine.NavigationSystem.SimpleMoveToLocation
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Goal                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UNavigationSystem::STATIC_SimpleMoveToLocation(class AController* Controller, const struct FVector& Goal)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.SimpleMoveToLocation");

	UNavigationSystem_SimpleMoveToLocation_Params params {};
	params.Controller = Controller;
	params.Goal = Goal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B405E0
//		Name   -> Function Engine.NavigationSystem.SimpleMoveToActor
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      Goal                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNavigationSystem::STATIC_SimpleMoveToActor(class AController* Controller, class AActor* Goal)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.SimpleMoveToActor");

	UNavigationSystem_SimpleMoveToActor_Params params {};
	params.Controller = Controller;
	params.Goal = Goal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3E520
//		Name   -> Function Engine.NavigationSystem.SetMaxSimultaneousTileGenerationJobsCount
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                MaxNumberOfJobs                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNavigationSystem::SetMaxSimultaneousTileGenerationJobsCount(int MaxNumberOfJobs)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.SetMaxSimultaneousTileGenerationJobsCount");

	UNavigationSystem_SetMaxSimultaneousTileGenerationJobsCount_Params params {};
	params.MaxNumberOfJobs = MaxNumberOfJobs;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B3CF40
//		Name   -> Function Engine.NavigationSystem.SetGeometryGatheringMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ENavDataGatheringModeConfig>    NewMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNavigationSystem::SetGeometryGatheringMode(TEnumAsByte<Engine_ENavDataGatheringModeConfig> NewMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.SetGeometryGatheringMode");

	UNavigationSystem_SetGeometryGatheringMode_Params params {};
	params.NewMode = NewMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B394B0
//		Name   -> Function Engine.NavigationSystem.ResetMaxSimultaneousTileGenerationJobsCount
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UNavigationSystem::ResetMaxSimultaneousTileGenerationJobsCount()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.ResetMaxSimultaneousTileGenerationJobsCount");

	UNavigationSystem_ResetMaxSimultaneousTileGenerationJobsCount_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B391A0
//		Name   -> Function Engine.NavigationSystem.RegisterNavigationInvoker
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      Invoker                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TileGenerationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TileRemovalRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNavigationSystem::RegisterNavigationInvoker(class AActor* Invoker, float TileGenerationRadius, float TileRemovalRadius)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.RegisterNavigationInvoker");

	UNavigationSystem_RegisterNavigationInvoker_Params params {};
	params.Invoker = Invoker;
	params.TileGenerationRadius = TileGenerationRadius;
	params.TileRemovalRadius = TileRemovalRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B38DB0
//		Name   -> Function Engine.NavigationSystem.ProjectPointToNavigation
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Point                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		struct FVector                                     QueryExtent                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UNavigationSystem::STATIC_ProjectPointToNavigation(class UObject* WorldContext, const struct FVector& Point, class ANavigationData* NavData, class UClass* FilterClass, const struct FVector& QueryExtent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.ProjectPointToNavigation");

	UNavigationSystem_ProjectPointToNavigation_Params params {};
	params.WorldContext = WorldContext;
	params.Point = Point;
	params.NavData = NavData;
	params.FilterClass = FilterClass;
	params.QueryExtent = QueryExtent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B380F0
//		Name   -> Function Engine.NavigationSystem.OnNavigationBoundsUpdated
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class ANavMeshBoundsVolume*                        NavVolume                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNavigationSystem::OnNavigationBoundsUpdated(class ANavMeshBoundsVolume* NavVolume)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.OnNavigationBoundsUpdated");

	UNavigationSystem_OnNavigationBoundsUpdated_Params params {};
	params.NavVolume = NavVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02B37DA0
//		Name   -> Function Engine.NavigationSystem.NavigationRaycast
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     RayStart                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     RayEnd                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     HitLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class AController*                                 Querier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavigationSystem::STATIC_NavigationRaycast(class UObject* WorldContext, const struct FVector& RayStart, const struct FVector& RayEnd, struct FVector* HitLocation, class UClass* FilterClass, class AController* Querier)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.NavigationRaycast");

	UNavigationSystem_NavigationRaycast_Params params {};
	params.WorldContext = WorldContext;
	params.RayStart = RayStart;
	params.RayEnd = RayEnd;
	params.FilterClass = FilterClass;
	params.Querier = Querier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HitLocation != nullptr)
		*HitLocation = params.HitLocation;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B36F10
//		Name   -> Function Engine.NavigationSystem.IsNavigationBeingBuilt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavigationSystem::STATIC_IsNavigationBeingBuilt(class UObject* WorldContext)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.IsNavigationBeingBuilt");

	UNavigationSystem_IsNavigationBeingBuilt_Params params {};
	params.WorldContext = WorldContext;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34820
//		Name   -> Function Engine.NavigationSystem.GetRandomReachablePointInRadius
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UNavigationSystem::STATIC_GetRandomReachablePointInRadius(class UObject* WorldContext, const struct FVector& Origin, float Radius, class ANavigationData* NavData, class UClass* FilterClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetRandomReachablePointInRadius");

	UNavigationSystem_GetRandomReachablePointInRadius_Params params {};
	params.WorldContext = WorldContext;
	params.Origin = Origin;
	params.Radius = Radius;
	params.NavData = NavData;
	params.FilterClass = FilterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34650
//		Name   -> Function Engine.NavigationSystem.GetRandomPointInRadius
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UNavigationSystem::STATIC_GetRandomPointInRadius(class UObject* WorldContext, const struct FVector& Origin, float Radius, class ANavigationData* NavData, class UClass* FilterClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetRandomPointInRadius");

	UNavigationSystem_GetRandomPointInRadius_Params params {};
	params.WorldContext = WorldContext;
	params.Origin = Origin;
	params.Radius = Radius;
	params.NavData = NavData;
	params.FilterClass = FilterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34480
//		Name   -> Function Engine.NavigationSystem.GetRandomPointInNavigableRadius
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UNavigationSystem::STATIC_GetRandomPointInNavigableRadius(class UObject* WorldContext, const struct FVector& Origin, float Radius, class ANavigationData* NavData, class UClass* FilterClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetRandomPointInNavigableRadius");

	UNavigationSystem_GetRandomPointInNavigableRadius_Params params {};
	params.WorldContext = WorldContext;
	params.Origin = Origin;
	params.Radius = Radius;
	params.NavData = NavData;
	params.FilterClass = FilterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B34380
//		Name   -> Function Engine.NavigationSystem.GetRandomPoint
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UNavigationSystem::STATIC_GetRandomPoint(class UObject* WorldContext, class ANavigationData* NavData, class UClass* FilterClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetRandomPoint");

	UNavigationSystem_GetRandomPoint_Params params {};
	params.WorldContext = WorldContext;
	params.NavData = NavData;
	params.FilterClass = FilterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33A50
//		Name   -> Function Engine.NavigationSystem.GetPathLength
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     PathStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     PathEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              PathLength                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ENavigationQueryResult>         ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
TEnumAsByte<Engine_ENavigationQueryResult> UNavigationSystem::STATIC_GetPathLength(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, float* PathLength, class ANavigationData* NavData, class UClass* FilterClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetPathLength");

	UNavigationSystem_GetPathLength_Params params {};
	params.WorldContext = WorldContext;
	params.PathStart = PathStart;
	params.PathEnd = PathEnd;
	params.NavData = NavData;
	params.FilterClass = FilterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (PathLength != nullptr)
		*PathLength = params.PathLength;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B33830
//		Name   -> Function Engine.NavigationSystem.GetPathCost
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     PathStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     PathEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              PathCost                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ENavigationQueryResult>         ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
TEnumAsByte<Engine_ENavigationQueryResult> UNavigationSystem::STATIC_GetPathCost(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, float* PathCost, class ANavigationData* NavData, class UClass* FilterClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetPathCost");

	UNavigationSystem_GetPathCost_Params params {};
	params.WorldContext = WorldContext;
	params.PathStart = PathStart;
	params.PathEnd = PathEnd;
	params.NavData = NavData;
	params.FilterClass = FilterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (PathCost != nullptr)
		*PathCost = params.PathCost;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B331A0
//		Name   -> Function Engine.NavigationSystem.GetNavigationSystem
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UNavigationSystem*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UNavigationSystem* UNavigationSystem::STATIC_GetNavigationSystem(class UObject* WorldContext)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetNavigationSystem");

	UNavigationSystem_GetNavigationSystem_Params params {};
	params.WorldContext = WorldContext;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B32CC0
//		Name   -> Function Engine.NavigationSystem.GetMainNavData
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class ANavigationData*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class ANavigationData* UNavigationSystem::GetMainNavData()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetMainNavData");

	UNavigationSystem_GetMainNavData_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B30F10
//		Name   -> Function Engine.NavigationSystem.FindPathToLocationSynchronously
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     PathStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     PathEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		class AActor*                                      PathfindingContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class UNavigationPath*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UNavigationPath* UNavigationSystem::STATIC_FindPathToLocationSynchronously(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, class AActor* PathfindingContext, class UClass* FilterClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.FindPathToLocationSynchronously");

	UNavigationSystem_FindPathToLocationSynchronously_Params params {};
	params.WorldContext = WorldContext;
	params.PathStart = PathStart;
	params.PathEnd = PathEnd;
	params.PathfindingContext = PathfindingContext;
	params.FilterClass = FilterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B30D20
//		Name   -> Function Engine.NavigationSystem.FindPathToActorSynchronously
//		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     PathStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		class AActor*                                      GoalActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              TetherDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class AActor*                                      PathfindingContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		class UNavigationPath*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UNavigationPath* UNavigationSystem::STATIC_FindPathToActorSynchronously(class UObject* WorldContext, const struct FVector& PathStart, class AActor* GoalActor, float TetherDistance, class AActor* PathfindingContext, class UClass* FilterClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.FindPathToActorSynchronously");

	UNavigationSystem_FindPathToActorSynchronously_Params params {};
	params.WorldContext = WorldContext;
	params.PathStart = PathStart;
	params.GoalActor = GoalActor;
	params.TetherDistance = TetherDistance;
	params.PathfindingContext = PathfindingContext;
	params.FilterClass = FilterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02B2F8F0
//		Name   -> Function Engine.NavigationSystem.DoesMainNavDataHaveValidNavMesh
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavigationSystem::DoesMainNavDataHaveValidNavMesh()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.DoesMainNavDataHaveValidNavMesh");

	UNavigationSystem_DoesMainNavDataHaveValidNavMesh_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UNavigationSystem::AfterRead()
{
	UBlueprintFunctionLibrary::AfterRead();

	READ_PTR_FULL(MainNavData, ANavigationData);
	READ_PTR_FULL(AbstractNavData, ANavigationData);
	READ_PTR_FULL(InstancedNavMeshesData, UInstancedNavMeshesDataAsset);
}

void UNavigationSystem::BeforeDelete()
{
	UBlueprintFunctionLibrary::BeforeDelete();

	DELE_PTR_FULL(MainNavData);
	DELE_PTR_FULL(AbstractNavData);
	DELE_PTR_FULL(InstancedNavMeshesData);
}

// Function:
//		Offset -> 0x02C3F1A0
//		Name   -> Function Engine.AnimSequenceBase.GetPlayLength
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimSequenceBase::GetPlayLength()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSequenceBase.GetPlayLength");

	UAnimSequenceBase_GetPlayLength_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UAnimSequenceBase::AfterRead()
{
	UAnimationAsset::AfterRead();

}

void UAnimSequenceBase::BeforeDelete()
{
	UAnimationAsset::BeforeDelete();

}

void UAnimCompositeBase::AfterRead()
{
	UAnimSequenceBase::AfterRead();

}

void UAnimCompositeBase::BeforeDelete()
{
	UAnimSequenceBase::BeforeDelete();

}

void UAnimStateMachineTypes::AfterRead()
{
	UObject::AfterRead();

}

void UAnimStateMachineTypes::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UAnimMontage::AfterRead()
{
	UAnimCompositeBase::AfterRead();

}

void UAnimMontage::BeforeDelete()
{
	UAnimCompositeBase::BeforeDelete();

}

void URVOAvoidanceInterface::AfterRead()
{
	UInterface::AfterRead();

}

void URVOAvoidanceInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UNetworkPredictionInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UNetworkPredictionInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UFloatingPawnMovement::AfterRead()
{
	UPawnMovementComponent::AfterRead();

}

void UFloatingPawnMovement::BeforeDelete()
{
	UPawnMovementComponent::BeforeDelete();

}

void USpectatorPawnMovement::AfterRead()
{
	UFloatingPawnMovement::AfterRead();

}

void USpectatorPawnMovement::BeforeDelete()
{
	UFloatingPawnMovement::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D0B0
//		Name   -> Function Engine.ProjectileMovementComponent.StopSimulating
//		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
void UProjectileMovementComponent::StopSimulating(const struct FHitResult& HitResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.StopSimulating");

	UProjectileMovementComponent_StopSimulating_Params params {};
	params.HitResult = HitResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4B100
//		Name   -> Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     NewVelocity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UProjectileMovementComponent::SetVelocityInLocalSpace(const struct FVector& NewVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace");

	UProjectileMovementComponent_SetVelocityInLocalSpace_Params params {};
	params.NewVelocity = NewVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
//		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
void UProjectileMovementComponent::OnProjectileStopDelegate__DelegateSignature(const struct FHitResult& ImpactResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature");

	UProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature_Params params {};
	params.ImpactResult = ImpactResult;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> DelegateFunction Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
// Parameters:
//		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
//		struct FVector                                     ImpactVelocity                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UProjectileMovementComponent::OnProjectileBounceDelegate__DelegateSignature(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature");

	UProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature_Params params {};
	params.ImpactResult = ImpactResult;
	params.ImpactVelocity = ImpactVelocity;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41120
//		Name   -> Function Engine.ProjectileMovementComponent.LimitVelocity
//		Flags  -> (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     NewVelocity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UProjectileMovementComponent::LimitVelocity(const struct FVector& NewVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.LimitVelocity");

	UProjectileMovementComponent_LimitVelocity_Params params {};
	params.NewVelocity = NewVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UProjectileMovementComponent::AfterRead()
{
	UMovementComponent::AfterRead();

}

void UProjectileMovementComponent::BeforeDelete()
{
	UMovementComponent::BeforeDelete();

}

void URotatingMovementComponent::AfterRead()
{
	UMovementComponent::AfterRead();

}

void URotatingMovementComponent::BeforeDelete()
{
	UMovementComponent::BeforeDelete();

}

void UNavigationInvokerComponent::AfterRead()
{
	UActorComponent::AfterRead();

}

void UNavigationInvokerComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C48DA0
//		Name   -> Function Engine.NavRelevantComponent.SetNavigationRelevancy
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bRelevant                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UNavRelevantComponent::SetNavigationRelevancy(bool bRelevant)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavRelevantComponent.SetNavigationRelevancy");

	UNavRelevantComponent_SetNavigationRelevancy_Params params {};
	params.bRelevant = bRelevant;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UNavRelevantComponent::AfterRead()
{
	UActorComponent::AfterRead();

	READ_PTR_FULL(CachedNavParent, UObject);
}

void UNavRelevantComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

	DELE_PTR_FULL(CachedNavParent);
}

void UNavLinkCustomInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UNavLinkCustomInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UNavLinkCustomComponent::AfterRead()
{
	UNavRelevantComponent::AfterRead();

	READ_PTR_FULL(EnabledAreaClass, UClass);
	READ_PTR_FULL(DisabledAreaClass, UClass);
	READ_PTR_FULL(ObstacleAreaClass, UClass);
}

void UNavLinkCustomComponent::BeforeDelete()
{
	UNavRelevantComponent::BeforeDelete();

	DELE_PTR_FULL(EnabledAreaClass);
	DELE_PTR_FULL(DisabledAreaClass);
	DELE_PTR_FULL(ObstacleAreaClass);
}

void UMaterialExpressionIfShadowPass::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionIfShadowPass::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionLightmapUVs::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionLightmapUVs::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionLightmassReplace::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionLightmassReplace::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionLightVector::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionLightVector::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionLinearInterpolate::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionLinearInterpolate::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionStaticSwitch::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionStaticSwitch::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionSubtract::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionSubtract::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionTextureBase::AfterRead()
{
	UMaterialExpression::AfterRead();

	READ_PTR_FULL(Texture, UTexture);
}

void UMaterialExpressionTextureBase::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

	DELE_PTR_FULL(Texture);
}

void UMaterialExpressionTextureObject::AfterRead()
{
	UMaterialExpressionTextureBase::AfterRead();

}

void UMaterialExpressionTextureObject::BeforeDelete()
{
	UMaterialExpressionTextureBase::BeforeDelete();

}

void UMaterialExpressionTextureSample::AfterRead()
{
	UMaterialExpressionTextureBase::AfterRead();

}

void UMaterialExpressionTextureSample::BeforeDelete()
{
	UMaterialExpressionTextureBase::BeforeDelete();

}

void UMaterialExpressionParticleSubUV::AfterRead()
{
	UMaterialExpressionTextureSample::AfterRead();

}

void UMaterialExpressionParticleSubUV::BeforeDelete()
{
	UMaterialExpressionTextureSample::BeforeDelete();

}

void UNavModifierComponent::AfterRead()
{
	UNavRelevantComponent::AfterRead();

	READ_PTR_FULL(AreaClass, UClass);
}

void UNavModifierComponent::BeforeDelete()
{
	UNavRelevantComponent::BeforeDelete();

	DELE_PTR_FULL(AreaClass);
}

// Function:
//		Offset -> 0x02C41530
//		Name   -> Function Engine.PawnNoiseEmitterComponent.MakeNoise
//		Flags  -> (BlueprintAuthorityOnly, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class AActor*                                      NoiseMaker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Loudness                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     NoiseLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UPawnNoiseEmitterComponent::MakeNoise(class AActor* NoiseMaker, float Loudness, const struct FVector& NoiseLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PawnNoiseEmitterComponent.MakeNoise");

	UPawnNoiseEmitterComponent_MakeNoise_Params params {};
	params.NoiseMaker = NoiseMaker;
	params.Loudness = Loudness;
	params.NoiseLocation = NoiseLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UPawnNoiseEmitterComponent::AfterRead()
{
	UActorComponent::AfterRead();

}

void UPawnNoiseEmitterComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C45C70
//		Name   -> Function Engine.BoxComponent.SetBoxExtent
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     InBoxExtent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateOverlaps                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UBoxComponent::SetBoxExtent(const struct FVector& InBoxExtent, bool bUpdateOverlaps)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.SetBoxExtent");

	UBoxComponent_SetBoxExtent_Params params {};
	params.InBoxExtent = InBoxExtent;
	params.bUpdateOverlaps = bUpdateOverlaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C403B0
//		Name   -> Function Engine.BoxComponent.GetUnscaledBoxExtent
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UBoxComponent::GetUnscaledBoxExtent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.GetUnscaledBoxExtent");

	UBoxComponent_GetUnscaledBoxExtent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F990
//		Name   -> Function Engine.BoxComponent.GetScaledBoxExtent
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UBoxComponent::GetScaledBoxExtent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.GetScaledBoxExtent");

	UBoxComponent_GetScaledBoxExtent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UBoxComponent::AfterRead()
{
	UShapeComponent::AfterRead();

}

void UBoxComponent::BeforeDelete()
{
	UShapeComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C49CF0
//		Name   -> Function Engine.SphereComponent.SetSphereRadius
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InSphereRadius                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUpdateOverlaps                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USphereComponent::SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.SetSphereRadius");

	USphereComponent_SetSphereRadius_Params params {};
	params.InSphereRadius = InSphereRadius;
	params.bUpdateOverlaps = bUpdateOverlaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40510
//		Name   -> Function Engine.SphereComponent.GetUnscaledSphereRadius
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USphereComponent::GetUnscaledSphereRadius()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetUnscaledSphereRadius");

	USphereComponent_GetUnscaledSphereRadius_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FC40
//		Name   -> Function Engine.SphereComponent.GetShapeScale
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USphereComponent::GetShapeScale()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetShapeScale");

	USphereComponent_GetShapeScale_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FBB0
//		Name   -> Function Engine.SphereComponent.GetScaledSphereRadius
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USphereComponent::GetScaledSphereRadius()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetScaledSphereRadius");

	USphereComponent_GetScaledSphereRadius_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void USphereComponent::AfterRead()
{
	UShapeComponent::AfterRead();

}

void USphereComponent::BeforeDelete()
{
	UShapeComponent::BeforeDelete();

}

void UDrawSphereComponent::AfterRead()
{
	USphereComponent::AfterRead();

}

void UDrawSphereComponent::BeforeDelete()
{
	USphereComponent::BeforeDelete();

}

void UEllipsoidComponent::AfterRead()
{
	USphereComponent::AfterRead();

}

void UEllipsoidComponent::BeforeDelete()
{
	USphereComponent::BeforeDelete();

}

void UParticleModuleLocationBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleLocationBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleLocationPrimitiveTriangle::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleLocationPrimitiveTriangle::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UParticleModuleLocationSkelVertSurface::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleLocationSkelVertSurface::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UPhysicsConstraintTemplate::AfterRead()
{
	UObject::AfterRead();

}

void UPhysicsConstraintTemplate::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UPhysicsSerializer::AfterRead()
{
	UObject::AfterRead();

}

void UPhysicsSerializer::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02C48C70
//		Name   -> Function Engine.FFTWaterExtendedPlaneComponent.SetMurkyRegion
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FMurkyRegion                                MurkyRegion                                                (ConstParm, Parm, OutParm, ReferenceParm)
void UFFTWaterExtendedPlaneComponent::SetMurkyRegion(const struct FMurkyRegion& MurkyRegion)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FFTWaterExtendedPlaneComponent.SetMurkyRegion");

	UFFTWaterExtendedPlaneComponent_SetMurkyRegion_Params params {};
	params.MurkyRegion = MurkyRegion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UFFTWaterExtendedPlaneComponent::AfterRead()
{
	UBaseWaterComponent::AfterRead();

	READ_PTR_FULL(Material, UMaterial);
}

void UFFTWaterExtendedPlaneComponent::BeforeDelete()
{
	UBaseWaterComponent::BeforeDelete();

	DELE_PTR_FULL(Material);
}

// Function:
//		Offset -> 0x02C4AFC0
//		Name   -> Function Engine.BillboardComponent.SetUV
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                NewU                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NewUL                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NewV                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NewVL                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UBillboardComponent::SetUV(int NewU, int NewUL, int NewV, int NewVL)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetUV");

	UBillboardComponent_SetUV_Params params {};
	params.NewU = NewU;
	params.NewUL = NewUL;
	params.NewV = NewV;
	params.NewVL = NewVL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49F30
//		Name   -> Function Engine.BillboardComponent.SetSpriteAndUV
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UTexture2D*                                  NewSprite                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NewU                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NewUL                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NewV                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                NewVL                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UBillboardComponent::SetSpriteAndUV(class UTexture2D* NewSprite, int NewU, int NewUL, int NewV, int NewVL)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetSpriteAndUV");

	UBillboardComponent_SetSpriteAndUV_Params params {};
	params.NewSprite = NewSprite;
	params.NewU = NewU;
	params.NewUL = NewUL;
	params.NewV = NewV;
	params.NewVL = NewVL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49EA0
//		Name   -> Function Engine.BillboardComponent.SetSprite
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UTexture2D*                                  NewSprite                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UBillboardComponent::SetSprite(class UTexture2D* NewSprite)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetSprite");

	UBillboardComponent_SetSprite_Params params {};
	params.NewSprite = NewSprite;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UBillboardComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

	READ_PTR_FULL(Sprite, UTexture2D);
}

void UBillboardComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

	DELE_PTR_FULL(Sprite);
}

void UBrushComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

	READ_PTR_FULL(Brush, UModel);
	READ_PTR_FULL(BrushBodySetup, UBodySetup);
}

void UBrushComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

	DELE_PTR_FULL(Brush);
	DELE_PTR_FULL(BrushBodySetup);
}

void UDrawFrustumComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

	READ_PTR_FULL(Texture, UTexture);
}

void UDrawFrustumComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

	DELE_PTR_FULL(Texture);
}

void ULineBatchComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

}

void ULineBatchComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C378B0
//		Name   -> Function Engine.MaterialBillboardComponent.AddElement
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UCurveFloat*                                 DistanceToOpacityCurve                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bSizeIsInScreenSpace                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              BaseSizeX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              BaseSizeY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UCurveFloat*                                 DistanceToSizeCurve                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UMaterialBillboardComponent::AddElement(class UMaterialInterface* Material, class UCurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, class UCurveFloat* DistanceToSizeCurve)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialBillboardComponent.AddElement");

	UMaterialBillboardComponent_AddElement_Params params {};
	params.Material = Material;
	params.DistanceToOpacityCurve = DistanceToOpacityCurve;
	params.bSizeIsInScreenSpace = bSizeIsInScreenSpace;
	params.BaseSizeX = BaseSizeX;
	params.BaseSizeY = BaseSizeY;
	params.DistanceToSizeCurve = DistanceToSizeCurve;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UMaterialBillboardComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

}

void UMaterialBillboardComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

}

void UCollisionProfile::AfterRead()
{
	UDeveloperSettings::AfterRead();

}

void UCollisionProfile::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

}

void UMaterialExpressionAppendVector::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionAppendVector::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionAtmosphericFogColor::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionAtmosphericFogColor::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionBlackBody::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionBlackBody::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionBoneMatrix::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionBoneMatrix::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void USCS_Node::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(ComponentTemplate, UActorComponent);
}

void USCS_Node::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(ComponentTemplate);
}

void USelection::AfterRead()
{
	UObject::AfterRead();

}

void USelection::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02EEDFC0
//		Name   -> Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation
//		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class USkeletalMeshComponent*                      SkelComp                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     WorldLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     WorldNormal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USkeletalMeshSocket::InitializeSocketFromLocation(class USkeletalMeshComponent* SkelComp, const struct FVector& WorldLocation, const struct FVector& WorldNormal)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation");

	USkeletalMeshSocket_InitializeSocketFromLocation_Params params {};
	params.SkelComp = SkelComp;
	params.WorldLocation = WorldLocation;
	params.WorldNormal = WorldNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02EEDF00
//		Name   -> Function Engine.SkeletalMeshSocket.GetSocketLocation
//		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class USkeletalMeshComponent*                      SkelComp                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USkeletalMeshSocket::GetSocketLocation(class USkeletalMeshComponent* SkelComp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshSocket.GetSocketLocation");

	USkeletalMeshSocket_GetSocketLocation_Params params {};
	params.SkelComp = SkelComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void USkeletalMeshSocket::AfterRead()
{
	UObject::AfterRead();

}

void USkeletalMeshSocket::BeforeDelete()
{
	UObject::BeforeDelete();

}

void USoundNode::AfterRead()
{
	UObject::AfterRead();

}

void USoundNode::BeforeDelete()
{
	UObject::BeforeDelete();

}

void USoundNodeDistanceCrossFade::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeDistanceCrossFade::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeParamCrossFade::AfterRead()
{
	USoundNodeDistanceCrossFade::AfterRead();

}

void USoundNodeParamCrossFade::BeforeDelete()
{
	USoundNodeDistanceCrossFade::BeforeDelete();

}

void USoundNodeDoppler::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeDoppler::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeEnveloper::AfterRead()
{
	USoundNode::AfterRead();

	READ_PTR_FULL(VolumeInterpCurve, UDistributionFloatConstantCurve);
	READ_PTR_FULL(PitchInterpCurve, UDistributionFloatConstantCurve);
}

void USoundNodeEnveloper::BeforeDelete()
{
	USoundNode::BeforeDelete();

	DELE_PTR_FULL(VolumeInterpCurve);
	DELE_PTR_FULL(PitchInterpCurve);
}

void USoundNodeGroupControl::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeGroupControl::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeLooping::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeLooping::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeMature::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeMature::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeMixer::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeMixer::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeModulator::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeModulator::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

// Function:
//		Offset -> 0x02C3EEA0
//		Name   -> Function Engine.StaticMesh.GetNumUVChannels
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                LodLevel                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UStaticMesh::GetNumUVChannels(int LodLevel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetNumUVChannels");

	UStaticMesh_GetNumUVChannels_Params params {};
	params.LodLevel = LodLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3EE70
//		Name   -> Function Engine.StaticMesh.GetNumLODsBP
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UStaticMesh::GetNumLODsBP()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetNumLODsBP");

	UStaticMesh_GetNumLODsBP_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D1A0
//		Name   -> Function Engine.StaticMesh.GetBoundingBox
//		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FBox                                        ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FBox UStaticMesh::GetBoundingBox()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetBoundingBox");

	UStaticMesh_GetBoundingBox_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UStaticMesh::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(BodySetup, UBodySetup);
	READ_PTR_FULL(NavCollision, UNavCollision);
}

void UStaticMesh::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(BodySetup);
	DELE_PTR_FULL(NavCollision);
}

// Function:
//		Offset -> 0x02C3FF70
//		Name   -> Function Engine.MergedCollisionComponent.GetStaticMeshByInstanceBodyIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                InstanceBodyIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UStaticMesh*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UStaticMesh* UMergedCollisionComponent::GetStaticMeshByInstanceBodyIndex(int InstanceBodyIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MergedCollisionComponent.GetStaticMeshByInstanceBodyIndex");

	UMergedCollisionComponent_GetStaticMeshByInstanceBodyIndex_Params params {};
	params.InstanceBodyIndex = InstanceBodyIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F010
//		Name   -> Function Engine.MergedCollisionComponent.GetOwningActorCrc32ByInstanceBodyIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                InstanceBodyIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UMergedCollisionComponent::GetOwningActorCrc32ByInstanceBodyIndex(int InstanceBodyIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MergedCollisionComponent.GetOwningActorCrc32ByInstanceBodyIndex");

	UMergedCollisionComponent_GetOwningActorCrc32ByInstanceBodyIndex_Params params {};
	params.InstanceBodyIndex = InstanceBodyIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UMergedCollisionComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

}

void UMergedCollisionComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C46960
//		Name   -> Function Engine.DestructibleComponent.SetDestructibleMesh
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UDestructibleMesh*                           NewMesh                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDestructibleComponent::SetDestructibleMesh(class UDestructibleMesh* NewMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DestructibleComponent.SetDestructibleMesh");

	UDestructibleComponent_SetDestructibleMesh_Params params {};
	params.NewMesh = NewMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3D930
//		Name   -> Function Engine.DestructibleComponent.GetDestructibleMesh
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UDestructibleMesh*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UDestructibleMesh* UDestructibleComponent::GetDestructibleMesh()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DestructibleComponent.GetDestructibleMesh");

	UDestructibleComponent_GetDestructibleMesh_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C39130
//		Name   -> Function Engine.DestructibleComponent.ApplyRadiusDamage
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     HurtOrigin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              DamageRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ImpulseStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bFullDamage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UDestructibleComponent::ApplyRadiusDamage(float BaseDamage, const struct FVector& HurtOrigin, float DamageRadius, float ImpulseStrength, bool bFullDamage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DestructibleComponent.ApplyRadiusDamage");

	UDestructibleComponent_ApplyRadiusDamage_Params params {};
	params.BaseDamage = BaseDamage;
	params.HurtOrigin = HurtOrigin;
	params.DamageRadius = DamageRadius;
	params.ImpulseStrength = ImpulseStrength;
	params.bFullDamage = bFullDamage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C38580
//		Name   -> Function Engine.DestructibleComponent.ApplyDamage
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		struct FVector                                     ImpulseDir                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		float                                              ImpulseStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UDestructibleComponent::ApplyDamage(float DamageAmount, const struct FVector& HitLocation, const struct FVector& ImpulseDir, float ImpulseStrength)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.DestructibleComponent.ApplyDamage");

	UDestructibleComponent_ApplyDamage_Params params {};
	params.DamageAmount = DamageAmount;
	params.HitLocation = HitLocation;
	params.ImpulseDir = ImpulseDir;
	params.ImpulseStrength = ImpulseStrength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UDestructibleComponent::AfterRead()
{
	USkinnedMeshComponent::AfterRead();

}

void UDestructibleComponent::BeforeDelete()
{
	USkinnedMeshComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C456D0
//		Name   -> Function Engine.PoseableMeshComponent.SetBoneTransformByName
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  InTransform                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPoseableMeshComponent::SetBoneTransformByName(const struct FName& BoneName, const struct FTransform& InTransform, TEnumAsByte<Engine_EBoneSpaces> BoneSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneTransformByName");

	UPoseableMeshComponent_SetBoneTransformByName_Params params {};
	params.BoneName = BoneName;
	params.InTransform = InTransform;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C45400
//		Name   -> Function Engine.PoseableMeshComponent.SetBoneScaleByName
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     InScale3D                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPoseableMeshComponent::SetBoneScaleByName(const struct FName& BoneName, const struct FVector& InScale3D, TEnumAsByte<Engine_EBoneSpaces> BoneSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneScaleByName");

	UPoseableMeshComponent_SetBoneScaleByName_Params params {};
	params.BoneName = BoneName;
	params.InScale3D = InScale3D;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C452F0
//		Name   -> Function Engine.PoseableMeshComponent.SetBoneRotationByName
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    InRotation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPoseableMeshComponent::SetBoneRotationByName(const struct FName& BoneName, const struct FRotator& InRotation, TEnumAsByte<Engine_EBoneSpaces> BoneSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneRotationByName");

	UPoseableMeshComponent_SetBoneRotationByName_Params params {};
	params.BoneName = BoneName;
	params.InRotation = InRotation;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C451E0
//		Name   -> Function Engine.PoseableMeshComponent.SetBoneLocationByName
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     InLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPoseableMeshComponent::SetBoneLocationByName(const struct FName& BoneName, const struct FVector& InLocation, TEnumAsByte<Engine_EBoneSpaces> BoneSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneLocationByName");

	UPoseableMeshComponent_SetBoneLocationByName_Params params {};
	params.BoneName = BoneName;
	params.InLocation = InLocation;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C439A0
//		Name   -> Function Engine.PoseableMeshComponent.ResetBoneTransformByName
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPoseableMeshComponent::ResetBoneTransformByName(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.ResetBoneTransformByName");

	UPoseableMeshComponent_ResetBoneTransformByName_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3CEF0
//		Name   -> Function Engine.PoseableMeshComponent.GetBoneTransformByName
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UPoseableMeshComponent::GetBoneTransformByName(const struct FName& BoneName, TEnumAsByte<Engine_EBoneSpaces> BoneSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneTransformByName");

	UPoseableMeshComponent_GetBoneTransformByName_Params params {};
	params.BoneName = BoneName;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3CE20
//		Name   -> Function Engine.PoseableMeshComponent.GetBoneScaleByName
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPoseableMeshComponent::GetBoneScaleByName(const struct FName& BoneName, TEnumAsByte<Engine_EBoneSpaces> BoneSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneScaleByName");

	UPoseableMeshComponent_GetBoneScaleByName_Params params {};
	params.BoneName = BoneName;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3CD50
//		Name   -> Function Engine.PoseableMeshComponent.GetBoneRotationByName
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FRotator                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FRotator UPoseableMeshComponent::GetBoneRotationByName(const struct FName& BoneName, TEnumAsByte<Engine_EBoneSpaces> BoneSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneRotationByName");

	UPoseableMeshComponent_GetBoneRotationByName_Params params {};
	params.BoneName = BoneName;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3CC80
//		Name   -> Function Engine.PoseableMeshComponent.GetBoneLocationByName
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UPoseableMeshComponent::GetBoneLocationByName(const struct FName& BoneName, TEnumAsByte<Engine_EBoneSpaces> BoneSpace)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneLocationByName");

	UPoseableMeshComponent_GetBoneLocationByName_Params params {};
	params.BoneName = BoneName;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UPoseableMeshComponent::AfterRead()
{
	USkinnedMeshComponent::AfterRead();

}

void UPoseableMeshComponent::BeforeDelete()
{
	USkinnedMeshComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D270
//		Name   -> Function Engine.PoseableSkeletalMeshComponent.SwitchPoseMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EPoseableAnimMode>              NewMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPoseableSkeletalMeshComponent::SwitchPoseMode(TEnumAsByte<Engine_EPoseableAnimMode> NewMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableSkeletalMeshComponent.SwitchPoseMode");

	UPoseableSkeletalMeshComponent_SwitchPoseMode_Params params {};
	params.NewMode = NewMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C45840
//		Name   -> Function Engine.PoseableSkeletalMeshComponent.SetBoneTransformByName
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  InTransform                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bApplyRefPose                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPoseableSkeletalMeshComponent::SetBoneTransformByName(const struct FName& BoneName, const struct FTransform& InTransform, TEnumAsByte<Engine_EBoneSpaces> BoneSpace, bool bApplyRefPose)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableSkeletalMeshComponent.SetBoneTransformByName");

	UPoseableSkeletalMeshComponent_SetBoneTransformByName_Params params {};
	params.BoneName = BoneName;
	params.InTransform = InTransform;
	params.BoneSpace = BoneSpace;
	params.bApplyRefPose = bApplyRefPose;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C45510
//		Name   -> Function Engine.PoseableSkeletalMeshComponent.SetBoneTransformByIndex
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		int                                                BoneIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FTransform                                  InTransform                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bApplyRefPose                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UPoseableSkeletalMeshComponent::SetBoneTransformByIndex(int BoneIndex, const struct FTransform& InTransform, TEnumAsByte<Engine_EBoneSpaces> BoneSpace, bool bApplyRefPose)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableSkeletalMeshComponent.SetBoneTransformByIndex");

	UPoseableSkeletalMeshComponent_SetBoneTransformByIndex_Params params {};
	params.BoneIndex = BoneIndex;
	params.InTransform = InTransform;
	params.BoneSpace = BoneSpace;
	params.bApplyRefPose = bApplyRefPose;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3CFF0
//		Name   -> Function Engine.PoseableSkeletalMeshComponent.GetBoneTransformByName
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_EBoneSpaces>                    BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bApplyRefPose                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)
struct FTransform UPoseableSkeletalMeshComponent::GetBoneTransformByName(const struct FName& BoneName, TEnumAsByte<Engine_EBoneSpaces> BoneSpace, bool bApplyRefPose)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PoseableSkeletalMeshComponent.GetBoneTransformByName");

	UPoseableSkeletalMeshComponent_GetBoneTransformByName_Params params {};
	params.BoneName = BoneName;
	params.BoneSpace = BoneSpace;
	params.bApplyRefPose = bApplyRefPose;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UPoseableSkeletalMeshComponent::AfterRead()
{
	USkeletalMeshComponent::AfterRead();

}

void UPoseableSkeletalMeshComponent::BeforeDelete()
{
	USkeletalMeshComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D530
//		Name   -> Function Engine.FlatWaterMeshComponent.UpdateBoundary
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      BoundaryActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UFlatWaterMeshComponent::UpdateBoundary(class AActor* BoundaryActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FlatWaterMeshComponent.UpdateBoundary");

	UFlatWaterMeshComponent_UpdateBoundary_Params params {};
	params.BoundaryActor = BoundaryActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4AC30
//		Name   -> Function Engine.FlatWaterMeshComponent.SetTexture
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                MaterialIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UTexture*                                    Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UFlatWaterMeshComponent::SetTexture(int MaterialIndex, const struct FName& Name, class UTexture* Texture)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FlatWaterMeshComponent.SetTexture");

	UFlatWaterMeshComponent_SetTexture_Params params {};
	params.MaterialIndex = MaterialIndex;
	params.Name = Name;
	params.Texture = Texture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49750
//		Name   -> Function Engine.FlatWaterMeshComponent.SetScalarValue
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                MaterialIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FName                                       Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UFlatWaterMeshComponent::SetScalarValue(int MaterialIndex, const struct FName& Name, float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FlatWaterMeshComponent.SetScalarValue");

	UFlatWaterMeshComponent_SetScalarValue_Params params {};
	params.MaterialIndex = MaterialIndex;
	params.Name = Name;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C42150
//		Name   -> Function Engine.FlatWaterMeshComponent.PlaceDrop
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   Position                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Size                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Height                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UFlatWaterMeshComponent::PlaceDrop(const struct FVector2D& Position, float Size, float Height)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FlatWaterMeshComponent.PlaceDrop");

	UFlatWaterMeshComponent_PlaceDrop_Params params {};
	params.Position = Position;
	params.Size = Size;
	params.Height = Height;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3B160
//		Name   -> Function Engine.FlatWaterMeshComponent.CreateBoundaryMap
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      BoundaryActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ZNearDistance                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ZFarDistance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                TextureSize                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UFlatWaterMeshComponent::CreateBoundaryMap(class AActor* BoundaryActor, float ZNearDistance, float ZFarDistance, int TextureSize)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.FlatWaterMeshComponent.CreateBoundaryMap");

	UFlatWaterMeshComponent_CreateBoundaryMap_Params params {};
	params.BoundaryActor = BoundaryActor;
	params.ZNearDistance = ZNearDistance;
	params.ZFarDistance = ZFarDistance;
	params.TextureSize = TextureSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UFlatWaterMeshComponent::AfterRead()
{
	UStaticMeshComponent::AfterRead();

	READ_PTR_FULL(ClippingHull, UStaticMesh);
	READ_PTR_FULL(Texture, UTexture);
	READ_PTR_FULL(NormalTexture, UTexture);
	READ_PTR_FULL(WaterMaskTexture, UTextureRenderTarget2D);
}

void UFlatWaterMeshComponent::BeforeDelete()
{
	UStaticMeshComponent::BeforeDelete();

	DELE_PTR_FULL(ClippingHull);
	DELE_PTR_FULL(Texture);
	DELE_PTR_FULL(NormalTexture);
	DELE_PTR_FULL(WaterMaskTexture);
}

// Function:
//		Offset -> 0x02C45010
//		Name   -> Function Engine.InstancedCoverageMeshComponent.SetBaseMeshComponent
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UStaticMeshComponent*                        BaseMeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UInstancedCoverageMeshComponent::SetBaseMeshComponent(class UStaticMeshComponent* BaseMeshComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedCoverageMeshComponent.SetBaseMeshComponent");

	UInstancedCoverageMeshComponent_SetBaseMeshComponent_Params params {};
	params.BaseMeshComponent = BaseMeshComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C39630
//		Name   -> Function Engine.InstancedCoverageMeshComponent.BaseMeshComponent
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UStaticMeshComponent*                        ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UStaticMeshComponent* UInstancedCoverageMeshComponent::BaseMeshComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.InstancedCoverageMeshComponent.BaseMeshComponent");

	UInstancedCoverageMeshComponent_BaseMeshComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UInstancedCoverageMeshComponent::AfterRead()
{
	UStaticMeshComponent::AfterRead();

	READ_PTR_FULL(CoveredMesh, UStaticMesh);
}

void UInstancedCoverageMeshComponent::BeforeDelete()
{
	UStaticMeshComponent::BeforeDelete();

	DELE_PTR_FULL(CoveredMesh);
}

void UMergedStaticMeshComponent::AfterRead()
{
	UStaticMeshComponent::AfterRead();

}

void UMergedStaticMeshComponent::BeforeDelete()
{
	UStaticMeshComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C37CE0
//		Name   -> Function Engine.MobileInstancedStaticMeshComponent.AddInstance
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UMobileInstancedStaticMeshComponent::AddInstance(const struct FTransform& Transform)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MobileInstancedStaticMeshComponent.AddInstance");

	UMobileInstancedStaticMeshComponent_AddInstance_Params params {};
	params.Transform = Transform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UMobileInstancedStaticMeshComponent::AfterRead()
{
	UStaticMeshComponent::AfterRead();

	READ_PTR_FULL(PhysicsSerializer, UPhysicsSerializer);
}

void UMobileInstancedStaticMeshComponent::BeforeDelete()
{
	UStaticMeshComponent::BeforeDelete();

	DELE_PTR_FULL(PhysicsSerializer);
}

// Function:
//		Offset -> 0x02C4D860
//		Name   -> Function Engine.SplineMeshComponent.UpdateMesh
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USplineMeshComponent::UpdateMesh()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.UpdateMesh");

	USplineMeshComponent_UpdateMesh_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4A6A0
//		Name   -> Function Engine.SplineMeshComponent.SetStartTangent
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     StartTangent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetStartTangent(const struct FVector& StartTangent, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartTangent");

	USplineMeshComponent_SetStartTangent_Params params {};
	params.StartTangent = StartTangent;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4A5E0
//		Name   -> Function Engine.SplineMeshComponent.SetStartScale
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   StartScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetStartScale(const struct FVector2D& StartScale, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartScale");

	USplineMeshComponent_SetStartScale_Params params {};
	params.StartScale = StartScale;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4A510
//		Name   -> Function Engine.SplineMeshComponent.SetStartRoll
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              StartRoll                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetStartRoll(float StartRoll, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartRoll");

	USplineMeshComponent_SetStartRoll_Params params {};
	params.StartRoll = StartRoll;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4A430
//		Name   -> Function Engine.SplineMeshComponent.SetStartPosition
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     StartPos                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetStartPosition(const struct FVector& StartPos, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartPosition");

	USplineMeshComponent_SetStartPosition_Params params {};
	params.StartPos = StartPos;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4A370
//		Name   -> Function Engine.SplineMeshComponent.SetStartOffset
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   StartOffset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetStartOffset(const struct FVector2D& StartOffset, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartOffset");

	USplineMeshComponent_SetStartOffset_Params params {};
	params.StartOffset = StartOffset;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4A0B0
//		Name   -> Function Engine.SplineMeshComponent.SetStartAndEnd
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     StartPos                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     StartTangent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     EndPos                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     EndTangent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetStartAndEnd(const struct FVector& StartPos, const struct FVector& StartTangent, const struct FVector& EndPos, const struct FVector& EndTangent, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartAndEnd");

	USplineMeshComponent_SetStartAndEnd_Params params {};
	params.StartPos = StartPos;
	params.StartTangent = StartTangent;
	params.EndPos = EndPos;
	params.EndTangent = EndTangent;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49DC0
//		Name   -> Function Engine.SplineMeshComponent.SetSplineUpDir
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     InSplineUpDir                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetSplineUpDir(const struct FVector& InSplineUpDir, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetSplineUpDir");

	USplineMeshComponent_SetSplineUpDir_Params params {};
	params.InSplineUpDir = InSplineUpDir;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47AF0
//		Name   -> Function Engine.SplineMeshComponent.SetForwardAxis
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ESplineMeshAxis>                InForwardAxis                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetForwardAxis(TEnumAsByte<Engine_ESplineMeshAxis> InForwardAxis, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetForwardAxis");

	USplineMeshComponent_SetForwardAxis_Params params {};
	params.InForwardAxis = InForwardAxis;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C472A0
//		Name   -> Function Engine.SplineMeshComponent.SetEndTangent
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     EndTangent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetEndTangent(const struct FVector& EndTangent, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndTangent");

	USplineMeshComponent_SetEndTangent_Params params {};
	params.EndTangent = EndTangent;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C471E0
//		Name   -> Function Engine.SplineMeshComponent.SetEndScale
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   EndScale                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetEndScale(const struct FVector2D& EndScale, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndScale");

	USplineMeshComponent_SetEndScale_Params params {};
	params.EndScale = EndScale;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47110
//		Name   -> Function Engine.SplineMeshComponent.SetEndRoll
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              EndRoll                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetEndRoll(float EndRoll, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndRoll");

	USplineMeshComponent_SetEndRoll_Params params {};
	params.EndRoll = EndRoll;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47030
//		Name   -> Function Engine.SplineMeshComponent.SetEndPosition
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     EndPos                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetEndPosition(const struct FVector& EndPos, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndPosition");

	USplineMeshComponent_SetEndPosition_Params params {};
	params.EndPos = EndPos;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C46F70
//		Name   -> Function Engine.SplineMeshComponent.SetEndOffset
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   EndOffset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetEndOffset(const struct FVector2D& EndOffset, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndOffset");

	USplineMeshComponent_SetEndOffset_Params params {};
	params.EndOffset = EndOffset;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C45BA0
//		Name   -> Function Engine.SplineMeshComponent.SetBoundaryMin
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InBoundaryMin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetBoundaryMin(float InBoundaryMin, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetBoundaryMin");

	USplineMeshComponent_SetBoundaryMin_Params params {};
	params.InBoundaryMin = InBoundaryMin;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C45AD0
//		Name   -> Function Engine.SplineMeshComponent.SetBoundaryMax
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InBoundaryMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bUpdateMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void USplineMeshComponent::SetBoundaryMax(float InBoundaryMax, bool bUpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetBoundaryMax");

	USplineMeshComponent_SetBoundaryMax_Params params {};
	params.InBoundaryMax = InBoundaryMax;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3FE70
//		Name   -> Function Engine.SplineMeshComponent.GetStartTangent
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineMeshComponent::GetStartTangent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartTangent");

	USplineMeshComponent_GetStartTangent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FE30
//		Name   -> Function Engine.SplineMeshComponent.GetStartScale
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D USplineMeshComponent::GetStartScale()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartScale");

	USplineMeshComponent_GetStartScale_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FE00
//		Name   -> Function Engine.SplineMeshComponent.GetStartRoll
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USplineMeshComponent::GetStartRoll()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartRoll");

	USplineMeshComponent_GetStartRoll_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FDC0
//		Name   -> Function Engine.SplineMeshComponent.GetStartPosition
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineMeshComponent::GetStartPosition()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartPosition");

	USplineMeshComponent_GetStartPosition_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FD80
//		Name   -> Function Engine.SplineMeshComponent.GetStartOffset
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D USplineMeshComponent::GetStartOffset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartOffset");

	USplineMeshComponent_GetStartOffset_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3FC80
//		Name   -> Function Engine.SplineMeshComponent.GetSplineUpDir
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineMeshComponent::GetSplineUpDir()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetSplineUpDir");

	USplineMeshComponent_GetSplineUpDir_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DA90
//		Name   -> Function Engine.SplineMeshComponent.GetForwardAxis
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_ESplineMeshAxis>                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
TEnumAsByte<Engine_ESplineMeshAxis> USplineMeshComponent::GetForwardAxis()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetForwardAxis");

	USplineMeshComponent_GetForwardAxis_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DA50
//		Name   -> Function Engine.SplineMeshComponent.GetEndTangent
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineMeshComponent::GetEndTangent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndTangent");

	USplineMeshComponent_GetEndTangent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3DA10
//		Name   -> Function Engine.SplineMeshComponent.GetEndScale
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D USplineMeshComponent::GetEndScale()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndScale");

	USplineMeshComponent_GetEndScale_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D9E0
//		Name   -> Function Engine.SplineMeshComponent.GetEndRoll
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USplineMeshComponent::GetEndRoll()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndRoll");

	USplineMeshComponent_GetEndRoll_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D9A0
//		Name   -> Function Engine.SplineMeshComponent.GetEndPosition
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector USplineMeshComponent::GetEndPosition()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndPosition");

	USplineMeshComponent_GetEndPosition_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D960
//		Name   -> Function Engine.SplineMeshComponent.GetEndOffset
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D USplineMeshComponent::GetEndOffset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndOffset");

	USplineMeshComponent_GetEndOffset_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D170
//		Name   -> Function Engine.SplineMeshComponent.GetBoundaryMin
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USplineMeshComponent::GetBoundaryMin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetBoundaryMin");

	USplineMeshComponent_GetBoundaryMin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3D140
//		Name   -> Function Engine.SplineMeshComponent.GetBoundaryMax
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float USplineMeshComponent::GetBoundaryMax()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetBoundaryMax");

	USplineMeshComponent_GetBoundaryMax_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void USplineMeshComponent::AfterRead()
{
	UStaticMeshComponent::AfterRead();

	READ_PTR_FULL(BodySetup, UBodySetup);
}

void USplineMeshComponent::BeforeDelete()
{
	UStaticMeshComponent::BeforeDelete();

	DELE_PTR_FULL(BodySetup);
}

void UModelComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

	READ_PTR_FULL(ModelBodySetup, UBodySetup);
}

void UModelComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

	DELE_PTR_FULL(ModelBodySetup);
}

void UNavLinkRenderingComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

}

void UNavLinkRenderingComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

}

void UNavMeshRenderingComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

}

void UNavMeshRenderingComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

}

void UNavTestRenderingComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

}

void UNavTestRenderingComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

}

void UDialogueWave::AfterRead()
{
	UObject::AfterRead();

}

void UDialogueWave::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UDistribution::AfterRead()
{
	UObject::AfterRead();

}

void UDistribution::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UDistributionFloat::AfterRead()
{
	UDistribution::AfterRead();

}

void UDistributionFloat::BeforeDelete()
{
	UDistribution::BeforeDelete();

}

void UDistributionFloatConstant::AfterRead()
{
	UDistributionFloat::AfterRead();

}

void UDistributionFloatConstant::BeforeDelete()
{
	UDistributionFloat::BeforeDelete();

}

void UDistributionFloatParameterBase::AfterRead()
{
	UDistributionFloatConstant::AfterRead();

}

void UDistributionFloatParameterBase::BeforeDelete()
{
	UDistributionFloatConstant::BeforeDelete();

}

void UDistributionFloatParticleParameter::AfterRead()
{
	UDistributionFloatParameterBase::AfterRead();

}

void UDistributionFloatParticleParameter::BeforeDelete()
{
	UDistributionFloatParameterBase::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4B7C0
//		Name   -> Function Engine.TextRenderComponent.SetYScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTextRenderComponent::SetYScale(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetYScale");

	UTextRenderComponent_SetYScale_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4B740
//		Name   -> Function Engine.TextRenderComponent.SetXScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTextRenderComponent::SetXScale(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetXScale");

	UTextRenderComponent_SetXScale_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4B6C0
//		Name   -> Function Engine.TextRenderComponent.SetWorldSize
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTextRenderComponent::SetWorldSize(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetWorldSize");

	UTextRenderComponent_SetWorldSize_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4ABC0
//		Name   -> Function Engine.TextRenderComponent.SetTextRenderColor
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FColor                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UTextRenderComponent::SetTextRenderColor(const struct FColor& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetTextRenderColor");

	UTextRenderComponent_SetTextRenderColor_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4AB40
//		Name   -> Function Engine.TextRenderComponent.SetTextMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTextRenderComponent::SetTextMaterial(class UMaterialInterface* Material)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetTextMaterial");

	UTextRenderComponent_SetTextMaterial_Params params {};
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4AAA0
//		Name   -> Function Engine.TextRenderComponent.SetText
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     Value                                                      (Parm, ZeroConstructor, HasGetValueTypeHash)
void UTextRenderComponent::SetText(const struct FString& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetText");

	UTextRenderComponent_SetText_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47F40
//		Name   -> Function Engine.TextRenderComponent.SetHorizSpacingAdjust
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTextRenderComponent::SetHorizSpacingAdjust(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetHorizSpacingAdjust");

	UTextRenderComponent_SetHorizSpacingAdjust_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C47FC0
//		Name   -> Function Engine.TextRenderComponent.SetHorizontalAlignment
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EHorizTextAligment>             Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTextRenderComponent::SetHorizontalAlignment(TEnumAsByte<Engine_EHorizTextAligment> Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetHorizontalAlignment");

	UTextRenderComponent_SetHorizontalAlignment_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C479F0
//		Name   -> Function Engine.TextRenderComponent.SetFont
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UFont*                                       Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTextRenderComponent::SetFont(class UFont* Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetFont");

	UTextRenderComponent_SetFont_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41070
//		Name   -> Function Engine.TextRenderComponent.K2_SetText
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FText                                       Value                                                      (ConstParm, Parm, OutParm, ReferenceParm)
void UTextRenderComponent::K2_SetText(const struct FText& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.K2_SetText");

	UTextRenderComponent_K2_SetText_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40340
//		Name   -> Function Engine.TextRenderComponent.GetTextWorldSize
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UTextRenderComponent::GetTextWorldSize()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.GetTextWorldSize");

	UTextRenderComponent_GetTextWorldSize_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40300
//		Name   -> Function Engine.TextRenderComponent.GetTextLocalSize
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UTextRenderComponent::GetTextLocalSize()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.GetTextLocalSize");

	UTextRenderComponent_GetTextLocalSize_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UTextRenderComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

	READ_PTR_FULL(TextMaterial, UMaterialInterface);
	READ_PTR_FULL(Font, UFont);
}

void UTextRenderComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

	DELE_PTR_FULL(TextMaterial);
	DELE_PTR_FULL(Font);
}

// Function:
//		Offset -> 0x02C48380
//		Name   -> Function Engine.VectorFieldComponent.SetIntensity
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewIntensity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UVectorFieldComponent::SetIntensity(float NewIntensity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.VectorFieldComponent.SetIntensity");

	UVectorFieldComponent_SetIntensity_Params params {};
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UVectorFieldComponent::AfterRead()
{
	UPrimitiveComponent::AfterRead();

	READ_PTR_FULL(VectorField, UVectorField);
}

void UVectorFieldComponent::BeforeDelete()
{
	UPrimitiveComponent::BeforeDelete();

	DELE_PTR_FULL(VectorField);
}

// Function:
//		Offset -> 0x02C43850
//		Name   -> Function Engine.RadialForceComponent.RemoveObjectTypeToAffect
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EObjectTypeQuery>               ObjectType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void URadialForceComponent::RemoveObjectTypeToAffect(TEnumAsByte<Engine_EObjectTypeQuery> ObjectType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.RemoveObjectTypeToAffect");

	URadialForceComponent_RemoveObjectTypeToAffect_Params params {};
	params.ObjectType = ObjectType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3BF80
//		Name   -> Function Engine.RadialForceComponent.FireImpulse
//		Flags  -> (Native, Public, BlueprintCallable)
void URadialForceComponent::FireImpulse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.FireImpulse");

	URadialForceComponent_FireImpulse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C37F70
//		Name   -> Function Engine.RadialForceComponent.AddObjectTypeToAffect
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_EObjectTypeQuery>               ObjectType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void URadialForceComponent::AddObjectTypeToAffect(TEnumAsByte<Engine_EObjectTypeQuery> ObjectType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.AddObjectTypeToAffect");

	URadialForceComponent_AddObjectTypeToAffect_Params params {};
	params.ObjectType = ObjectType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void URadialForceComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void URadialForceComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D880
//		Name   -> Function Engine.ReflectionCaptureComponent.UpdateReflectionCapture
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UReflectionCaptureComponent::UpdateReflectionCapture()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ReflectionCaptureComponent.UpdateReflectionCapture");

	UReflectionCaptureComponent_UpdateReflectionCapture_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4D510
//		Name   -> Function Engine.ReflectionCaptureComponent.UpdateAllReflectionCaptures
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UReflectionCaptureComponent::UpdateAllReflectionCaptures()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ReflectionCaptureComponent.UpdateAllReflectionCaptures");

	UReflectionCaptureComponent_UpdateAllReflectionCaptures_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4AEB0
//		Name   -> Function Engine.ReflectionCaptureComponent.SetTint
//		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FLinearColor                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UReflectionCaptureComponent::SetTint(const struct FLinearColor& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ReflectionCaptureComponent.SetTint");

	UReflectionCaptureComponent_SetTint_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49860
//		Name   -> Function Engine.ReflectionCaptureComponent.SetShadowBrightness
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UReflectionCaptureComponent::SetShadowBrightness(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ReflectionCaptureComponent.SetShadowBrightness");

	UReflectionCaptureComponent_SetShadowBrightness_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48500
//		Name   -> Function Engine.ReflectionCaptureComponent.SetLPVOcclusionBrightness
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UReflectionCaptureComponent::SetLPVOcclusionBrightness(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ReflectionCaptureComponent.SetLPVOcclusionBrightness");

	UReflectionCaptureComponent_SetLPVOcclusionBrightness_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C45D50
//		Name   -> Function Engine.ReflectionCaptureComponent.SetBrightness
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UReflectionCaptureComponent::SetBrightness(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.ReflectionCaptureComponent.SetBrightness");

	UReflectionCaptureComponent_SetBrightness_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UReflectionCaptureComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UReflectionCaptureComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

void UBoxReflectionCaptureComponent::AfterRead()
{
	UReflectionCaptureComponent::AfterRead();

	READ_PTR_FULL(PreviewInfluenceBox, UBoxComponent);
	READ_PTR_FULL(PreviewCaptureBox, UBoxComponent);
}

void UBoxReflectionCaptureComponent::BeforeDelete()
{
	UReflectionCaptureComponent::BeforeDelete();

	DELE_PTR_FULL(PreviewInfluenceBox);
	DELE_PTR_FULL(PreviewCaptureBox);
}

void UPlaneReflectionCaptureComponent::AfterRead()
{
	UReflectionCaptureComponent::AfterRead();

	READ_PTR_FULL(PreviewInfluenceRadius, UDrawSphereComponent);
	READ_PTR_FULL(PreviewCaptureBox, UBoxComponent);
}

void UPlaneReflectionCaptureComponent::BeforeDelete()
{
	UReflectionCaptureComponent::BeforeDelete();

	DELE_PTR_FULL(PreviewInfluenceRadius);
	DELE_PTR_FULL(PreviewCaptureBox);
}

void USphereReflectionCaptureComponent::AfterRead()
{
	UReflectionCaptureComponent::AfterRead();

	READ_PTR_FULL(PreviewInfluenceRadius, UDrawSphereComponent);
}

void USphereReflectionCaptureComponent::BeforeDelete()
{
	UReflectionCaptureComponent::BeforeDelete();

	DELE_PTR_FULL(PreviewInfluenceRadius);
}

// Function:
//		Offset -> 0x02C40B70
//		Name   -> Function Engine.SceneCaptureComponent.HideComponent
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		class UPrimitiveComponent*                         InComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USceneCaptureComponent::HideComponent(class UPrimitiveComponent* InComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.HideComponent");

	USceneCaptureComponent_HideComponent_Params params {};
	params.InComponent = InComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40AF0
//		Name   -> Function Engine.SceneCaptureComponent.HideActorComponents
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USceneCaptureComponent::HideActorComponents(class AActor* InActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.HideActorComponents");

	USceneCaptureComponent_HideActorComponents_Params params {};
	params.InActor = InActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void USceneCaptureComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void USceneCaptureComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D5B0
//		Name   -> Function Engine.SceneCaptureComponent2D.UpdateContent
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
void USceneCaptureComponent2D::UpdateContent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent2D.UpdateContent");

	USceneCaptureComponent2D_UpdateContent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C381E0
//		Name   -> Function Engine.SceneCaptureComponent2D.AddOrUpdateBlendable
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InWeight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void USceneCaptureComponent2D::AddOrUpdateBlendable(float InWeight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent2D.AddOrUpdateBlendable");

	USceneCaptureComponent2D_AddOrUpdateBlendable_Params params {};
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void USceneCaptureComponent2D::AfterRead()
{
	USceneCaptureComponent::AfterRead();

	READ_PTR_FULL(TextureTarget, UTextureRenderTarget2D);
}

void USceneCaptureComponent2D::BeforeDelete()
{
	USceneCaptureComponent::BeforeDelete();

	DELE_PTR_FULL(TextureTarget);
}

// Function:
//		Offset -> 0x02C4D5D0
//		Name   -> Function Engine.SceneCaptureComponentCube.UpdateContent
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
void USceneCaptureComponentCube::UpdateContent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponentCube.UpdateContent");

	USceneCaptureComponentCube_UpdateContent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void USceneCaptureComponentCube::AfterRead()
{
	USceneCaptureComponent::AfterRead();

	READ_PTR_FULL(TextureTarget, UTextureRenderTargetCube);
}

void USceneCaptureComponentCube::BeforeDelete()
{
	USceneCaptureComponent::BeforeDelete();

	DELE_PTR_FULL(TextureTarget);
}

void USpringArmComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void USpringArmComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

void UWaterEmissionVolumeComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UWaterEmissionVolumeComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

void UWindDirectionalSourceComponent::AfterRead()
{
	USceneComponent::AfterRead();

}

void UWindDirectionalSourceComponent::BeforeDelete()
{
	USceneComponent::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D070
//		Name   -> Function Engine.TimelineComponent.Stop
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
void UTimelineComponent::Stop()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Stop");

	UTimelineComponent_Stop_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4ADB0
//		Name   -> Function Engine.TimelineComponent.SetTimelineLengthMode
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ETimelineLengthMode>            NewLengthMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTimelineComponent::SetTimelineLengthMode(TEnumAsByte<Engine_ETimelineLengthMode> NewLengthMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetTimelineLengthMode");

	UTimelineComponent_SetTimelineLengthMode_Params params {};
	params.NewLengthMode = NewLengthMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4AD30
//		Name   -> Function Engine.TimelineComponent.SetTimelineLength
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewLength                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTimelineComponent::SetTimelineLength(float NewLength)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetTimelineLength");

	UTimelineComponent_SetTimelineLength_Params params {};
	params.NewLength = NewLength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C491C0
//		Name   -> Function Engine.TimelineComponent.SetPlayRate
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewRate                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTimelineComponent::SetPlayRate(float NewRate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetPlayRate");

	UTimelineComponent_SetPlayRate_Params params {};
	params.NewRate = NewRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49240
//		Name   -> Function Engine.TimelineComponent.SetPlaybackPosition
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewPosition                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bFireEvents                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bFireUpdate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
void UTimelineComponent::SetPlaybackPosition(float NewPosition, bool bFireEvents, bool bFireUpdate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetPlaybackPosition");

	UTimelineComponent_SetPlaybackPosition_Params params {};
	params.NewPosition = NewPosition;
	params.bFireEvents = bFireEvents;
	params.bFireUpdate = bFireUpdate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48E30
//		Name   -> Function Engine.TimelineComponent.SetNewTime
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UTimelineComponent::SetNewTime(float NewTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetNewTime");

	UTimelineComponent_SetNewTime_Params params {};
	params.NewTime = NewTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48920
//		Name   -> Function Engine.TimelineComponent.SetLooping
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bNewLooping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UTimelineComponent::SetLooping(bool bNewLooping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetLooping");

	UTimelineComponent_SetLooping_Params params {};
	params.bNewLooping = bNewLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C43A40
//		Name   -> Function Engine.TimelineComponent.ReverseFromEnd
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
void UTimelineComponent::ReverseFromEnd()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.ReverseFromEnd");

	UTimelineComponent_ReverseFromEnd_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C43A20
//		Name   -> Function Engine.TimelineComponent.Reverse
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
void UTimelineComponent::Reverse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Reverse");

	UTimelineComponent_Reverse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C428C0
//		Name   -> Function Engine.TimelineComponent.PlayFromStart
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
void UTimelineComponent::PlayFromStart()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.PlayFromStart");

	UTimelineComponent_PlayFromStart_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C422D0
//		Name   -> Function Engine.TimelineComponent.Play
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
void UTimelineComponent::Play()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Play");

	UTimelineComponent_Play_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C41E70
//		Name   -> Function Engine.TimelineComponent.OnRep_Timeline
//		Flags  -> (Final, Native, Public)
void UTimelineComponent::OnRep_Timeline()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.OnRep_Timeline");

	UTimelineComponent_OnRep_Timeline_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C40EA0
//		Name   -> Function Engine.TimelineComponent.IsReversing
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UTimelineComponent::IsReversing()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsReversing");

	UTimelineComponent_IsReversing_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40DB0
//		Name   -> Function Engine.TimelineComponent.IsPlaying
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UTimelineComponent::IsPlaying()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsPlaying");

	UTimelineComponent_IsPlaying_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40D50
//		Name   -> Function Engine.TimelineComponent.IsLooping
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UTimelineComponent::IsLooping()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsLooping");

	UTimelineComponent_IsLooping_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C40380
//		Name   -> Function Engine.TimelineComponent.GetTimelineLength
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UTimelineComponent::GetTimelineLength()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetTimelineLength");

	UTimelineComponent_GetTimelineLength_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F1E0
//		Name   -> Function Engine.TimelineComponent.GetPlayRate
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UTimelineComponent::GetPlayRate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetPlayRate");

	UTimelineComponent_GetPlayRate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3F210
//		Name   -> Function Engine.TimelineComponent.GetPlaybackPosition
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UTimelineComponent::GetPlaybackPosition()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetPlaybackPosition");

	UTimelineComponent_GetPlaybackPosition_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UTimelineComponent::AfterRead()
{
	UActorComponent::AfterRead();

}

void UTimelineComponent::BeforeDelete()
{
	UActorComponent::BeforeDelete();

}

void UAggregatableInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UAggregatableInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UAnimComposite::AfterRead()
{
	UAnimCompositeBase::AfterRead();

}

void UAnimComposite::BeforeDelete()
{
	UAnimCompositeBase::BeforeDelete();

}

void UAnimSequence::AfterRead()
{
	UAnimSequenceBase::AfterRead();

	READ_PTR_FULL(RefPoseSeq, UAnimSequence);
}

void UAnimSequence::BeforeDelete()
{
	UAnimSequenceBase::BeforeDelete();

	DELE_PTR_FULL(RefPoseSeq);
}

void UBlendSpaceBase::AfterRead()
{
	UAnimationAsset::AfterRead();

}

void UBlendSpaceBase::BeforeDelete()
{
	UAnimationAsset::BeforeDelete();

}

void UBlendSpace::AfterRead()
{
	UBlendSpaceBase::AfterRead();

}

void UBlendSpace::BeforeDelete()
{
	UBlendSpaceBase::BeforeDelete();

}

void UAimOffsetBlendSpace::AfterRead()
{
	UBlendSpace::AfterRead();

}

void UAimOffsetBlendSpace::BeforeDelete()
{
	UBlendSpace::BeforeDelete();

}

void UBlendSpace1D::AfterRead()
{
	UBlendSpaceBase::AfterRead();

}

void UBlendSpace1D::BeforeDelete()
{
	UBlendSpaceBase::BeforeDelete();

}

void UAimOffsetBlendSpace1D::AfterRead()
{
	UBlendSpace1D::AfterRead();

}

void UAimOffsetBlendSpace1D::BeforeDelete()
{
	UBlendSpace1D::BeforeDelete();

}

void UAnimCompress::AfterRead()
{
	UObject::AfterRead();

}

void UAnimCompress::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UAnimCompress_Automatic::AfterRead()
{
	UAnimCompress::AfterRead();

}

void UAnimCompress_Automatic::BeforeDelete()
{
	UAnimCompress::BeforeDelete();

}

void UAnimCompress_BitwiseCompressOnly::AfterRead()
{
	UAnimCompress::AfterRead();

}

void UAnimCompress_BitwiseCompressOnly::BeforeDelete()
{
	UAnimCompress::BeforeDelete();

}

void UAnimCompress_LeastDestructive::AfterRead()
{
	UAnimCompress::AfterRead();

}

void UAnimCompress_LeastDestructive::BeforeDelete()
{
	UAnimCompress::BeforeDelete();

}

void UAnimCompress_RemoveEverySecondKey::AfterRead()
{
	UAnimCompress::AfterRead();

}

void UAnimCompress_RemoveEverySecondKey::BeforeDelete()
{
	UAnimCompress::BeforeDelete();

}

void UAnimCompress_RemoveLinearKeys::AfterRead()
{
	UAnimCompress::AfterRead();

}

void UAnimCompress_RemoveLinearKeys::BeforeDelete()
{
	UAnimCompress::BeforeDelete();

}

void UAnimCompress_PerTrackCompression::AfterRead()
{
	UAnimCompress_RemoveLinearKeys::AfterRead();

}

void UAnimCompress_PerTrackCompression::BeforeDelete()
{
	UAnimCompress_RemoveLinearKeys::BeforeDelete();

}

void UAnimCompress_RemoveTrivialKeys::AfterRead()
{
	UAnimCompress::AfterRead();

}

void UAnimCompress_RemoveTrivialKeys::BeforeDelete()
{
	UAnimCompress::BeforeDelete();

}

// Function:
//		Offset -> 0x02C4D090
//		Name   -> Function Engine.AnimSingleNodeInstance.StopAnim
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UAnimSingleNodeInstance::StopAnim()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.StopAnim");

	UAnimSingleNodeInstance_StopAnim_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C4B190
//		Name   -> Function Engine.AnimSingleNodeInstance.SetVertexAnimation
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UVertexAnimation*                            NewVertexAnim                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bIsLooping                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimSingleNodeInstance::SetVertexAnimation(class UVertexAnimation* NewVertexAnim, bool bIsLooping, float InPlayRate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetVertexAnimation");

	UAnimSingleNodeInstance_SetVertexAnimation_Params params {};
	params.NewVertexAnim = NewVertexAnim;
	params.bIsLooping = bIsLooping;
	params.InPlayRate = InPlayRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C496C0
//		Name   -> Function Engine.AnimSingleNodeInstance.SetReverse
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bInReverse                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAnimSingleNodeInstance::SetReverse(bool bInReverse)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetReverse");

	UAnimSingleNodeInstance_SetReverse_Params params {};
	params.bInReverse = bInReverse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C493E0
//		Name   -> Function Engine.AnimSingleNodeInstance.SetPosition
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InPosition                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bFireNotifies                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAnimSingleNodeInstance::SetPosition(float InPosition, bool bFireNotifies)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPosition");

	UAnimSingleNodeInstance_SetPosition_Params params {};
	params.InPosition = InPosition;
	params.bFireNotifies = bFireNotifies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49140
//		Name   -> Function Engine.AnimSingleNodeInstance.SetPlayRate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimSingleNodeInstance::SetPlayRate(float InPlayRate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPlayRate");

	UAnimSingleNodeInstance_SetPlayRate_Params params {};
	params.InPlayRate = InPlayRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C49350
//		Name   -> Function Engine.AnimSingleNodeInstance.SetPlaying
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bIsPlaying                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAnimSingleNodeInstance::SetPlaying(bool bIsPlaying)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPlaying");

	UAnimSingleNodeInstance_SetPlaying_Params params {};
	params.bIsPlaying = bIsPlaying;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C48890
//		Name   -> Function Engine.AnimSingleNodeInstance.SetLooping
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bIsLooping                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UAnimSingleNodeInstance::SetLooping(bool bIsLooping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetLooping");

	UAnimSingleNodeInstance_SetLooping_Params params {};
	params.bIsLooping = bIsLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C45150
//		Name   -> Function Engine.AnimSingleNodeInstance.SetBlendSpaceInput
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     InBlendInput                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
void UAnimSingleNodeInstance::SetBlendSpaceInput(const struct FVector& InBlendInput)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetBlendSpaceInput");

	UAnimSingleNodeInstance_SetBlendSpaceInput_Params params {};
	params.InBlendInput = InBlendInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C44BE0
//		Name   -> Function Engine.AnimSingleNodeInstance.SetAnimationAsset
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimationAsset*                             NewAsset                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bIsLooping                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimSingleNodeInstance::SetAnimationAsset(class UAnimationAsset* NewAsset, bool bIsLooping, float InPlayRate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetAnimationAsset");

	UAnimSingleNodeInstance_SetAnimationAsset_Params params {};
	params.NewAsset = NewAsset;
	params.bIsLooping = bIsLooping;
	params.InPlayRate = InPlayRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C422F0
//		Name   -> Function Engine.AnimSingleNodeInstance.PlayAnim
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bIsLooping                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              InStartPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UAnimSingleNodeInstance::PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.PlayAnim");

	UAnimSingleNodeInstance_PlayAnim_Params params {};
	params.bIsLooping = bIsLooping;
	params.InPlayRate = InPlayRate;
	params.InStartPosition = InStartPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02C3E960
//		Name   -> Function Engine.AnimSingleNodeInstance.GetLength
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UAnimSingleNodeInstance::GetLength()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.GetLength");

	UAnimSingleNodeInstance_GetLength_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UAnimSingleNodeInstance::AfterRead()
{
	UAnimInstance::AfterRead();

	READ_PTR_FULL(CurrentAsset, UAnimationAsset);
	READ_PTR_FULL(CurrentVertexAnim, UVertexAnimation);
}

void UAnimSingleNodeInstance::BeforeDelete()
{
	UAnimInstance::BeforeDelete();

	DELE_PTR_FULL(CurrentAsset);
	DELE_PTR_FULL(CurrentVertexAnim);
}

void UAnimMetaData::AfterRead()
{
	UObject::AfterRead();

}

void UAnimMetaData::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UAnimNotify_ResetDynamics::AfterRead()
{
	UAnimNotify::AfterRead();

}

void UAnimNotify_ResetDynamics::BeforeDelete()
{
	UAnimNotify::BeforeDelete();

}

void UAnimNotifyCondition::AfterRead()
{
	UObject::AfterRead();

}

void UAnimNotifyCondition::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.AnimNotifyState_Trail.OverridePSTemplate
//		Flags  -> (Event, Public, BlueprintEvent, Const)
// Parameters:
//		class USkeletalMeshComponent*                      MeshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UAnimSequenceBase*                           Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UParticleSystem*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UParticleSystem* UAnimNotifyState_Trail::OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState_Trail.OverridePSTemplate");

	UAnimNotifyState_Trail_OverridePSTemplate_Params params {};
	params.MeshComp = MeshComp;
	params.Animation = Animation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UAnimNotifyState_Trail::AfterRead()
{
	UAnimNotifyState::AfterRead();

	READ_PTR_FULL(PSTemplate, UParticleSystem);
}

void UAnimNotifyState_Trail::BeforeDelete()
{
	UAnimNotifyState::BeforeDelete();

	DELE_PTR_FULL(PSTemplate);
}

void UAnimSet::AfterRead()
{
	UObject::AfterRead();

}

void UAnimSet::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UAssetImportData::AfterRead()
{
	UObject::AfterRead();

}

void UAssetImportData::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UAssetUserData::AfterRead()
{
	UObject::AfterRead();

}

void UAssetUserData::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UAutomationTestSettings::AfterRead()
{
	UObject::AfterRead();

}

void UAutomationTestSettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UAutomationTestUserSettings::AfterRead()
{
	UObject::AfterRead();

}

void UAutomationTestUserSettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UDistributionFloatUniformCurve::AfterRead()
{
	UDistributionFloat::AfterRead();

}

void UDistributionFloatUniformCurve::BeforeDelete()
{
	UDistributionFloat::BeforeDelete();

}

void UDistributionVector::AfterRead()
{
	UDistribution::AfterRead();

}

void UDistributionVector::BeforeDelete()
{
	UDistribution::BeforeDelete();

}

void UDistributionVectorConstant::AfterRead()
{
	UDistributionVector::AfterRead();

}

void UDistributionVectorConstant::BeforeDelete()
{
	UDistributionVector::BeforeDelete();

}

void UDistributionVectorParameterBase::AfterRead()
{
	UDistributionVectorConstant::AfterRead();

}

void UDistributionVectorParameterBase::BeforeDelete()
{
	UDistributionVectorConstant::BeforeDelete();

}

void UDistributionVectorParticleParameter::AfterRead()
{
	UDistributionVectorParameterBase::AfterRead();

}

void UDistributionVectorParticleParameter::BeforeDelete()
{
	UDistributionVectorParameterBase::BeforeDelete();

}

void UDistributionVectorConstantCurve::AfterRead()
{
	UDistributionVector::AfterRead();

}

void UDistributionVectorConstantCurve::BeforeDelete()
{
	UDistributionVector::BeforeDelete();

}

void UDistributionVectorUniform::AfterRead()
{
	UDistributionVector::AfterRead();

}

void UDistributionVectorUniform::BeforeDelete()
{
	UDistributionVector::BeforeDelete();

}

void UDistributionVectorUniformCurve::AfterRead()
{
	UDistributionVector::AfterRead();

}

void UDistributionVectorUniformCurve::BeforeDelete()
{
	UDistributionVector::BeforeDelete();

}

void UDPICustomScalingRule::AfterRead()
{
	UObject::AfterRead();

}

void UDPICustomScalingRule::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UDynamicBlueprintBinding::AfterRead()
{
	UObject::AfterRead();

}

void UDynamicBlueprintBinding::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02C43600
//		Name   -> Function Engine.AvoidanceManager.RegisterMovementComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMovementComponent*                          MovementComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              AvoidanceWeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UAvoidanceManager::RegisterMovementComponent(class UMovementComponent* MovementComp, float AvoidanceWeight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.RegisterMovementComponent");

	UAvoidanceManager_RegisterMovementComponent_Params params {};
	params.MovementComp = MovementComp;
	params.AvoidanceWeight = AvoidanceWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3EFB0
//		Name   -> Function Engine.AvoidanceManager.GetObjectCount
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UAvoidanceManager::GetObjectCount()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetObjectCount");

	UAvoidanceManager_GetObjectCount_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3ECD0
//		Name   -> Function Engine.AvoidanceManager.GetNewAvoidanceUID
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UAvoidanceManager::GetNewAvoidanceUID()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetNewAvoidanceUID");

	UAvoidanceManager_GetNewAvoidanceUID_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3CB30
//		Name   -> Function Engine.AvoidanceManager.GetAvoidanceVelocityIgnoringUID
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FNavAvoidanceData                           AvoidanceData                                              (ConstParm, Parm, OutParm, ReferenceParm)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                IgnoreThisUID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UAvoidanceManager::GetAvoidanceVelocityIgnoringUID(const struct FNavAvoidanceData& AvoidanceData, float DeltaTime, int IgnoreThisUID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetAvoidanceVelocityIgnoringUID");

	UAvoidanceManager_GetAvoidanceVelocityIgnoringUID_Params params {};
	params.AvoidanceData = AvoidanceData;
	params.DeltaTime = DeltaTime;
	params.IgnoreThisUID = IgnoreThisUID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3CA90
//		Name   -> Function Engine.AvoidanceManager.GetAvoidanceVelocityForComponent
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UMovementComponent*                          MovementComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UAvoidanceManager::GetAvoidanceVelocityForComponent(class UMovementComponent* MovementComp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetAvoidanceVelocityForComponent");

	UAvoidanceManager_GetAvoidanceVelocityForComponent_Params params {};
	params.MovementComp = MovementComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02C3C990
//		Name   -> Function Engine.AvoidanceManager.GetAvoidanceVelocity
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FNavAvoidanceData                           AvoidanceData                                              (ConstParm, Parm, OutParm, ReferenceParm)
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UAvoidanceManager::GetAvoidanceVelocity(const struct FNavAvoidanceData& AvoidanceData, float DeltaTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetAvoidanceVelocity");

	UAvoidanceManager_GetAvoidanceVelocity_Params params {};
	params.AvoidanceData = AvoidanceData;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UAvoidanceManager::AfterRead()
{
	UObject::AfterRead();

}

void UAvoidanceManager::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UBodySetup::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(PhysMaterial, UPhysicalMaterial);
}

void UBodySetup::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(PhysMaterial);
}

void UBodySetup2D::AfterRead()
{
	UBodySetup::AfterRead();

}

void UBodySetup2D::BeforeDelete()
{
	UBodySetup::BeforeDelete();

}

void UBoneMaskFilter::AfterRead()
{
	UObject::AfterRead();

}

void UBoneMaskFilter::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UBookMark::AfterRead()
{
	UObject::AfterRead();

}

void UBookMark::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UMaterialExpressionCustom::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionCustom::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UParticleModuleAccelerationBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleAccelerationBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleAcceleration::AfterRead()
{
	UParticleModuleAccelerationBase::AfterRead();

}

void UParticleModuleAcceleration::BeforeDelete()
{
	UParticleModuleAccelerationBase::BeforeDelete();

}

void UParticleModuleAttractorBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleAttractorBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleAttractorLine::AfterRead()
{
	UParticleModuleAttractorBase::AfterRead();

}

void UParticleModuleAttractorLine::BeforeDelete()
{
	UParticleModuleAttractorBase::BeforeDelete();

}

void UParticleModuleAttractorParticle::AfterRead()
{
	UParticleModuleAttractorBase::AfterRead();

}

void UParticleModuleAttractorParticle::BeforeDelete()
{
	UParticleModuleAttractorBase::BeforeDelete();

}

void UParticleModuleAttractorPoint::AfterRead()
{
	UParticleModuleAttractorBase::AfterRead();

}

void UParticleModuleAttractorPoint::BeforeDelete()
{
	UParticleModuleAttractorBase::BeforeDelete();

}

void UParticleModuleAttractorPointGravity::AfterRead()
{
	UParticleModuleAttractorBase::AfterRead();

	READ_PTR_FULL(Strength, UDistributionFloat);
}

void UParticleModuleAttractorPointGravity::BeforeDelete()
{
	UParticleModuleAttractorBase::BeforeDelete();

	DELE_PTR_FULL(Strength);
}

void UParticleModuleBeamBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleBeamBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleBeamModifier::AfterRead()
{
	UParticleModuleBeamBase::AfterRead();

}

void UParticleModuleBeamModifier::BeforeDelete()
{
	UParticleModuleBeamBase::BeforeDelete();

}

void UParticleModuleLocationPrimitiveBase::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleLocationPrimitiveBase::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UParticleModuleLocationComputeShaderOutput::AfterRead()
{
	UParticleModuleLocationPrimitiveBase::AfterRead();

	READ_PTR_FULL(PositionData, UParticleComputeShaderData);
}

void UParticleModuleLocationComputeShaderOutput::BeforeDelete()
{
	UParticleModuleLocationPrimitiveBase::BeforeDelete();

	DELE_PTR_FULL(PositionData);
}

void UParticleModuleLocationPrimitiveCylinder::AfterRead()
{
	UParticleModuleLocationPrimitiveBase::AfterRead();

}

void UParticleModuleLocationPrimitiveCylinder::BeforeDelete()
{
	UParticleModuleLocationPrimitiveBase::BeforeDelete();

}

void UParticleModuleLocationPrimitiveCylinder_Seeded::AfterRead()
{
	UParticleModuleLocationPrimitiveCylinder::AfterRead();

}

void UParticleModuleLocationPrimitiveCylinder_Seeded::BeforeDelete()
{
	UParticleModuleLocationPrimitiveCylinder::BeforeDelete();

}

void UParticleModuleLocationPrimitiveSphere::AfterRead()
{
	UParticleModuleLocationPrimitiveBase::AfterRead();

}

void UParticleModuleLocationPrimitiveSphere::BeforeDelete()
{
	UParticleModuleLocationPrimitiveBase::BeforeDelete();

}

void UParticleModuleLocationPrimitiveSphere_Seeded::AfterRead()
{
	UParticleModuleLocationPrimitiveSphere::AfterRead();

}

void UParticleModuleLocationPrimitiveSphere_Seeded::BeforeDelete()
{
	UParticleModuleLocationPrimitiveSphere::BeforeDelete();

}

void UParticleModuleLocationPrimitiveSphereGPU::AfterRead()
{
	UParticleModuleLocationPrimitiveBase::AfterRead();

}

void UParticleModuleLocationPrimitiveSphereGPU::BeforeDelete()
{
	UParticleModuleLocationPrimitiveBase::BeforeDelete();

}

void UParticleModuleLocationVelocityComputeShaderOutput::AfterRead()
{
	UParticleModuleLocationPrimitiveBase::AfterRead();

	READ_PTR_FULL(PositionData, UParticleComputeShaderData);
}

void UParticleModuleLocationVelocityComputeShaderOutput::BeforeDelete()
{
	UParticleModuleLocationPrimitiveBase::BeforeDelete();

	DELE_PTR_FULL(PositionData);
}

void UBookMark2D::AfterRead()
{
	UObject::AfterRead();

}

void UBookMark2D::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UBreakpoint::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(Node, UEdGraphNode);
}

void UBreakpoint::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(Node);
}

void UBrushBuilder::AfterRead()
{
	UObject::AfterRead();

}

void UBrushBuilder::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UMaterialExpressionComment::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionComment::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionComponentMask::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionComponentMask::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionConstant::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionConstant::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionConstant2Vector::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionConstant2Vector::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionConstant3Vector::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionConstant3Vector::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UTouchInterface::AfterRead()
{
	UObject::AfterRead();

}

void UTouchInterface::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UUserDefinedEnum::AfterRead()
{
	UEnum::AfterRead();

}

void UUserDefinedEnum::BeforeDelete()
{
	UEnum::BeforeDelete();

}

void UAnimDataEntryStruct::AfterRead()
{
	UUserDefinedStruct::AfterRead();

}

void UAnimDataEntryStruct::BeforeDelete()
{
	UUserDefinedStruct::BeforeDelete();

}

void UVectorField::AfterRead()
{
	UObject::AfterRead();

}

void UVectorField::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UVectorFieldAnimated::AfterRead()
{
	UVectorField::AfterRead();

	READ_PTR_FULL(Texture, UTexture2D);
	READ_PTR_FULL(NoiseField, UVectorFieldStatic);
}

void UVectorFieldAnimated::BeforeDelete()
{
	UVectorField::BeforeDelete();

	DELE_PTR_FULL(Texture);
	DELE_PTR_FULL(NoiseField);
}

void UVectorFieldStatic::AfterRead()
{
	UVectorField::AfterRead();

}

void UVectorFieldStatic::BeforeDelete()
{
	UVectorField::BeforeDelete();

}

void UVertexAnimBase::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(BaseSkelMesh, USkeletalMesh);
}

void UVertexAnimBase::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(BaseSkelMesh);
}

void UMorphTarget::AfterRead()
{
	UVertexAnimBase::AfterRead();

}

void UMorphTarget::BeforeDelete()
{
	UVertexAnimBase::BeforeDelete();

}

void UVertexAnimation::AfterRead()
{
	UVertexAnimBase::AfterRead();

}

void UVertexAnimation::BeforeDelete()
{
	UVertexAnimBase::BeforeDelete();

}

void UVisualLoggerAutomationTests::AfterRead()
{
	UObject::AfterRead();

}

void UVisualLoggerAutomationTests::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UButtonStyleAsset::AfterRead()
{
	UObject::AfterRead();

}

void UButtonStyleAsset::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UCameraAnim::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(CameraInterpGroup, UInterpGroup);
}

void UCameraAnim::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(CameraInterpGroup);
}

// Function:
//		Offset -> 0x02D754A0
//		Name   -> Function Engine.CameraAnimInst.Stop
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCameraAnimInst::Stop(bool bImmediate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.Stop");

	UCameraAnimInst_Stop_Params params {};
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71DA0
//		Name   -> Function Engine.CameraAnimInst.SetScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewDuration                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCameraAnimInst::SetScale(float NewDuration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.SetScale");

	UCameraAnimInst_SetScale_Params params {};
	params.NewDuration = NewDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71490
//		Name   -> Function Engine.CameraAnimInst.SetDuration
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewDuration                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCameraAnimInst::SetDuration(float NewDuration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.SetDuration");

	UCameraAnimInst_SetDuration_Params params {};
	params.NewDuration = NewDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UCameraAnimInst::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(CamAnim, UCameraAnim);
	READ_PTR_FULL(InterpGroupInst, UInterpGroupInst);
	READ_PTR_FULL(MoveTrack, UInterpTrackMove);
	READ_PTR_FULL(MoveInst, UInterpTrackInstMove);
	READ_PTR_FULL(BlendInCurve, UCurveFloat);
}

void UCameraAnimInst::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(CamAnim);
	DELE_PTR_FULL(InterpGroupInst);
	DELE_PTR_FULL(MoveTrack);
	DELE_PTR_FULL(MoveInst);
	DELE_PTR_FULL(BlendInCurve);
}

void UCameraModifier_CameraShake::AfterRead()
{
	UCameraModifier::AfterRead();

}

void UCameraModifier_CameraShake::BeforeDelete()
{
	UCameraModifier::BeforeDelete();

}

// Function:
//		Offset -> 0x02D61E30
//		Name   -> Function Engine.Canvas.K2_TextSize
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UFont*                                       RenderFont                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     RenderText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FVector2D                                   Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UCanvas::K2_TextSize(class UFont* RenderFont, const struct FString& RenderText, const struct FVector2D& Scale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_TextSize");

	UCanvas_K2_TextSize_Params params {};
	params.RenderFont = RenderFont;
	params.RenderText = RenderText;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D61D40
//		Name   -> Function Engine.Canvas.K2_StrLen
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UFont*                                       RenderFont                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     RenderText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector2D UCanvas::K2_StrLen(class UFont* RenderFont, const struct FString& RenderText)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_StrLen");

	UCanvas_K2_StrLen_Params params {};
	params.RenderFont = RenderFont;
	params.RenderText = RenderText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D619C0
//		Name   -> Function Engine.Canvas.K2_Project
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     WorldLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UCanvas::K2_Project(const struct FVector& WorldLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_Project");

	UCanvas_K2_Project_Params params {};
	params.WorldLocation = WorldLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02D60B80
//		Name   -> Function Engine.Canvas.K2_DrawTriangle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UTexture*                                    RenderTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FCanvasUVTri>                        Triangles                                                  (Parm, ZeroConstructor)
void UCanvas::K2_DrawTriangle(class UTexture* RenderTexture, TArray<struct FCanvasUVTri> Triangles)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawTriangle");

	UCanvas_K2_DrawTriangle_Params params {};
	params.RenderTexture = RenderTexture;
	params.Triangles = Triangles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D60900
//		Name   -> Function Engine.Canvas.K2_DrawTexture
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UTexture*                                    RenderTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ScreenSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   CoordinatePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   CoordinateSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		TEnumAsByte<Engine_EBlendMode>                     BlendMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   PivotPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCanvas::K2_DrawTexture(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, TEnumAsByte<Engine_EBlendMode> BlendMode, float Rotation, const struct FVector2D& PivotPoint)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawTexture");

	UCanvas_K2_DrawTexture_Params params {};
	params.RenderTexture = RenderTexture;
	params.ScreenPosition = ScreenPosition;
	params.ScreenSize = ScreenSize;
	params.CoordinatePosition = CoordinatePosition;
	params.CoordinateSize = CoordinateSize;
	params.RenderColor = RenderColor;
	params.BlendMode = BlendMode;
	params.Rotation = Rotation;
	params.PivotPoint = PivotPoint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D605B0
//		Name   -> Function Engine.Canvas.K2_DrawText
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UFont*                                       RenderFont                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     RenderText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Kerning                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ShadowColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ShadowOffset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bCentreX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bCentreY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               bOutlined                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                OutlineColor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCanvas::K2_DrawText(class UFont* RenderFont, const struct FString& RenderText, const struct FVector2D& ScreenPosition, const struct FLinearColor& RenderColor, float Kerning, const struct FLinearColor& ShadowColor, const struct FVector2D& ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, const struct FLinearColor& OutlineColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawText");

	UCanvas_K2_DrawText_Params params {};
	params.RenderFont = RenderFont;
	params.RenderText = RenderText;
	params.ScreenPosition = ScreenPosition;
	params.RenderColor = RenderColor;
	params.Kerning = Kerning;
	params.ShadowColor = ShadowColor;
	params.ShadowOffset = ShadowOffset;
	params.bCentreX = bCentreX;
	params.bCentreY = bCentreY;
	params.bOutlined = bOutlined;
	params.OutlineColor = OutlineColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D60420
//		Name   -> Function Engine.Canvas.K2_DrawPolygon
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UTexture*                                    RenderTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		int                                                NumberOfSides                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCanvas::K2_DrawPolygon(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& Radius, int NumberOfSides, const struct FLinearColor& RenderColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawPolygon");

	UCanvas_K2_DrawPolygon_Params params {};
	params.RenderTexture = RenderTexture;
	params.ScreenPosition = ScreenPosition;
	params.Radius = Radius;
	params.NumberOfSides = NumberOfSides;
	params.RenderColor = RenderColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D602E0
//		Name   -> Function Engine.Canvas.K2_DrawMaterialTriangle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          RenderMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TArray<struct FCanvasUVTri>                        Triangles                                                  (Parm, ZeroConstructor)
void UCanvas::K2_DrawMaterialTriangle(class UMaterialInterface* RenderMaterial, TArray<struct FCanvasUVTri> Triangles)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawMaterialTriangle");

	UCanvas_K2_DrawMaterialTriangle_Params params {};
	params.RenderMaterial = RenderMaterial;
	params.Triangles = Triangles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D600C0
//		Name   -> Function Engine.Canvas.K2_DrawMaterial
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          RenderMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ScreenSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   CoordinatePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   CoordinateSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   PivotPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCanvas::K2_DrawMaterial(class UMaterialInterface* RenderMaterial, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, float Rotation, const struct FVector2D& PivotPoint)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawMaterial");

	UCanvas_K2_DrawMaterial_Params params {};
	params.RenderMaterial = RenderMaterial;
	params.ScreenPosition = ScreenPosition;
	params.ScreenSize = ScreenSize;
	params.CoordinatePosition = CoordinatePosition;
	params.CoordinateSize = CoordinateSize;
	params.Rotation = Rotation;
	params.PivotPoint = PivotPoint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5FF70
//		Name   -> Function Engine.Canvas.K2_DrawLine
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   ScreenPositionA                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ScreenPositionB                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCanvas::K2_DrawLine(const struct FVector2D& ScreenPositionA, const struct FVector2D& ScreenPositionB, float Thickness, const struct FLinearColor& RenderColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawLine");

	UCanvas_K2_DrawLine_Params params {};
	params.ScreenPositionA = ScreenPositionA;
	params.ScreenPositionB = ScreenPositionB;
	params.Thickness = Thickness;
	params.RenderColor = RenderColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5FE70
//		Name   -> Function Engine.Canvas.K2_DrawBox
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ScreenSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCanvas::K2_DrawBox(const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, float Thickness)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBox");

	UCanvas_K2_DrawBox_Params params {};
	params.ScreenPosition = ScreenPosition;
	params.ScreenSize = ScreenSize;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5FA30
//		Name   -> Function Engine.Canvas.K2_DrawBorder
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UTexture*                                    BorderTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UTexture*                                    BackgroundTexture                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UTexture*                                    LeftBorderTexture                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UTexture*                                    RightBorderTexture                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UTexture*                                    TopBorderTexture                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UTexture*                                    BottomBorderTexture                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   ScreenSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   CoordinatePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   CoordinateSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   BorderScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   BackgroundScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		float                                              Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector2D                                   PivotPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector2D                                   CornerSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCanvas::K2_DrawBorder(class UTexture* BorderTexture, class UTexture* BackgroundTexture, class UTexture* LeftBorderTexture, class UTexture* RightBorderTexture, class UTexture* TopBorderTexture, class UTexture* BottomBorderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, const struct FVector2D& BorderScale, const struct FVector2D& BackgroundScale, float Rotation, const struct FVector2D& PivotPoint, const struct FVector2D& CornerSize)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBorder");

	UCanvas_K2_DrawBorder_Params params {};
	params.BorderTexture = BorderTexture;
	params.BackgroundTexture = BackgroundTexture;
	params.LeftBorderTexture = LeftBorderTexture;
	params.RightBorderTexture = RightBorderTexture;
	params.TopBorderTexture = TopBorderTexture;
	params.BottomBorderTexture = BottomBorderTexture;
	params.ScreenPosition = ScreenPosition;
	params.ScreenSize = ScreenSize;
	params.CoordinatePosition = CoordinatePosition;
	params.CoordinateSize = CoordinateSize;
	params.RenderColor = RenderColor;
	params.BorderScale = BorderScale;
	params.BackgroundScale = BackgroundScale;
	params.Rotation = Rotation;
	params.PivotPoint = PivotPoint;
	params.CornerSize = CornerSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5F910
//		Name   -> Function Engine.Canvas.K2_Deproject
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     WorldOrigin                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FVector                                     WorldDirection                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCanvas::K2_Deproject(const struct FVector2D& ScreenPosition, struct FVector* WorldOrigin, struct FVector* WorldDirection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_Deproject");

	UCanvas_K2_Deproject_Params params {};
	params.ScreenPosition = ScreenPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (WorldOrigin != nullptr)
		*WorldOrigin = params.WorldOrigin;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;

}


// Function:
//		Offset -> 0x02D56FA0
//		Name   -> Function Engine.Canvas.DrawTextures
//		Flags  -> (Native, Public, HasOutParms)
// Parameters:
//		TArray<struct FTextureRenderData>                  RenderDatas                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
void UCanvas::DrawTextures(TArray<struct FTextureRenderData> RenderDatas)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Canvas.DrawTextures");

	UCanvas_DrawTextures_Params params {};
	params.RenderDatas = RenderDatas;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UCanvas::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(DefaultTexture, UTexture2D);
	READ_PTR_FULL(GradientTexture0, UTexture2D);
	READ_PTR_FULL(ReporterGraph, UReporterGraph);
}

void UCanvas::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(DefaultTexture);
	DELE_PTR_FULL(GradientTexture0);
	DELE_PTR_FULL(ReporterGraph);
}

void UChannel::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(Connection, UNetConnection);
}

void UChannel::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(Connection);
}

void UActorChannel::AfterRead()
{
	UChannel::AfterRead();

	READ_PTR_FULL(Actor, AActor);
}

void UActorChannel::BeforeDelete()
{
	UChannel::BeforeDelete();

	DELE_PTR_FULL(Actor);
}

void UControlChannel::AfterRead()
{
	UChannel::AfterRead();

}

void UControlChannel::BeforeDelete()
{
	UChannel::BeforeDelete();

}

void UVoiceChannel::AfterRead()
{
	UChannel::AfterRead();

}

void UVoiceChannel::BeforeDelete()
{
	UChannel::BeforeDelete();

}

// Function:
//		Offset -> 0x02D78860
//		Name   -> Function Engine.CheatManager.WidgetReflector
//		Flags  -> (Exec, Native, Public)
void UCheatManager::WidgetReflector()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.WidgetReflector");

	UCheatManager_WidgetReflector_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D78840
//		Name   -> Function Engine.CheatManager.Walk
//		Flags  -> (Exec, Native, Public)
void UCheatManager::Walk()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Walk");

	UCheatManager_Walk_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D78820
//		Name   -> Function Engine.CheatManager.ViewSelf
//		Flags  -> (Exec, Native, Public)
void UCheatManager::ViewSelf()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewSelf");

	UCheatManager_ViewSelf_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D78770
//		Name   -> Function Engine.CheatManager.ViewPlayer
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FString                                     S                                                          (Parm, ZeroConstructor, HasGetValueTypeHash)
void UCheatManager::ViewPlayer(const struct FString& S)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewPlayer");

	UCheatManager_ViewPlayer_Params params {};
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D786E0
//		Name   -> Function Engine.CheatManager.ViewClass
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		class UClass*                                      DesiredClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void UCheatManager::ViewClass(class UClass* DesiredClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewClass");

	UCheatManager_ViewClass_Params params {};
	params.DesiredClass = DesiredClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D78650
//		Name   -> Function Engine.CheatManager.ViewActor
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FName                                       ActorName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::ViewActor(const struct FName& ActorName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewActor");

	UCheatManager_ViewActor_Params params {};
	params.ActorName = ActorName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D77330
//		Name   -> Function Engine.CheatManager.ToggleDebugCamera
//		Flags  -> (Exec, Native, Public)
void UCheatManager::ToggleDebugCamera()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleDebugCamera");

	UCheatManager_ToggleDebugCamera_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D77310
//		Name   -> Function Engine.CheatManager.ToggleAILogging
//		Flags  -> (Exec, Native, Public)
void UCheatManager::ToggleAILogging()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleAILogging");

	UCheatManager_ToggleAILogging_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D76D70
//		Name   -> Function Engine.CheatManager.TextureAtlasVisualizer
//		Flags  -> (Exec, Native, Public)
void UCheatManager::TextureAtlasVisualizer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.TextureAtlasVisualizer");

	UCheatManager_TextureAtlasVisualizer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D76750
//		Name   -> Function Engine.CheatManager.TestCollisionDistance
//		Flags  -> (Exec, Native, Public)
void UCheatManager::TestCollisionDistance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.TestCollisionDistance");

	UCheatManager_TestCollisionDistance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D76730
//		Name   -> Function Engine.CheatManager.Teleport
//		Flags  -> (Exec, Native, Public)
void UCheatManager::Teleport()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Teleport");

	UCheatManager_Teleport_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D75F00
//		Name   -> Function Engine.CheatManager.Summon
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FString                                     ClassName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash)
void UCheatManager::Summon(const struct FString& ClassName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Summon");

	UCheatManager_Summon_Params params {};
	params.ClassName = ClassName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D755C0
//		Name   -> Function Engine.CheatManager.StreamLevelOut
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FName                                       PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::StreamLevelOut(const struct FName& PackageName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.StreamLevelOut");

	UCheatManager_StreamLevelOut_Params params {};
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D75530
//		Name   -> Function Engine.CheatManager.StreamLevelIn
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FName                                       PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::StreamLevelIn(const struct FName& PackageName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.StreamLevelIn");

	UCheatManager_StreamLevelIn_Params params {};
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D72A10
//		Name   -> Function Engine.CheatManager.Slomo
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		float                                              T                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::Slomo(float T)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Slomo");

	UCheatManager_Slomo_Params params {};
	params.T = T;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D726C0
//		Name   -> Function Engine.CheatManager.SetWorldOrigin
//		Flags  -> (Final, Exec, Native, Public)
void UCheatManager::SetWorldOrigin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SetWorldOrigin");

	UCheatManager_SetWorldOrigin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71920
//		Name   -> Function Engine.CheatManager.SetNavDrawDistance
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		float                                              DrawDistance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::SetNavDrawDistance(float DrawDistance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SetNavDrawDistance");

	UCheatManager_SetNavDrawDistance_Params params {};
	params.DrawDistance = DrawDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D71800
//		Name   -> Function Engine.CheatManager.SetMouseSensitivityToDefault
//		Flags  -> (Final, Exec, Native, Public)
void UCheatManager::SetMouseSensitivityToDefault()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SetMouseSensitivityToDefault");

	UCheatManager_SetMouseSensitivityToDefault_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D70CE0
//		Name   -> Function Engine.CheatManager.ServerToggleAILogging
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void UCheatManager::ServerToggleAILogging()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ServerToggleAILogging");

	UCheatManager_ServerToggleAILogging_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6E900
//		Name   -> Function Engine.CheatManager.RebuildNavigation
//		Flags  -> (Exec, Native, Public)
void UCheatManager::RebuildNavigation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.RebuildNavigation");

	UCheatManager_RebuildNavigation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6BCA0
//		Name   -> Function Engine.CheatManager.PlayersOnly
//		Flags  -> (Exec, Native, Public)
void UCheatManager::PlayersOnly()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.PlayersOnly");

	UCheatManager_PlayersOnly_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D6B630
//		Name   -> Function Engine.CheatManager.OnlyLoadLevel
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FName                                       PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::OnlyLoadLevel(const struct FName& PackageName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.OnlyLoadLevel");

	UCheatManager_OnlyLoadLevel_Params params {};
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D65C10
//		Name   -> Function Engine.CheatManager.LogLoc
//		Flags  -> (Exec, Native, Public)
void UCheatManager::LogLoc()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.LogLoc");

	UCheatManager_LogLoc_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5EB90
//		Name   -> Function Engine.CheatManager.InvertMouse
//		Flags  -> (Final, Exec, Native, Public)
void UCheatManager::InvertMouse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.InvertMouse");

	UCheatManager_InvertMouse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5CE20
//		Name   -> Function Engine.CheatManager.God
//		Flags  -> (Exec, Native, Public)
void UCheatManager::God()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.God");

	UCheatManager_God_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D5CE00
//		Name   -> Function Engine.CheatManager.Ghost
//		Flags  -> (Exec, Native, Public)
void UCheatManager::Ghost()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Ghost");

	UCheatManager_Ghost_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D59A40
//		Name   -> Function Engine.CheatManager.FreezeFrame
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::FreezeFrame(float Delay)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.FreezeFrame");

	UCheatManager_FreezeFrame_Params params {};
	params.Delay = Delay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D597A0
//		Name   -> Function Engine.CheatManager.FontAtlasVisualizer
//		Flags  -> (Exec, Native, Public)
void UCheatManager::FontAtlasVisualizer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.FontAtlasVisualizer");

	UCheatManager_FontAtlasVisualizer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D59780
//		Name   -> Function Engine.CheatManager.Fly
//		Flags  -> (Exec, Native, Public)
void UCheatManager::Fly()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Fly");

	UCheatManager_Fly_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D596F0
//		Name   -> Function Engine.CheatManager.FlushLog
//		Flags  -> (Exec, Native, Public)
void UCheatManager::FlushLog()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.FlushLog");

	UCheatManager_FlushLog_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D570A0
//		Name   -> Function Engine.CheatManager.DumpVoiceMutingState
//		Flags  -> (Exec, Native, Public)
void UCheatManager::DumpVoiceMutingState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpVoiceMutingState");

	UCheatManager_DumpVoiceMutingState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D57080
//		Name   -> Function Engine.CheatManager.DumpPartyState
//		Flags  -> (Exec, Native, Public)
void UCheatManager::DumpPartyState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpPartyState");

	UCheatManager_DumpPartyState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D57060
//		Name   -> Function Engine.CheatManager.DumpOnlineSessionState
//		Flags  -> (Exec, Native, Public)
void UCheatManager::DumpOnlineSessionState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpOnlineSessionState");

	UCheatManager_DumpOnlineSessionState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D54540
//		Name   -> Function Engine.CheatManager.DestroyTarget
//		Flags  -> (Exec, Native, Public)
void UCheatManager::DestroyTarget()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyTarget");

	UCheatManager_DestroyTarget_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D544B0
//		Name   -> Function Engine.CheatManager.DestroyPawns
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		class UClass*                                      aClass                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void UCheatManager::DestroyPawns(class UClass* aClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyPawns");

	UCheatManager_DestroyPawns_Params params {};
	params.aClass = aClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D54490
//		Name   -> Function Engine.CheatManager.DestroyAllPawnsExceptTarget
//		Flags  -> (Final, Exec, Native, Public)
void UCheatManager::DestroyAllPawnsExceptTarget()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyAllPawnsExceptTarget");

	UCheatManager_DestroyAllPawnsExceptTarget_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D54400
//		Name   -> Function Engine.CheatManager.DestroyAll
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		class UClass*                                      aClass                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
void UCheatManager::DestroyAll(class UClass* aClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyAll");

	UCheatManager_DestroyAll_Params params {};
	params.aClass = aClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D53DD0
//		Name   -> Function Engine.CheatManager.DebugCapsuleSweepSize
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::DebugCapsuleSweepSize(float HalfHeight, float Radius)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepSize");

	UCheatManager_DebugCapsuleSweepSize_Params params {};
	params.HalfHeight = HalfHeight;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D53DB0
//		Name   -> Function Engine.CheatManager.DebugCapsuleSweepPawn
//		Flags  -> (Exec, Native, Public)
void UCheatManager::DebugCapsuleSweepPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepPawn");

	UCheatManager_DebugCapsuleSweepPawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D53D20
//		Name   -> Function Engine.CheatManager.DebugCapsuleSweepComplex
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UCheatManager::DebugCapsuleSweepComplex(bool bTraceComplex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepComplex");

	UCheatManager_DebugCapsuleSweepComplex_Params params {};
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D53D00
//		Name   -> Function Engine.CheatManager.DebugCapsuleSweepClear
//		Flags  -> (Exec, Native, Public)
void UCheatManager::DebugCapsuleSweepClear()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepClear");

	UCheatManager_DebugCapsuleSweepClear_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D53C80
//		Name   -> Function Engine.CheatManager.DebugCapsuleSweepChannel
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		TEnumAsByte<Engine_ECollisionChannel>              Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::DebugCapsuleSweepChannel(TEnumAsByte<Engine_ECollisionChannel> Channel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepChannel");

	UCheatManager_DebugCapsuleSweepChannel_Params params {};
	params.Channel = Channel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D53C60
//		Name   -> Function Engine.CheatManager.DebugCapsuleSweepCapture
//		Flags  -> (Exec, Native, Public)
void UCheatManager::DebugCapsuleSweepCapture()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepCapture");

	UCheatManager_DebugCapsuleSweepCapture_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D53C40
//		Name   -> Function Engine.CheatManager.DebugCapsuleSweep
//		Flags  -> (Exec, Native, Public)
void UCheatManager::DebugCapsuleSweep()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweep");

	UCheatManager_DebugCapsuleSweep_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D53800
//		Name   -> Function Engine.CheatManager.DamageTarget
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::DamageTarget(float DamageAmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DamageTarget");

	UCheatManager_DamageTarget_Params params {};
	params.DamageAmount = DamageAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D4F610
//		Name   -> Function Engine.CheatManager.ChangeSize
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		float                                              F                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::ChangeSize(float F)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ChangeSize");

	UCheatManager_ChangeSize_Params params {};
	params.F = F;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D4B960
//		Name   -> Function Engine.CheatManager.BugItStringCreator
//		Flags  -> (Exec, Native, Public, HasOutParms, HasDefaults)
// Parameters:
//		struct FVector                                     ViewLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FRotator                                    ViewRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FString                                     GoString                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     LocString                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
void UCheatManager::BugItStringCreator(const struct FVector& ViewLocation, const struct FRotator& ViewRotation, struct FString* GoString, struct FString* LocString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugItStringCreator");

	UCheatManager_BugItStringCreator_Params params {};
	params.ViewLocation = ViewLocation;
	params.ViewRotation = ViewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (GoString != nullptr)
		*GoString = params.GoString;
	if (LocString != nullptr)
		*LocString = params.LocString;

}


// Function:
//		Offset -> 0x02D4B790
//		Name   -> Function Engine.CheatManager.BugItGo
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Roll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCheatManager::BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugItGo");

	UCheatManager_BugItGo_Params params {};
	params.X = X;
	params.Y = Y;
	params.Z = Z;
	params.Pitch = Pitch;
	params.Yaw = Yaw;
	params.Roll = Roll;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02D4B6E0
//		Name   -> Function Engine.CheatManager.BugIt
//		Flags  -> (Exec, Native, Public)
// Parameters:
//		struct FString                                     ScreenShotDescription                                      (Parm, ZeroConstructor, HasGetValueTypeHash)
void UCheatManager::BugIt(const struct FString& ScreenShotDescription)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugIt");

	UCheatManager_BugIt_Params params {};
	params.ScreenShotDescription = ScreenShotDescription;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UCheatManager::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(DebugCameraControllerRef, ADebugCameraController);
	READ_PTR_FULL(DebugCameraControllerClass, UClass);
}

void UCheatManager::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(DebugCameraControllerRef);
	DELE_PTR_FULL(DebugCameraControllerClass);
}

void UParticleModuleVelocityBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleVelocityBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleVelocity::AfterRead()
{
	UParticleModuleVelocityBase::AfterRead();

}

void UParticleModuleVelocity::BeforeDelete()
{
	UParticleModuleVelocityBase::BeforeDelete();

}

void UParticleModuleVelocity_Seeded::AfterRead()
{
	UParticleModuleVelocity::AfterRead();

}

void UParticleModuleVelocity_Seeded::BeforeDelete()
{
	UParticleModuleVelocity::BeforeDelete();

}

void UPlatformInterfaceBase::AfterRead()
{
	UObject::AfterRead();

}

void UPlatformInterfaceBase::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UCloudStorageBase::AfterRead()
{
	UPlatformInterfaceBase::AfterRead();

}

void UCloudStorageBase::BeforeDelete()
{
	UPlatformInterfaceBase::BeforeDelete();

}

void UInGameAdManager::AfterRead()
{
	UPlatformInterfaceBase::AfterRead();

}

void UInGameAdManager::BeforeDelete()
{
	UPlatformInterfaceBase::BeforeDelete();

}

void UMicroTransactionBase::AfterRead()
{
	UPlatformInterfaceBase::AfterRead();

}

void UMicroTransactionBase::BeforeDelete()
{
	UPlatformInterfaceBase::BeforeDelete();

}

// Function:
//		Offset -> 0x02EEE320
//		Name   -> Function Engine.TwitterIntegrationBase.TwitterRequest
//		Flags  -> (Native, Public, HasOutParms)
// Parameters:
//		struct FString                                     URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash)
//		TArray<struct FString>                             ParamKeysAndValues                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
//		TEnumAsByte<Engine_ETwitterRequestMethod>          RequestMethod                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                AccountIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UTwitterIntegrationBase::TwitterRequest(const struct FString& URL, TArray<struct FString> ParamKeysAndValues, TEnumAsByte<Engine_ETwitterRequestMethod> RequestMethod, int AccountIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.TwitterRequest");

	UTwitterIntegrationBase_TwitterRequest_Params params {};
	params.URL = URL;
	params.ParamKeysAndValues = ParamKeysAndValues;
	params.RequestMethod = RequestMethod;
	params.AccountIndex = AccountIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02EEE1B0
//		Name   -> Function Engine.TwitterIntegrationBase.ShowTweetUI
//		Flags  -> (Native, Public)
// Parameters:
//		struct FString                                     InitialMessage                                             (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Picture                                                    (Parm, ZeroConstructor, HasGetValueTypeHash)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UTwitterIntegrationBase::ShowTweetUI(const struct FString& InitialMessage, const struct FString& URL, const struct FString& Picture)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.ShowTweetUI");

	UTwitterIntegrationBase_ShowTweetUI_Params params {};
	params.InitialMessage = InitialMessage;
	params.URL = URL;
	params.Picture = Picture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02EEDFA0
//		Name   -> Function Engine.TwitterIntegrationBase.Init
//		Flags  -> (Native, Public)
void UTwitterIntegrationBase::Init()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.Init");

	UTwitterIntegrationBase_Init_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02EEDEA0
//		Name   -> Function Engine.TwitterIntegrationBase.GetNumAccounts
//		Flags  -> (Native, Public)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UTwitterIntegrationBase::GetNumAccounts()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.GetNumAccounts");

	UTwitterIntegrationBase_GetNumAccounts_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02EEDB40
//		Name   -> Function Engine.TwitterIntegrationBase.GetAccountName
//		Flags  -> (Native, Public)
// Parameters:
//		int                                                AccountIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UTwitterIntegrationBase::GetAccountName(int AccountIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.GetAccountName");

	UTwitterIntegrationBase_GetAccountName_Params params {};
	params.AccountIndex = AccountIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02EEDB10
//		Name   -> Function Engine.TwitterIntegrationBase.CanShowTweetUI
//		Flags  -> (Native, Public)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UTwitterIntegrationBase::CanShowTweetUI()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.CanShowTweetUI");

	UTwitterIntegrationBase_CanShowTweetUI_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02EEDAE0
//		Name   -> Function Engine.TwitterIntegrationBase.AuthorizeAccounts
//		Flags  -> (Native, Public)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UTwitterIntegrationBase::AuthorizeAccounts()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.AuthorizeAccounts");

	UTwitterIntegrationBase_AuthorizeAccounts_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UTwitterIntegrationBase::AfterRead()
{
	UPlatformInterfaceBase::AfterRead();

}

void UTwitterIntegrationBase::BeforeDelete()
{
	UPlatformInterfaceBase::BeforeDelete();

}

// Function:
//		Offset -> 0x02EEDED0
//		Name   -> Function Engine.PlatformInterfaceWebResponse.GetNumHeaders
//		Flags  -> (Native, Public)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UPlatformInterfaceWebResponse::GetNumHeaders()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetNumHeaders");

	UPlatformInterfaceWebResponse_GetNumHeaders_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02EEDDA0
//		Name   -> Function Engine.PlatformInterfaceWebResponse.GetHeaderValue
//		Flags  -> (Native, Public)
// Parameters:
//		struct FString                                     HeaderName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UPlatformInterfaceWebResponse::GetHeaderValue(const struct FString& HeaderName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetHeaderValue");

	UPlatformInterfaceWebResponse_GetHeaderValue_Params params {};
	params.HeaderName = HeaderName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02EEDC30
//		Name   -> Function Engine.PlatformInterfaceWebResponse.GetHeader
//		Flags  -> (Native, Public, HasOutParms)
// Parameters:
//		int                                                HeaderIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     Header                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
//		struct FString                                     Value                                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
void UPlatformInterfaceWebResponse::GetHeader(int HeaderIndex, struct FString* Header, struct FString* Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetHeader");

	UPlatformInterfaceWebResponse_GetHeader_Params params {};
	params.HeaderIndex = HeaderIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Header != nullptr)
		*Header = params.Header;
	if (Value != nullptr)
		*Value = params.Value;

}


void UPlatformInterfaceWebResponse::AfterRead()
{
	UObject::AfterRead();

}

void UPlatformInterfaceWebResponse::BeforeDelete()
{
	UObject::BeforeDelete();

}

void ULocalPlayer::AfterRead()
{
	UPlayer::AfterRead();

	READ_PTR_FULL(ViewportClient, UGameViewportClient);
	READ_PTR_FULL(PendingLevelPlayerControllerClass, UClass);
}

void ULocalPlayer::BeforeDelete()
{
	UPlayer::BeforeDelete();

	DELE_PTR_FULL(ViewportClient);
	DELE_PTR_FULL(PendingLevelPlayerControllerClass);
}

void UChildConnection::AfterRead()
{
	UNetConnection::AfterRead();

	READ_PTR_FULL(Parent, UNetConnection);
}

void UChildConnection::BeforeDelete()
{
	UNetConnection::BeforeDelete();

	DELE_PTR_FULL(Parent);
}

void UDemoNetConnection::AfterRead()
{
	UNetConnection::AfterRead();

}

void UDemoNetConnection::BeforeDelete()
{
	UNetConnection::BeforeDelete();

}

void UPolys::AfterRead()
{
	UObject::AfterRead();

}

void UPolys::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UReporterBase::AfterRead()
{
	UObject::AfterRead();

}

void UReporterBase::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UReporterGraph::AfterRead()
{
	UReporterBase::AfterRead();

}

void UReporterGraph::BeforeDelete()
{
	UReporterBase::BeforeDelete();

}

void UReverbEffect::AfterRead()
{
	UObject::AfterRead();

}

void UReverbEffect::BeforeDelete()
{
	UObject::BeforeDelete();

}

void URig::AfterRead()
{
	UObject::AfterRead();

}

void URig::BeforeDelete()
{
	UObject::BeforeDelete();

}

void USaveGame::AfterRead()
{
	UObject::AfterRead();

}

void USaveGame::BeforeDelete()
{
	UObject::BeforeDelete();

}

void USimpleConstructionScript::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(DefaultSceneRootNode, USCS_Node);
}

void USimpleConstructionScript::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(DefaultSceneRootNode);
}

void UCheckBoxStyleAsset::AfterRead()
{
	UObject::AfterRead();

}

void UCheckBoxStyleAsset::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UPluginCommandlet::AfterRead()
{
	UCommandlet::AfterRead();

}

void UPluginCommandlet::BeforeDelete()
{
	UCommandlet::BeforeDelete();

}

void USmokeTestCommandlet::AfterRead()
{
	UCommandlet::AfterRead();

}

void USmokeTestCommandlet::BeforeDelete()
{
	UCommandlet::BeforeDelete();

}

void UConsole::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(ConsoleTargetPlayer, ULocalPlayer);
	READ_PTR_FULL(DefaultTexture_Black, UTexture2D);
	READ_PTR_FULL(DefaultTexture_White, UTexture2D);
}

void UConsole::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(ConsoleTargetPlayer);
	DELE_PTR_FULL(DefaultTexture_Black);
	DELE_PTR_FULL(DefaultTexture_White);
}

void UMaterialExpressionConstant4Vector::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionConstant4Vector::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionConstantBiasScale::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionConstantBiasScale::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionCosine::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionCosine::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionLowResClouds::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionLowResClouds::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionLumaAvg::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionLumaAvg::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UParticleModuleLocationPrimitiveSphereSlice::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleLocationPrimitiveSphereSlice::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

// Function:
//		Offset -> 0x02D5B360
//		Name   -> Function Engine.CurveLinearColor.GetLinearColorValue
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              InTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UCurveLinearColor::GetLinearColorValue(float InTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CurveLinearColor.GetLinearColorValue");

	UCurveLinearColor_GetLinearColorValue_Params params {};
	params.InTime = InTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UCurveLinearColor::AfterRead()
{
	UCurveBase::AfterRead();

}

void UCurveLinearColor::BeforeDelete()
{
	UCurveBase::BeforeDelete();

}

void UTimelineTemplate::AfterRead()
{
	UObject::AfterRead();

}

void UTimelineTemplate::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02D5CAD0
//		Name   -> Function Engine.CurveVector.GetVectorValue
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              InTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FVector UCurveVector::GetVectorValue(float InTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CurveVector.GetVectorValue");

	UCurveVector_GetVectorValue_Params params {};
	params.InTime = InTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UCurveVector::AfterRead()
{
	UCurveBase::AfterRead();

}

void UCurveVector::BeforeDelete()
{
	UCurveBase::BeforeDelete();

}

void UCurveEdPresetCurve::AfterRead()
{
	UObject::AfterRead();

}

void UCurveEdPresetCurve::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UCurveTable::AfterRead()
{
	UObject::AfterRead();

}

void UCurveTable::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UCustomWidgetDrawerInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UCustomWidgetDrawerInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UMaterialExpressionMaterialFunctionCall::AfterRead()
{
	UMaterialExpression::AfterRead();

	READ_PTR_FULL(MaterialFunction, UMaterialFunction);
}

void UMaterialExpressionMaterialFunctionCall::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

	DELE_PTR_FULL(MaterialFunction);
}

void UMaterialExpressionMax::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionMax::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionMin::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionMin::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionMultiply::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionMultiply::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionNoise::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionNoise::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UAudioSettings::AfterRead()
{
	UDeveloperSettings::AfterRead();

}

void UAudioSettings::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

}

void UAutomaticInstancingSettings::AfterRead()
{
	UDeveloperSettings::AfterRead();

}

void UAutomaticInstancingSettings::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

}

void UUserInterfaceSettings::AfterRead()
{
	UDeveloperSettings::AfterRead();

	READ_PTR_FULL(CustomScalingRuleClassInstance, UClass);
	READ_PTR_FULL(CustomScalingRule, UDPICustomScalingRule);
}

void UUserInterfaceSettings::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

	DELE_PTR_FULL(CustomScalingRuleClassInstance);
	DELE_PTR_FULL(CustomScalingRule);
}

void UStreamingSettings::AfterRead()
{
	UDeveloperSettings::AfterRead();

}

void UStreamingSettings::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

}

void UGarbageCollectionSettings::AfterRead()
{
	UDeveloperSettings::AfterRead();

}

void UGarbageCollectionSettings::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

}

void UNetworkClusteringSettings::AfterRead()
{
	UDeveloperSettings::AfterRead();

}

void UNetworkClusteringSettings::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

}

void UNetworkSettings::AfterRead()
{
	UDeveloperSettings::AfterRead();

}

void UNetworkSettings::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

}

void UPhysicsSettings::AfterRead()
{
	UDeveloperSettings::AfterRead();

}

void UPhysicsSettings::BeforeDelete()
{
	UDeveloperSettings::BeforeDelete();

}

void UDialogueVoice::AfterRead()
{
	UObject::AfterRead();

}

void UDialogueVoice::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UMaterialExpressionCausticTexture::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionCausticTexture::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionCausticTextureCoordinate::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionCausticTextureCoordinate::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UDistributionFloatConstantCurve::AfterRead()
{
	UDistributionFloat::AfterRead();

}

void UDistributionFloatConstantCurve::BeforeDelete()
{
	UDistributionFloat::BeforeDelete();

}

void UDistributionFloatUniform::AfterRead()
{
	UDistributionFloat::AfterRead();

}

void UDistributionFloatUniform::BeforeDelete()
{
	UDistributionFloat::BeforeDelete();

}

void UParticleModuleEventGeneratorGPU::AfterRead()
{
	UParticleModuleEventBase::AfterRead();

}

void UParticleModuleEventGeneratorGPU::BeforeDelete()
{
	UParticleModuleEventBase::BeforeDelete();

}

void UParticleModuleEventReceiverBase::AfterRead()
{
	UParticleModuleEventBase::AfterRead();

}

void UParticleModuleEventReceiverBase::BeforeDelete()
{
	UParticleModuleEventBase::BeforeDelete();

}

void UParticleModuleEventReceiverKillParticles::AfterRead()
{
	UParticleModuleEventReceiverBase::AfterRead();

}

void UParticleModuleEventReceiverKillParticles::BeforeDelete()
{
	UParticleModuleEventReceiverBase::BeforeDelete();

}

void UDestructibleMesh::AfterRead()
{
	USkeletalMesh::AfterRead();

}

void UDestructibleMesh::BeforeDelete()
{
	USkeletalMesh::BeforeDelete();

}

void USlateBrushAsset::AfterRead()
{
	UObject::AfterRead();

}

void USlateBrushAsset::BeforeDelete()
{
	UObject::BeforeDelete();

}

void USoundBase::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(SoundClassObject, USoundClass);
	READ_PTR_FULL(AttenuationSettings, USoundAttenuation);
}

void USoundBase::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(SoundClassObject);
	DELE_PTR_FULL(AttenuationSettings);
}

void UDialogueSoundWaveProxy::AfterRead()
{
	USoundBase::AfterRead();

}

void UDialogueSoundWaveProxy::BeforeDelete()
{
	USoundBase::BeforeDelete();

}

void UComponentDelegateBinding::AfterRead()
{
	UDynamicBlueprintBinding::AfterRead();

}

void UComponentDelegateBinding::BeforeDelete()
{
	UDynamicBlueprintBinding::BeforeDelete();

}

void UInputDelegateBinding::AfterRead()
{
	UDynamicBlueprintBinding::AfterRead();

}

void UInputDelegateBinding::BeforeDelete()
{
	UDynamicBlueprintBinding::BeforeDelete();

}

void UInputActionDelegateBinding::AfterRead()
{
	UInputDelegateBinding::AfterRead();

}

void UInputActionDelegateBinding::BeforeDelete()
{
	UInputDelegateBinding::BeforeDelete();

}

void UInputAxisDelegateBinding::AfterRead()
{
	UInputDelegateBinding::AfterRead();

}

void UInputAxisDelegateBinding::BeforeDelete()
{
	UInputDelegateBinding::BeforeDelete();

}

void UInputAxisKeyDelegateBinding::AfterRead()
{
	UInputDelegateBinding::AfterRead();

}

void UInputAxisKeyDelegateBinding::BeforeDelete()
{
	UInputDelegateBinding::BeforeDelete();

}

void UInputVectorAxisDelegateBinding::AfterRead()
{
	UInputAxisKeyDelegateBinding::AfterRead();

}

void UInputVectorAxisDelegateBinding::BeforeDelete()
{
	UInputAxisKeyDelegateBinding::BeforeDelete();

}

void UInputKeyDelegateBinding::AfterRead()
{
	UInputDelegateBinding::AfterRead();

}

void UInputKeyDelegateBinding::BeforeDelete()
{
	UInputDelegateBinding::BeforeDelete();

}

void UParticleModuleSourceMovement::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleSourceMovement::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UParticleModuleMaterialBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleMaterialBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleMeshMaterial::AfterRead()
{
	UParticleModuleMaterialBase::AfterRead();

}

void UParticleModuleMeshMaterial::BeforeDelete()
{
	UParticleModuleMaterialBase::BeforeDelete();

}

void UParticleModuleOrbitBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleOrbitBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleOrbit::AfterRead()
{
	UParticleModuleOrbitBase::AfterRead();

}

void UParticleModuleOrbit::BeforeDelete()
{
	UParticleModuleOrbitBase::BeforeDelete();

}

void UParticleModuleOrientationBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleOrientationBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleOrientationAxisLock::AfterRead()
{
	UParticleModuleOrientationBase::AfterRead();

}

void UParticleModuleOrientationAxisLock::BeforeDelete()
{
	UParticleModuleOrientationBase::BeforeDelete();

}

void UParticleModuleParameterBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleParameterBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UInputTouchDelegateBinding::AfterRead()
{
	UInputDelegateBinding::AfterRead();

}

void UInputTouchDelegateBinding::BeforeDelete()
{
	UInputDelegateBinding::BeforeDelete();

}

void UInstancedActorDelegateBinding::AfterRead()
{
	UDynamicBlueprintBinding::AfterRead();

}

void UInstancedActorDelegateBinding::BeforeDelete()
{
	UDynamicBlueprintBinding::BeforeDelete();

}

void UEdGraph::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(Schema, UClass);
}

void UEdGraph::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(Schema);
}

void UEdGraphNode_Documentation::AfterRead()
{
	UEdGraphNode::AfterRead();

}

void UEdGraphNode_Documentation::BeforeDelete()
{
	UEdGraphNode::BeforeDelete();

}

void UEdGraphSchema::AfterRead()
{
	UObject::AfterRead();

}

void UEdGraphSchema::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UImportantToggleSettingInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UImportantToggleSettingInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UEndUserSettings::AfterRead()
{
	UObject::AfterRead();

}

void UEndUserSettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UExecutableAnimMetaDataInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UExecutableAnimMetaDataInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UExporter::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(SupportedClass, UClass);
	READ_PTR_FULL(ExportRootScope, UObject);
}

void UExporter::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(SupportedClass);
	DELE_PTR_FULL(ExportRootScope);
}

void URareNetworkProfilerExporter::AfterRead()
{
	UExporter::AfterRead();

}

void URareNetworkProfilerExporter::BeforeDelete()
{
	UExporter::BeforeDelete();

}

void UFFTWaterSettings::AfterRead()
{
	UObject::AfterRead();

}

void UFFTWaterSettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UFontImportOptions::AfterRead()
{
	UObject::AfterRead();

}

void UFontImportOptions::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UMaterialExpressionParameter::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionParameter::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionStaticBoolParameter::AfterRead()
{
	UMaterialExpressionParameter::AfterRead();

}

void UMaterialExpressionStaticBoolParameter::BeforeDelete()
{
	UMaterialExpressionParameter::BeforeDelete();

}

void UMaterialExpressionStaticSwitchParameter::AfterRead()
{
	UMaterialExpressionStaticBoolParameter::AfterRead();

}

void UMaterialExpressionStaticSwitchParameter::BeforeDelete()
{
	UMaterialExpressionStaticBoolParameter::BeforeDelete();

}

void UMaterialExpressionStaticComponentMaskParameter::AfterRead()
{
	UMaterialExpressionParameter::AfterRead();

}

void UMaterialExpressionStaticComponentMaskParameter::BeforeDelete()
{
	UMaterialExpressionParameter::BeforeDelete();

}

void UMaterialExpressionVectorParameter::AfterRead()
{
	UMaterialExpressionParameter::AfterRead();

}

void UMaterialExpressionVectorParameter::BeforeDelete()
{
	UMaterialExpressionParameter::BeforeDelete();

}

void UMaterialExpressionParticleColor::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionParticleColor::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionParticleDirection::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionParticleDirection::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionParticleMacroUV::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionParticleMacroUV::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionParticleMotionBlurFade::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionParticleMotionBlurFade::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionParticlePositionWS::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionParticlePositionWS::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionParticleRadius::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionParticleRadius::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionParticleRelativeTime::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionParticleRelativeTime::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionParticleSize::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionParticleSize::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionParticleSpeed::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionParticleSpeed::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionPerInstanceFadeAmount::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionPerInstanceFadeAmount::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionPerInstanceRandom::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionPerInstanceRandom::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionPixelDepth::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionPixelDepth::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionPixelNormalWS::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionPixelNormalWS::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionPower::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionPower::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionPrecomputedAOMask::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionPrecomputedAOMask::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionQualitySwitch::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionQualitySwitch::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionReflectionVectorWS::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionReflectionVectorWS::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionRotateAboutAxis::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionRotateAboutAxis::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionRotator::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionRotator::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UFont::AfterRead()
{
	UObject::AfterRead();

}

void UFont::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UInterpTrackInst::AfterRead()
{
	UObject::AfterRead();

}

void UInterpTrackInst::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UInterpTrackInstProperty::AfterRead()
{
	UInterpTrackInst::AfterRead();

	READ_PTR_FULL(InterpProperty, UProperty);
	READ_PTR_FULL(PropertyOuterObjectInst, UObject);
}

void UInterpTrackInstProperty::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

	DELE_PTR_FULL(InterpProperty);
	DELE_PTR_FULL(PropertyOuterObjectInst);
}

void UInterpTrackInstColorProp::AfterRead()
{
	UInterpTrackInstProperty::AfterRead();

}

void UInterpTrackInstColorProp::BeforeDelete()
{
	UInterpTrackInstProperty::BeforeDelete();

}

void UInterpTrackInstFloatProp::AfterRead()
{
	UInterpTrackInstProperty::AfterRead();

}

void UInterpTrackInstFloatProp::BeforeDelete()
{
	UInterpTrackInstProperty::BeforeDelete();

}

void UHapticFeedbackEffect::AfterRead()
{
	UObject::AfterRead();

}

void UHapticFeedbackEffect::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UHighLatencySettings::AfterRead()
{
	UObject::AfterRead();

}

void UHighLatencySettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UMaterialExpressionCeil::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionCeil::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionClamp::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionClamp::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionNormalize::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionNormalize::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionObjectBounds::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionObjectBounds::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionObjectOrientation::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionObjectOrientation::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionObjectPositionWS::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionObjectPositionWS::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionObjectRadius::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionObjectRadius::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UParticleModuleBeamNoise::AfterRead()
{
	UParticleModuleBeamBase::AfterRead();

}

void UParticleModuleBeamNoise::BeforeDelete()
{
	UParticleModuleBeamBase::BeforeDelete();

}

void UParticleModuleBeamSource::AfterRead()
{
	UParticleModuleBeamBase::AfterRead();

}

void UParticleModuleBeamSource::BeforeDelete()
{
	UParticleModuleBeamBase::BeforeDelete();

}

void UParticleModuleBeamTarget::AfterRead()
{
	UParticleModuleBeamBase::AfterRead();

}

void UParticleModuleBeamTarget::BeforeDelete()
{
	UParticleModuleBeamBase::BeforeDelete();

}

void UParticleModuleCameraBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleCameraBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleCameraOffset::AfterRead()
{
	UParticleModuleCameraBase::AfterRead();

}

void UParticleModuleCameraOffset::BeforeDelete()
{
	UParticleModuleCameraBase::BeforeDelete();

}

void UParticleModuleCollisionBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleCollisionBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleCollision::AfterRead()
{
	UParticleModuleCollisionBase::AfterRead();

}

void UParticleModuleCollision::BeforeDelete()
{
	UParticleModuleCollisionBase::BeforeDelete();

}

void UParticleModuleCollisionGPU::AfterRead()
{
	UParticleModuleCollisionBase::AfterRead();

}

void UParticleModuleCollisionGPU::BeforeDelete()
{
	UParticleModuleCollisionBase::BeforeDelete();

}

void UHIKCharacterization::AfterRead()
{
	UObject::AfterRead();

}

void UHIKCharacterization::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UMaterialExpressionTextureSampleParameter::AfterRead()
{
	UMaterialExpressionTextureSample::AfterRead();

}

void UMaterialExpressionTextureSampleParameter::BeforeDelete()
{
	UMaterialExpressionTextureSample::BeforeDelete();

}

void UMaterialExpressionTextureSampleParameter2D::AfterRead()
{
	UMaterialExpressionTextureSampleParameter::AfterRead();

}

void UMaterialExpressionTextureSampleParameter2D::BeforeDelete()
{
	UMaterialExpressionTextureSampleParameter::BeforeDelete();

}

void UMaterialExpressionPredicatedTextureSampleParameter2D::AfterRead()
{
	UMaterialExpressionTextureSampleParameter2D::AfterRead();

}

void UMaterialExpressionPredicatedTextureSampleParameter2D::BeforeDelete()
{
	UMaterialExpressionTextureSampleParameter2D::BeforeDelete();

}

void UMaterialExpressionTextureSampleParameterSubUV::AfterRead()
{
	UMaterialExpressionTextureSampleParameter2D::AfterRead();

}

void UMaterialExpressionTextureSampleParameterSubUV::BeforeDelete()
{
	UMaterialExpressionTextureSampleParameter2D::BeforeDelete();

}

void UMaterialExpressionTextureSampleParameterCube::AfterRead()
{
	UMaterialExpressionTextureSampleParameter::AfterRead();

}

void UMaterialExpressionTextureSampleParameterCube::BeforeDelete()
{
	UMaterialExpressionTextureSampleParameter::BeforeDelete();

}

void UMaterialExpressionTextureCoordinate::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionTextureCoordinate::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionTime::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionTime::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionTransform::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionTransform::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionTransformPosition::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionTransformPosition::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionTwoSidedSign::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionTwoSidedSign::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void USoundNodeModulatorContinuous::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeModulatorContinuous::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeOscillator::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeOscillator::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeQualityLevel::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeQualityLevel::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeRandom::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeRandom::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeSoundClass::AfterRead()
{
	USoundNode::AfterRead();

	READ_PTR_FULL(SoundClassOverride, USoundClass);
}

void USoundNodeSoundClass::BeforeDelete()
{
	USoundNode::BeforeDelete();

	DELE_PTR_FULL(SoundClassOverride);
}

void USoundNodeSwitch::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeSwitch::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeWaveParam::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeWaveParam::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void UStaticMeshSocket::AfterRead()
{
	UObject::AfterRead();

}

void UStaticMeshSocket::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UInheritableComponentHandler::AfterRead()
{
	UObject::AfterRead();

}

void UInheritableComponentHandler::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02E50B70
//		Name   -> Function Engine.PlayerInput.SetMouseSensitivity
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		float                                              Sensitivity                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPlayerInput::SetMouseSensitivity(float Sensitivity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetMouseSensitivity");

	UPlayerInput_SetMouseSensitivity_Params params {};
	params.Sensitivity = Sensitivity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50AF0
//		Name   -> Function Engine.PlayerInput.SetForceFeedbackIntensity
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		float                                              Intensity                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPlayerInput::SetForceFeedbackIntensity(float Intensity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetForceFeedbackIntensity");

	UPlayerInput_SetForceFeedbackIntensity_Params params {};
	params.Intensity = Intensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50A20
//		Name   -> Function Engine.PlayerInput.SetCombinedAxisScale
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FName                                       CombinedAxisName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Scale                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPlayerInput::SetCombinedAxisScale(const struct FName& CombinedAxisName, float Scale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetCombinedAxisScale");

	UPlayerInput_SetCombinedAxisScale_Params params {};
	params.CombinedAxisName = CombinedAxisName;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50950
//		Name   -> Function Engine.PlayerInput.SetCombinedAxisNonLinearity
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FName                                       CombinedAxisName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              NonLinearity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPlayerInput::SetCombinedAxisNonLinearity(const struct FName& CombinedAxisName, float NonLinearity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetCombinedAxisNonLinearity");

	UPlayerInput_SetCombinedAxisNonLinearity_Params params {};
	params.CombinedAxisName = CombinedAxisName;
	params.NonLinearity = NonLinearity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50880
//		Name   -> Function Engine.PlayerInput.SetCombinedAxisLowerDeadzone
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FName                                       CombinedAxisName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              LowerDeadzone                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPlayerInput::SetCombinedAxisLowerDeadzone(const struct FName& CombinedAxisName, float LowerDeadzone)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetCombinedAxisLowerDeadzone");

	UPlayerInput_SetCombinedAxisLowerDeadzone_Params params {};
	params.CombinedAxisName = CombinedAxisName;
	params.LowerDeadzone = LowerDeadzone;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E507A0
//		Name   -> Function Engine.PlayerInput.SetBind
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FName                                       BindName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FString                                     Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash)
void UPlayerInput::SetBind(const struct FName& BindName, const struct FString& Command)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetBind");

	UPlayerInput_SetBind_Params params {};
	params.BindName = BindName;
	params.Command = Command;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E501B0
//		Name   -> Function Engine.PlayerInput.InvertMouseAxis
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FName                                       AxisName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPlayerInput::InvertMouseAxis(const struct FName& AxisName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertMouseAxis");

	UPlayerInput_InvertMouseAxis_Params params {};
	params.AxisName = AxisName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50130
//		Name   -> Function Engine.PlayerInput.InvertGamepadAxis
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FName                                       AxisName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPlayerInput::InvertGamepadAxis(const struct FName& AxisName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertGamepadAxis");

	UPlayerInput_InvertGamepadAxis_Params params {};
	params.AxisName = AxisName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E500B0
//		Name   -> Function Engine.PlayerInput.InvertCombinedAxisY
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FName                                       CombinedAxisName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPlayerInput::InvertCombinedAxisY(const struct FName& CombinedAxisName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertCombinedAxisY");

	UPlayerInput_InvertCombinedAxisY_Params params {};
	params.CombinedAxisName = CombinedAxisName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50030
//		Name   -> Function Engine.PlayerInput.InvertCombinedAxisX
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FName                                       CombinedAxisName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UPlayerInput::InvertCombinedAxisX(const struct FName& CombinedAxisName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertCombinedAxisX");

	UPlayerInput_InvertCombinedAxisX_Params params {};
	params.CombinedAxisName = CombinedAxisName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E4FF40
//		Name   -> Function Engine.PlayerInput.InvertAxisKey
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FKey                                        AxisKey                                                    (ConstParm, Parm)
void UPlayerInput::InvertAxisKey(const struct FKey& AxisKey)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertAxisKey");

	UPlayerInput_InvertAxisKey_Params params {};
	params.AxisKey = AxisKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E4F6A0
//		Name   -> Function Engine.PlayerInput.ClearSmoothing
//		Flags  -> (Final, Exec, Native, Public)
void UPlayerInput::ClearSmoothing()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.ClearSmoothing");

	UPlayerInput_ClearSmoothing_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UPlayerInput::AfterRead()
{
	UObject::AfterRead();

}

void UPlayerInput::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UInputSettings::AfterRead()
{
	UObject::AfterRead();

}

void UInputSettings::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UInterpCurveEdSetup::AfterRead()
{
	UObject::AfterRead();

}

void UInterpCurveEdSetup::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UInterpData::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(CurveEdSetup, UInterpCurveEdSetup);
	READ_PTR_FULL(CachedDirectorGroup, UInterpGroupDirector);
}

void UInterpData::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(CurveEdSetup);
	DELE_PTR_FULL(CachedDirectorGroup);
}

void UInterpFilter::AfterRead()
{
	UObject::AfterRead();

}

void UInterpFilter::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UInterpFilter_Classes::AfterRead()
{
	UInterpFilter::AfterRead();

}

void UInterpFilter_Classes::BeforeDelete()
{
	UInterpFilter::BeforeDelete();

}

void UInterpFilter_Custom::AfterRead()
{
	UInterpFilter::AfterRead();

}

void UInterpFilter_Custom::BeforeDelete()
{
	UInterpFilter::BeforeDelete();

}

void UInterpGroup::AfterRead()
{
	UObject::AfterRead();

}

void UInterpGroup::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UInterpGroupCamera::AfterRead()
{
	UInterpGroup::AfterRead();

	READ_PTR_FULL(CameraAnimInst, UCameraAnim);
}

void UInterpGroupCamera::BeforeDelete()
{
	UInterpGroup::BeforeDelete();

	DELE_PTR_FULL(CameraAnimInst);
}

void UInterpGroupDirector::AfterRead()
{
	UInterpGroup::AfterRead();

}

void UInterpGroupDirector::BeforeDelete()
{
	UInterpGroup::BeforeDelete();

}

void UInterpGroupInst::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(Group, UInterpGroup);
	READ_PTR_FULL(GroupActor, AActor);
}

void UInterpGroupInst::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(Group);
	DELE_PTR_FULL(GroupActor);
}

void UInterpGroupInstCamera::AfterRead()
{
	UInterpGroupInst::AfterRead();

}

void UInterpGroupInstCamera::BeforeDelete()
{
	UInterpGroupInst::BeforeDelete();

}

void UInterpGroupInstDirector::AfterRead()
{
	UInterpGroupInst::AfterRead();

}

void UInterpGroupInstDirector::BeforeDelete()
{
	UInterpGroupInst::BeforeDelete();

}

void UInterpTrackBoolProp::AfterRead()
{
	UInterpTrack::AfterRead();

}

void UInterpTrackBoolProp::BeforeDelete()
{
	UInterpTrack::BeforeDelete();

}

void UInterpTrackDirector::AfterRead()
{
	UInterpTrack::AfterRead();

}

void UInterpTrackDirector::BeforeDelete()
{
	UInterpTrack::BeforeDelete();

}

void UInterpTrackEvent::AfterRead()
{
	UInterpTrack::AfterRead();

}

void UInterpTrackEvent::BeforeDelete()
{
	UInterpTrack::BeforeDelete();

}

void UInterpTrackAnimControl::AfterRead()
{
	UInterpTrackFloatBase::AfterRead();

}

void UInterpTrackAnimControl::BeforeDelete()
{
	UInterpTrackFloatBase::BeforeDelete();

}

void UMaterialExpressionCustomVelocity::AfterRead()
{
	UMaterialExpressionCustomOutput::AfterRead();

}

void UMaterialExpressionCustomVelocity::BeforeDelete()
{
	UMaterialExpressionCustomOutput::BeforeDelete();

}

void UMaterialExpressionDDY::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDDY::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionDecalMipmapLevel::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDecalMipmapLevel::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionDepthFade::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDepthFade::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionDistanceToNearestSurface::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDistanceToNearestSurface::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionDivide::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDivide::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionDynamicParameter::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDynamicParameter::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionEyeAdaptation::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionEyeAdaptation::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionFeatureLevelSwitch::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionFeatureLevelSwitch::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionFresnel::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionFresnel::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionFunctionInput::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionFunctionInput::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionGIReplace::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionGIReplace::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionPredicatedTextureSample::AfterRead()
{
	UMaterialExpressionTextureSample::AfterRead();

}

void UMaterialExpressionPredicatedTextureSample::BeforeDelete()
{
	UMaterialExpressionTextureSample::BeforeDelete();

}

void UMaterialExpressionTextureObjectParameter::AfterRead()
{
	UMaterialExpressionTextureSampleParameter::AfterRead();

}

void UMaterialExpressionTextureObjectParameter::BeforeDelete()
{
	UMaterialExpressionTextureSampleParameter::BeforeDelete();

}

void UMaterialExpressionAntialiasedTextureMask::AfterRead()
{
	UMaterialExpressionTextureSampleParameter2D::AfterRead();

}

void UMaterialExpressionAntialiasedTextureMask::BeforeDelete()
{
	UMaterialExpressionTextureSampleParameter2D::BeforeDelete();

}

void UParticleModuleAccelerationOverLifetime::AfterRead()
{
	UParticleModuleAccelerationBase::AfterRead();

}

void UParticleModuleAccelerationOverLifetime::BeforeDelete()
{
	UParticleModuleAccelerationBase::BeforeDelete();

}

void UInterpTrackMoveAxis::AfterRead()
{
	UInterpTrackFloatBase::AfterRead();

}

void UInterpTrackMoveAxis::BeforeDelete()
{
	UInterpTrackFloatBase::BeforeDelete();

}

void UInterpTrackLinearColorBase::AfterRead()
{
	UInterpTrack::AfterRead();

}

void UInterpTrackLinearColorBase::BeforeDelete()
{
	UInterpTrack::BeforeDelete();

}

void UInterpTrackLinearColorProp::AfterRead()
{
	UInterpTrackLinearColorBase::AfterRead();

}

void UInterpTrackLinearColorProp::BeforeDelete()
{
	UInterpTrackLinearColorBase::BeforeDelete();

}

void UMaterialExpressionDDX::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDDX::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UNavCollision::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(AreaClass, UClass);
}

void UNavCollision::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(AreaClass);
}

void UNavigationDataChunk::AfterRead()
{
	UObject::AfterRead();

}

void UNavigationDataChunk::BeforeDelete()
{
	UObject::BeforeDelete();

}

void URecastNavMeshDataChunk::AfterRead()
{
	UNavigationDataChunk::AfterRead();

}

void URecastNavMeshDataChunk::BeforeDelete()
{
	UNavigationDataChunk::BeforeDelete();

}

// Function:
//		Offset -> 0x02E50320
//		Name   -> Function Engine.NavigationPath.IsValid
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavigationPath::IsValid()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.IsValid");

	UNavigationPath_IsValid_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E502F0
//		Name   -> Function Engine.NavigationPath.IsStringPulled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavigationPath::IsStringPulled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.IsStringPulled");

	UNavigationPath_IsStringPulled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E50290
//		Name   -> Function Engine.NavigationPath.IsPartial
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool UNavigationPath::IsPartial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.IsPartial");

	UNavigationPath_IsPartial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E4FE00
//		Name   -> Function Engine.NavigationPath.GetPathLength
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UNavigationPath::GetPathLength()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.GetPathLength");

	UNavigationPath_GetPathLength_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E4FDD0
//		Name   -> Function Engine.NavigationPath.GetPathCost
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UNavigationPath::GetPathCost()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.GetPathCost");

	UNavigationPath_GetPathCost_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E4FD00
//		Name   -> Function Engine.NavigationPath.GetDebugString
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash)
struct FString UNavigationPath::GetDebugString()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.GetDebugString");

	UNavigationPath_GetDebugString_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E4FC80
//		Name   -> Function Engine.NavigationPath.EnableRecalculationOnInvalidation
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TEnumAsByte<Engine_ENavigationOptionFlag>          DoRecalculation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UNavigationPath::EnableRecalculationOnInvalidation(TEnumAsByte<Engine_ENavigationOptionFlag> DoRecalculation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.EnableRecalculationOnInvalidation");

	UNavigationPath_EnableRecalculationOnInvalidation_Params params {};
	params.DoRecalculation = DoRecalculation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E4FBA0
//		Name   -> Function Engine.NavigationPath.EnableDebugDrawing
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		bool                                               bShouldDrawDebugData                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		struct FLinearColor                                PathColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UNavigationPath::EnableDebugDrawing(bool bShouldDrawDebugData, const struct FLinearColor& PathColor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.EnableDebugDrawing");

	UNavigationPath_EnableDebugDrawing_Params params {};
	params.bShouldDrawDebugData = bShouldDrawDebugData;
	params.PathColor = PathColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UNavigationPath::AfterRead()
{
	UObject::AfterRead();

}

void UNavigationPath::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UNavigationPathGenerator::AfterRead()
{
	UInterface::AfterRead();

}

void UNavigationPathGenerator::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void URecastFilter_UseDefaultArea::AfterRead()
{
	UNavigationQueryFilter::AfterRead();

}

void URecastFilter_UseDefaultArea::BeforeDelete()
{
	UNavigationQueryFilter::BeforeDelete();

}

void UNavLinkTrivial::AfterRead()
{
	UNavLinkDefinition::AfterRead();

}

void UNavLinkTrivial::BeforeDelete()
{
	UNavLinkDefinition::BeforeDelete();

}

void UNavNodeInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UNavNodeInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UDemoNetDriver::AfterRead()
{
	UNetDriver::AfterRead();

}

void UDemoNetDriver::BeforeDelete()
{
	UNetDriver::BeforeDelete();

}

void UNetPhysicsInterpolatorInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UNetPhysicsInterpolatorInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UObjectLibrary::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(ObjectBaseClass, UClass);
}

void UObjectLibrary::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(ObjectBaseClass);
}

void UObjectReferencer::AfterRead()
{
	UObject::AfterRead();

}

void UObjectReferencer::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UPackageMapClient::AfterRead()
{
	UPackageMap::AfterRead();

}

void UPackageMapClient::BeforeDelete()
{
	UPackageMap::BeforeDelete();

}

void UParticleEmitter::AfterRead()
{
	UObject::AfterRead();

}

void UParticleEmitter::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UParticleSpriteEmitter::AfterRead()
{
	UParticleEmitter::AfterRead();

}

void UParticleSpriteEmitter::BeforeDelete()
{
	UParticleEmitter::BeforeDelete();

}

void UParticleLODLevel::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(RequiredModule, UParticleModuleRequired);
	READ_PTR_FULL(TypeDataModule, UParticleModule);
	READ_PTR_FULL(SpawnModule, UParticleModuleSpawn);
	READ_PTR_FULL(EventGenerator, UParticleModuleEventGenerator);
}

void UParticleLODLevel::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(RequiredModule);
	DELE_PTR_FULL(TypeDataModule);
	DELE_PTR_FULL(SpawnModule);
	DELE_PTR_FULL(EventGenerator);
}

void UInterpTrackParticleReplay::AfterRead()
{
	UInterpTrack::AfterRead();

}

void UInterpTrackParticleReplay::BeforeDelete()
{
	UInterpTrack::BeforeDelete();

}

void UInterpTrackToggle::AfterRead()
{
	UInterpTrack::AfterRead();

}

void UInterpTrackToggle::BeforeDelete()
{
	UInterpTrack::BeforeDelete();

}

void UInterpTrackVectorBase::AfterRead()
{
	UInterpTrack::AfterRead();

}

void UInterpTrackVectorBase::BeforeDelete()
{
	UInterpTrack::BeforeDelete();

}

void UInterpTrackAudioMaster::AfterRead()
{
	UInterpTrackVectorBase::AfterRead();

}

void UInterpTrackAudioMaster::BeforeDelete()
{
	UInterpTrackVectorBase::BeforeDelete();

}

void UInterpTrackColorProp::AfterRead()
{
	UInterpTrackVectorBase::AfterRead();

}

void UInterpTrackColorProp::BeforeDelete()
{
	UInterpTrackVectorBase::BeforeDelete();

}

void UInterpTrackColorScale::AfterRead()
{
	UInterpTrackVectorBase::AfterRead();

}

void UInterpTrackColorScale::BeforeDelete()
{
	UInterpTrackVectorBase::BeforeDelete();

}

void UInterpTrackSound::AfterRead()
{
	UInterpTrackVectorBase::AfterRead();

}

void UInterpTrackSound::BeforeDelete()
{
	UInterpTrackVectorBase::BeforeDelete();

}

void UInterpTrackVectorMaterialParam::AfterRead()
{
	UInterpTrackVectorBase::AfterRead();

}

void UInterpTrackVectorMaterialParam::BeforeDelete()
{
	UInterpTrackVectorBase::BeforeDelete();

}

void UInterpTrackVectorProp::AfterRead()
{
	UInterpTrackVectorBase::AfterRead();

}

void UInterpTrackVectorProp::BeforeDelete()
{
	UInterpTrackVectorBase::BeforeDelete();

}

void UInterpTrackVisibility::AfterRead()
{
	UInterpTrack::AfterRead();

}

void UInterpTrackVisibility::BeforeDelete()
{
	UInterpTrack::BeforeDelete();

}

void UInterpTrackInstAnimControl::AfterRead()
{
	UInterpTrackInst::AfterRead();

}

void UInterpTrackInstAnimControl::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

}

void UInterpTrackInstAudioMaster::AfterRead()
{
	UInterpTrackInst::AfterRead();

}

void UInterpTrackInstAudioMaster::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

}

void UInterpTrackInstColorScale::AfterRead()
{
	UInterpTrackInst::AfterRead();

}

void UInterpTrackInstColorScale::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

}

void UInterpTrackInstDirector::AfterRead()
{
	UInterpTrackInst::AfterRead();

	READ_PTR_FULL(OldViewTarget, AActor);
}

void UInterpTrackInstDirector::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

	DELE_PTR_FULL(OldViewTarget);
}

void UInterpTrackInstEvent::AfterRead()
{
	UInterpTrackInst::AfterRead();

}

void UInterpTrackInstEvent::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

}

void UInterpTrackInstFade::AfterRead()
{
	UInterpTrackInst::AfterRead();

}

void UInterpTrackInstFade::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

}

void UInterpTrackInstFloatAnimBPParam::AfterRead()
{
	UInterpTrackInst::AfterRead();

	READ_PTR_FULL(AnimScriptInstance, UAnimInstance);
}

void UInterpTrackInstFloatAnimBPParam::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

	DELE_PTR_FULL(AnimScriptInstance);
}

void UInterpTrackInstFloatMaterialParam::AfterRead()
{
	UInterpTrackInst::AfterRead();

	READ_PTR_FULL(InstancedTrack, UInterpTrackFloatMaterialParam);
}

void UInterpTrackInstFloatMaterialParam::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

	DELE_PTR_FULL(InstancedTrack);
}

void UInterpTrackInstFloatParticleParam::AfterRead()
{
	UInterpTrackInst::AfterRead();

}

void UInterpTrackInstFloatParticleParam::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

}

void UInterpTrackInstVectorProp::AfterRead()
{
	UInterpTrackInstProperty::AfterRead();

}

void UInterpTrackInstVectorProp::BeforeDelete()
{
	UInterpTrackInstProperty::BeforeDelete();

}

void UInterpTrackInstSound::AfterRead()
{
	UInterpTrackInst::AfterRead();

	READ_PTR_FULL(PlayAudioComp, UAudioComponent);
}

void UInterpTrackInstSound::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

	DELE_PTR_FULL(PlayAudioComp);
}

void UInterpTrackInstToggle::AfterRead()
{
	UInterpTrackInst::AfterRead();

}

void UInterpTrackInstToggle::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

}

void UInterpTrackInstVectorMaterialParam::AfterRead()
{
	UInterpTrackInst::AfterRead();

	READ_PTR_FULL(InstancedTrack, UInterpTrackVectorMaterialParam);
}

void UInterpTrackInstVectorMaterialParam::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

	DELE_PTR_FULL(InstancedTrack);
}

void UInterpTrackInstVisibility::AfterRead()
{
	UInterpTrackInst::AfterRead();

}

void UInterpTrackInstVisibility::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

}

void UIntSerialization::AfterRead()
{
	UObject::AfterRead();

}

void UIntSerialization::BeforeDelete()
{
	UObject::BeforeDelete();

}

void ULayer::AfterRead()
{
	UObject::AfterRead();

}

void ULayer::BeforeDelete()
{
	UObject::BeforeDelete();

}

void ULevelActorContainer::AfterRead()
{
	UObject::AfterRead();

}

void ULevelActorContainer::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02E502C0
//		Name   -> Function Engine.LevelStreaming.IsStreamingStatePending
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ULevelStreaming::IsStreamingStatePending()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsStreamingStatePending");

	ULevelStreaming_IsStreamingStatePending_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E50260
//		Name   -> Function Engine.LevelStreaming.IsLevelVisible
//		Flags  -> (RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ULevelStreaming::IsLevelVisible()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsLevelVisible");

	ULevelStreaming_IsLevelVisible_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E50230
//		Name   -> Function Engine.LevelStreaming.IsLevelLoaded
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
bool ULevelStreaming::IsLevelLoaded()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsLevelLoaded");

	ULevelStreaming_IsLevelLoaded_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E4FDA0
//		Name   -> Function Engine.LevelStreaming.GetLevelScriptActor
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class ALevelScriptActor*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class ALevelScriptActor* ULevelStreaming::GetLevelScriptActor()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetLevelScriptActor");

	ULevelStreaming_GetLevelScriptActor_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E4F930
//		Name   -> Function Engine.LevelStreaming.CreateInstance
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     UniqueInstanceName                                         (Parm, ZeroConstructor, HasGetValueTypeHash)
//		class ULevelStreaming*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class ULevelStreaming* ULevelStreaming::CreateInstance(const struct FString& UniqueInstanceName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.CreateInstance");

	ULevelStreaming_CreateInstance_Params params {};
	params.UniqueInstanceName = UniqueInstanceName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void ULevelStreaming::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(LoadedLevel, ULevel);
	READ_PTR_FULL(PendingUnloadLevel, ULevel);
}

void ULevelStreaming::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(LoadedLevel);
	DELE_PTR_FULL(PendingUnloadLevel);
}

void ULevelStreamingAlwaysLoaded::AfterRead()
{
	ULevelStreaming::AfterRead();

}

void ULevelStreamingAlwaysLoaded::BeforeDelete()
{
	ULevelStreaming::BeforeDelete();

}

void ULevelStreamingKismet::AfterRead()
{
	ULevelStreaming::AfterRead();

}

void ULevelStreamingKismet::BeforeDelete()
{
	ULevelStreaming::BeforeDelete();

}

void ULevelStreamingPersistent::AfterRead()
{
	ULevelStreaming::AfterRead();

}

void ULevelStreamingPersistent::BeforeDelete()
{
	ULevelStreaming::BeforeDelete();

}

void ULightmappedSurfaceCollection::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(SourceModel, UModel);
}

void ULightmappedSurfaceCollection::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(SourceModel);
}

void UParticleModuleAccelerationConstant::AfterRead()
{
	UParticleModuleAccelerationBase::AfterRead();

}

void UParticleModuleAccelerationConstant::BeforeDelete()
{
	UParticleModuleAccelerationBase::BeforeDelete();

}

void UParticleModuleAccelerationDrag::AfterRead()
{
	UParticleModuleAccelerationBase::AfterRead();

	READ_PTR_FULL(DragCoefficient, UDistributionFloat);
	READ_PTR_FULL(DragOnLocalVelocity, UDistributionFloat);
	READ_PTR_FULL(AdditionalDragCoefficient[0x5], UDistributionFloat);
	READ_PTR_FULL(AdditionalDragOnLocalVelocity[0x5], UDistributionFloat);
}

void UParticleModuleAccelerationDrag::BeforeDelete()
{
	UParticleModuleAccelerationBase::BeforeDelete();

	DELE_PTR_FULL(DragCoefficient);
	DELE_PTR_FULL(DragOnLocalVelocity);
	DELE_PTR_FULL(AdditionalDragCoefficient[0x5]);
	DELE_PTR_FULL(AdditionalDragOnLocalVelocity[0x5]);
}

void UParticleModuleAccelerationDragScaleOverLife::AfterRead()
{
	UParticleModuleAccelerationBase::AfterRead();

	READ_PTR_FULL(DragScale, UDistributionFloat);
	READ_PTR_FULL(DragLocalVelocityScale, UDistributionFloat);
}

void UParticleModuleAccelerationDragScaleOverLife::BeforeDelete()
{
	UParticleModuleAccelerationBase::BeforeDelete();

	DELE_PTR_FULL(DragScale);
	DELE_PTR_FULL(DragLocalVelocityScale);
}

void UParticleModuleAccelerationEmitterPoint::AfterRead()
{
	UParticleModuleAccelerationBase::AfterRead();

}

void UParticleModuleAccelerationEmitterPoint::BeforeDelete()
{
	UParticleModuleAccelerationBase::BeforeDelete();

}

void UParticleModuleEmitterPointVelocity::AfterRead()
{
	UParticleModuleVelocityBase::AfterRead();

}

void UParticleModuleEmitterPointVelocity::BeforeDelete()
{
	UParticleModuleVelocityBase::BeforeDelete();

}

void UInterpTrackInstMove::AfterRead()
{
	UInterpTrackInst::AfterRead();

}

void UInterpTrackInstMove::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

}

void UInterpTrackInstParticleReplay::AfterRead()
{
	UInterpTrackInst::AfterRead();

}

void UInterpTrackInstParticleReplay::BeforeDelete()
{
	UInterpTrackInst::BeforeDelete();

}

void UInterpTrackInstBoolProp::AfterRead()
{
	UInterpTrackInstProperty::AfterRead();

	READ_PTR_FULL(BoolProperty, UBoolProperty);
}

void UInterpTrackInstBoolProp::BeforeDelete()
{
	UInterpTrackInstProperty::BeforeDelete();

	DELE_PTR_FULL(BoolProperty);
}

void UInterpTrackInstLinearColorProp::AfterRead()
{
	UInterpTrackInstProperty::AfterRead();

}

void UInterpTrackInstLinearColorProp::BeforeDelete()
{
	UInterpTrackInstProperty::BeforeDelete();

}

void UParticleModuleSizeOverVelocity::AfterRead()
{
	UParticleModuleSizeBase::AfterRead();

}

void UParticleModuleSizeOverVelocity::BeforeDelete()
{
	UParticleModuleSizeBase::BeforeDelete();

}

void UParticleModuleSizeScale::AfterRead()
{
	UParticleModuleSizeBase::AfterRead();

}

void UParticleModuleSizeScale::BeforeDelete()
{
	UParticleModuleSizeBase::BeforeDelete();

}

void UParticleModuleWindBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleWindBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleWindInfluence::AfterRead()
{
	UParticleModuleWindBase::AfterRead();

}

void UParticleModuleWindInfluence::BeforeDelete()
{
	UParticleModuleWindBase::BeforeDelete();

}

void UParticleModuleEventSendToGame::AfterRead()
{
	UObject::AfterRead();

}

void UParticleModuleEventSendToGame::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UParticleSystemReplay::AfterRead()
{
	UObject::AfterRead();

}

void UParticleSystemReplay::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UDemoPendingNetGame::AfterRead()
{
	UPendingNetGame::AfterRead();

}

void UDemoPendingNetGame::BeforeDelete()
{
	UPendingNetGame::BeforeDelete();

}

void UPhysicalMaterial::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(PhysicalMaterialProperty, UPhysicalMaterialPropertyBase);
}

void UPhysicalMaterial::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(PhysicalMaterialProperty);
}

void UPhysicalMaterialPropertyBase::AfterRead()
{
	UObject::AfterRead();

}

void UPhysicalMaterialPropertyBase::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UPhysicsAsset::AfterRead()
{
	UObject::AfterRead();

}

void UPhysicsAsset::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UPhysicsCollisionHandler::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(DefaultImpactSound, USoundBase);
}

void UPhysicsCollisionHandler::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(DefaultImpactSound);
}

void UMaterialExpressionBreakMaterialAttributes::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionBreakMaterialAttributes::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionBumpOffset::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionBumpOffset::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionCameraPositionWS::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionCameraPositionWS::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionCameraVectorWS::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionCameraVectorWS::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionSceneColor::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionSceneColor::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void USoundCue::AfterRead()
{
	USoundBase::AfterRead();

	READ_PTR_FULL(FirstNode, USoundNode);
}

void USoundCue::BeforeDelete()
{
	USoundBase::BeforeDelete();

	DELE_PTR_FULL(FirstNode);
}

void USoundWave::AfterRead()
{
	USoundBase::AfterRead();

}

void USoundWave::BeforeDelete()
{
	USoundBase::BeforeDelete();

}

void USoundWaveProcedural::AfterRead()
{
	USoundWave::AfterRead();

}

void USoundWaveProcedural::BeforeDelete()
{
	USoundWave::BeforeDelete();

}

void USoundClass::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(ParentClass, USoundClass);
}

void USoundClass::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(ParentClass);
}

void USoundMix::AfterRead()
{
	UObject::AfterRead();

}

void USoundMix::BeforeDelete()
{
	UObject::BeforeDelete();

}

void USoundNodeAssetReferencer::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeAssetReferencer::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeWavePlayer::AfterRead()
{
	USoundNodeAssetReferencer::AfterRead();

	READ_PTR_FULL(SoundWave, USoundWave);
}

void USoundNodeWavePlayer::BeforeDelete()
{
	USoundNodeAssetReferencer::BeforeDelete();

	DELE_PTR_FULL(SoundWave);
}

void USoundNodeAttenuation::AfterRead()
{
	USoundNode::AfterRead();

	READ_PTR_FULL(AttenuationSettings, USoundAttenuation);
}

void USoundNodeAttenuation::BeforeDelete()
{
	USoundNode::BeforeDelete();

	DELE_PTR_FULL(AttenuationSettings);
}

void USoundNodeBranch::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeBranch::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeConcatenator::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeConcatenator::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void USoundNodeDelay::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeDelay::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void UMaterialExpressionCollectionParameter::AfterRead()
{
	UMaterialExpression::AfterRead();

	READ_PTR_FULL(Collection, UMaterialParameterCollection);
}

void UMaterialExpressionCollectionParameter::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

	DELE_PTR_FULL(Collection);
}

void UParticleModuleLocation::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleLocation::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UParticleModuleLocation_Seeded::AfterRead()
{
	UParticleModuleLocation::AfterRead();

}

void UParticleModuleLocation_Seeded::BeforeDelete()
{
	UParticleModuleLocation::BeforeDelete();

}

void UParticleModuleLocationWorldOffset::AfterRead()
{
	UParticleModuleLocation::AfterRead();

}

void UParticleModuleLocationWorldOffset::BeforeDelete()
{
	UParticleModuleLocation::BeforeDelete();

}

void UMaterialExpressionCrossProduct::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionCrossProduct::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionSceneDepth::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionSceneDepth::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionSceneTexelSize::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionSceneTexelSize::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionSceneTexture::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionSceneTexture::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionScreenPosition::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionScreenPosition::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionSine::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionSine::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionSpeedTree::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionSpeedTree::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionSphereMask::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionSphereMask::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionSphericalParticleOpacity::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionSphericalParticleOpacity::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UParticleModuleSizeScaleBySpeed::AfterRead()
{
	UParticleModuleSizeBase::AfterRead();

}

void UParticleModuleSizeScaleBySpeed::BeforeDelete()
{
	UParticleModuleSizeBase::BeforeDelete();

}

void UParticleModuleSpawnBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleSpawnBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleSpawn::AfterRead()
{
	UParticleModuleSpawnBase::AfterRead();

}

void UParticleModuleSpawn::BeforeDelete()
{
	UParticleModuleSpawnBase::BeforeDelete();

}

void UParticleModuleSpawnPerUnit::AfterRead()
{
	UParticleModuleSpawnBase::AfterRead();

}

void UParticleModuleSpawnPerUnit::BeforeDelete()
{
	UParticleModuleSpawnBase::BeforeDelete();

}

void UParticleModuleSpawnPerUnitNew::AfterRead()
{
	UParticleModuleSpawnPerUnit::AfterRead();

}

void UParticleModuleSpawnPerUnitNew::BeforeDelete()
{
	UParticleModuleSpawnPerUnit::BeforeDelete();

}

void UParticleModuleSpawnRepeatPerPoint::AfterRead()
{
	UParticleModuleSpawnBase::AfterRead();

}

void UParticleModuleSpawnRepeatPerPoint::BeforeDelete()
{
	UParticleModuleSpawnBase::BeforeDelete();

}

void UParticleModuleSubUVBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleSubUVBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleSubUV::AfterRead()
{
	UParticleModuleSubUVBase::AfterRead();

}

void UParticleModuleSubUV::BeforeDelete()
{
	UParticleModuleSubUVBase::BeforeDelete();

}

void UParticleModuleSubUVMovie::AfterRead()
{
	UParticleModuleSubUV::AfterRead();

}

void UParticleModuleSubUVMovie::BeforeDelete()
{
	UParticleModuleSubUV::BeforeDelete();

}

void UParticleModuleTrailBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleTrailBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleTrailSource::AfterRead()
{
	UParticleModuleTrailBase::AfterRead();

}

void UParticleModuleTrailSource::BeforeDelete()
{
	UParticleModuleTrailBase::BeforeDelete();

}

void UParticleModuleTypeDataBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleTypeDataBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleTypeDataAnimTrail::AfterRead()
{
	UParticleModuleTypeDataBase::AfterRead();

}

void UParticleModuleTypeDataAnimTrail::BeforeDelete()
{
	UParticleModuleTypeDataBase::BeforeDelete();

}

void UParticleModuleTypeDataBeam2::AfterRead()
{
	UParticleModuleTypeDataBase::AfterRead();

}

void UParticleModuleTypeDataBeam2::BeforeDelete()
{
	UParticleModuleTypeDataBase::BeforeDelete();

}

void UParticleModuleTypeDataGpu::AfterRead()
{
	UParticleModuleTypeDataBase::AfterRead();

}

void UParticleModuleTypeDataGpu::BeforeDelete()
{
	UParticleModuleTypeDataBase::BeforeDelete();

}

void UParticleModuleTypeDataMesh::AfterRead()
{
	UParticleModuleTypeDataBase::AfterRead();

	READ_PTR_FULL(Mesh, UStaticMesh);
}

void UParticleModuleTypeDataMesh::BeforeDelete()
{
	UParticleModuleTypeDataBase::BeforeDelete();

	DELE_PTR_FULL(Mesh);
}

void UParticleModuleTypeDataRibbon::AfterRead()
{
	UParticleModuleTypeDataBase::AfterRead();

}

void UParticleModuleTypeDataRibbon::BeforeDelete()
{
	UParticleModuleTypeDataBase::BeforeDelete();

}

void UParticleModuleVectorFieldBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleVectorFieldBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleVectorFieldGlobal::AfterRead()
{
	UParticleModuleVectorFieldBase::AfterRead();

}

void UParticleModuleVectorFieldGlobal::BeforeDelete()
{
	UParticleModuleVectorFieldBase::BeforeDelete();

}

void UParticleModuleVectorFieldLocal::AfterRead()
{
	UParticleModuleVectorFieldBase::AfterRead();

	READ_PTR_FULL(VectorField, UVectorField);
}

void UParticleModuleVectorFieldLocal::BeforeDelete()
{
	UParticleModuleVectorFieldBase::BeforeDelete();

	DELE_PTR_FULL(VectorField);
}

void UParticleModuleVectorFieldRotation::AfterRead()
{
	UParticleModuleVectorFieldBase::AfterRead();

}

void UParticleModuleVectorFieldRotation::BeforeDelete()
{
	UParticleModuleVectorFieldBase::BeforeDelete();

}

void UParticleModuleVectorFieldRotationRate::AfterRead()
{
	UParticleModuleVectorFieldBase::AfterRead();

}

void UParticleModuleVectorFieldRotationRate::BeforeDelete()
{
	UParticleModuleVectorFieldBase::BeforeDelete();

}

void UParticleModuleVectorFieldScale::AfterRead()
{
	UParticleModuleVectorFieldBase::AfterRead();

	READ_PTR_FULL(VectorFieldScale, UDistributionFloat);
}

void UParticleModuleVectorFieldScale::BeforeDelete()
{
	UParticleModuleVectorFieldBase::BeforeDelete();

	DELE_PTR_FULL(VectorFieldScale);
}

void UParticleModuleVectorFieldScaleOverLife::AfterRead()
{
	UParticleModuleVectorFieldBase::AfterRead();

	READ_PTR_FULL(VectorFieldScaleOverLife, UDistributionFloat);
}

void UParticleModuleVectorFieldScaleOverLife::BeforeDelete()
{
	UParticleModuleVectorFieldBase::BeforeDelete();

	DELE_PTR_FULL(VectorFieldScaleOverLife);
}

void UMaterialExpressionDeriveNormalZ::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDeriveNormalZ::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionDistance::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDistance::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionDistanceCullFade::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDistanceCullFade::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionFmod::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionFmod::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionFontSample::AfterRead()
{
	UMaterialExpression::AfterRead();

	READ_PTR_FULL(Font, UFont);
}

void UMaterialExpressionFontSample::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

	DELE_PTR_FULL(Font);
}

void UMaterialExpressionFontSampleParameter::AfterRead()
{
	UMaterialExpressionFontSample::AfterRead();

}

void UMaterialExpressionFontSampleParameter::BeforeDelete()
{
	UMaterialExpressionFontSample::BeforeDelete();

}

void UMaterialExpressionFunctionOutput::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionFunctionOutput::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionHash::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionHash::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionIf::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionIf::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionIfCondition::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionIfCondition::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionLocalDisturbanceTexture::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionLocalDisturbanceTexture::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionLogarithm2::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionLogarithm2::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionMakeMaterialAttributes::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionMakeMaterialAttributes::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionOneMinus::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionOneMinus::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionPanner::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionPanner::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionScalarParameter::AfterRead()
{
	UMaterialExpressionParameter::AfterRead();

}

void UMaterialExpressionScalarParameter::BeforeDelete()
{
	UMaterialExpressionParameter::BeforeDelete();

}

void UParticleModuleAlignRotationToVelocity::AfterRead()
{
	UParticleModuleRotationBase::AfterRead();

}

void UParticleModuleAlignRotationToVelocity::BeforeDelete()
{
	UParticleModuleRotationBase::BeforeDelete();

}

void UMaterialExpressionDotProduct::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionDotProduct::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionFloor::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionFloor::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UParticleModuleRotation::AfterRead()
{
	UParticleModuleRotationBase::AfterRead();

}

void UParticleModuleRotation::BeforeDelete()
{
	UParticleModuleRotationBase::BeforeDelete();

}

void UParticleModuleRotation_Seeded::AfterRead()
{
	UParticleModuleRotation::AfterRead();

}

void UParticleModuleRotation_Seeded::BeforeDelete()
{
	UParticleModuleRotation::BeforeDelete();

}

void UParticleModuleRotationOverLifetime::AfterRead()
{
	UParticleModuleRotationBase::AfterRead();

}

void UParticleModuleRotationOverLifetime::BeforeDelete()
{
	UParticleModuleRotationBase::BeforeDelete();

}

void UParticleModuleMeshRotationRate_Seeded::AfterRead()
{
	UParticleModuleMeshRotationRate::AfterRead();

}

void UParticleModuleMeshRotationRate_Seeded::BeforeDelete()
{
	UParticleModuleMeshRotationRate::BeforeDelete();

}

void USoundGroups::AfterRead()
{
	UObject::AfterRead();

}

void USoundGroups::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UMaterialExpressionFrac::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionFrac::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void USoundNodeDialoguePlayer::AfterRead()
{
	USoundNode::AfterRead();

}

void USoundNodeDialoguePlayer::BeforeDelete()
{
	USoundNode::BeforeDelete();

}

void UMaterialExpressionSquareRoot::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionSquareRoot::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionStaticBool::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionStaticBool::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UParticleModuleParameterDynamic::AfterRead()
{
	UParticleModuleParameterBase::AfterRead();

}

void UParticleModuleParameterDynamic::BeforeDelete()
{
	UParticleModuleParameterBase::BeforeDelete();

}

void UParticleModuleParameterDynamic_Seeded::AfterRead()
{
	UParticleModuleParameterDynamic::AfterRead();

}

void UParticleModuleParameterDynamic_Seeded::BeforeDelete()
{
	UParticleModuleParameterDynamic::BeforeDelete();

}

void UParticleModuleParametersOverX::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleParametersOverX::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleParametersOverCustom::AfterRead()
{
	UParticleModuleParametersOverX::AfterRead();

}

void UParticleModuleParametersOverCustom::BeforeDelete()
{
	UParticleModuleParametersOverX::BeforeDelete();

}

void UParticleModuleParametersOverVelocity::AfterRead()
{
	UParticleModuleParametersOverX::AfterRead();

}

void UParticleModuleParametersOverVelocity::BeforeDelete()
{
	UParticleModuleParametersOverX::BeforeDelete();

}

void USubUVAnimation::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(SubUVTexture, UTexture2D);
}

void USubUVAnimation::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(SubUVTexture);
}

void UParticleModuleRequired::AfterRead()
{
	UParticleModule::AfterRead();

	READ_PTR_FULL(Material, UMaterialInterface);
	READ_PTR_FULL(CutoutTexture, UTexture2D);
}

void UParticleModuleRequired::BeforeDelete()
{
	UParticleModule::BeforeDelete();

	DELE_PTR_FULL(Material);
	DELE_PTR_FULL(CutoutTexture);
}

void UParticleModuleVelocityConeEmitterPoint::AfterRead()
{
	UParticleModuleVelocityBase::AfterRead();

}

void UParticleModuleVelocityConeEmitterPoint::BeforeDelete()
{
	UParticleModuleVelocityBase::BeforeDelete();

}

void UParticleModuleVelocityInheritParent::AfterRead()
{
	UParticleModuleVelocityBase::AfterRead();

}

void UParticleModuleVelocityInheritParent::BeforeDelete()
{
	UParticleModuleVelocityBase::BeforeDelete();

}

void UParticleModuleVelocityOverLifetime::AfterRead()
{
	UParticleModuleVelocityBase::AfterRead();

}

void UParticleModuleVelocityOverLifetime::BeforeDelete()
{
	UParticleModuleVelocityBase::BeforeDelete();

}

void UMaterialExpressionUnderwaterTranslucencyTexture::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionUnderwaterTranslucencyTexture::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionVertexColor::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionVertexColor::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionVertexID::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionVertexID::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionVertexNormalWS::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionVertexNormalWS::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionViewProperty::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionViewProperty::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionViewSize::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionViewSize::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialExpressionWorldPosition::AfterRead()
{
	UMaterialExpression::AfterRead();

}

void UMaterialExpressionWorldPosition::BeforeDelete()
{
	UMaterialExpression::BeforeDelete();

}

void UMaterialFunction::AfterRead()
{
	UObject::AfterRead();

}

void UMaterialFunction::BeforeDelete()
{
	UObject::BeforeDelete();

}

// Function:
//		Offset -> 0x02E50D80
//		Name   -> Function Engine.MaterialInstanceDynamic.SetVectorParameterValue
//		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UMaterialInstanceDynamic::SetVectorParameterValue(const struct FName& ParameterName, const struct FLinearColor& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetVectorParameterValue");

	UMaterialInstanceDynamic_SetVectorParameterValue_Params params {};
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50CC0
//		Name   -> Function Engine.MaterialInstanceDynamic.SetTextureParameterValue
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UTexture*                                    Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UMaterialInstanceDynamic::SetTextureParameterValue(const struct FName& ParameterName, class UTexture* Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetTextureParameterValue");

	UMaterialInstanceDynamic_SetTextureParameterValue_Params params {};
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50BF0
//		Name   -> Function Engine.MaterialInstanceDynamic.SetScalarParameterValue
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UMaterialInstanceDynamic::SetScalarParameterValue(const struct FName& ParameterName, float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetScalarParameterValue");

	UMaterialInstanceDynamic_SetScalarParameterValue_Params params {};
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50700
//		Name   -> Function Engine.MaterialInstanceDynamic.MergeParameters
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInstance*                           MaterialInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UMaterialInstanceDynamic::MergeParameters(class UMaterialInstance* MaterialInstance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.MergeParameters");

	UMaterialInstanceDynamic_MergeParameters_Params params {};
	params.MaterialInstance = MaterialInstance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E505F0
//		Name   -> Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInstance*                           MaterialA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UMaterialInstance*                           MaterialB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UMaterialInstanceDynamic::K2_InterpolateMaterialInstanceParams(class UMaterialInstance* MaterialA, class UMaterialInstance* MaterialB, float Alpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams");

	UMaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams_Params params {};
	params.MaterialA = MaterialA;
	params.MaterialB = MaterialB;
	params.Alpha = Alpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50550
//		Name   -> Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		struct FLinearColor                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
struct FLinearColor UMaterialInstanceDynamic::K2_GetVectorParameterValue(const struct FName& ParameterName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue");

	UMaterialInstanceDynamic_K2_GetVectorParameterValue_Params params {};
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E504C0
//		Name   -> Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UTexture*                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UTexture* UMaterialInstanceDynamic::K2_GetTextureParameterValue(const struct FName& ParameterName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue");

	UMaterialInstanceDynamic_K2_GetTextureParameterValue_Params params {};
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E50420
//		Name   -> Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
float UMaterialInstanceDynamic::K2_GetScalarParameterValue(const struct FName& ParameterName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue");

	UMaterialInstanceDynamic_K2_GetScalarParameterValue_Params params {};
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E50350
//		Name   -> Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          SourceMaterialToCopyFrom                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               bOverride                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
void UMaterialInstanceDynamic::K2_CopyMaterialInstanceParameters(class UMaterialInterface* SourceMaterialToCopyFrom, bool bOverride)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters");

	UMaterialInstanceDynamic_K2_CopyMaterialInstanceParameters_Params params {};
	params.SourceMaterialToCopyFrom = SourceMaterialToCopyFrom;
	params.bOverride = bOverride;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E4F6C0
//		Name   -> Function Engine.MaterialInstanceDynamic.CopyParameterOverrides
//		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInstance*                           MaterialInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UMaterialInstanceDynamic::CopyParameterOverrides(class UMaterialInstance* MaterialInstance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.CopyParameterOverrides");

	UMaterialInstanceDynamic_CopyParameterOverrides_Params params {};
	params.MaterialInstance = MaterialInstance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UMaterialInstanceDynamic::AfterRead()
{
	UMaterialInstance::AfterRead();

}

void UMaterialInstanceDynamic::BeforeDelete()
{
	UMaterialInstance::BeforeDelete();

}

void UMaterialParameterCollection::AfterRead()
{
	UObject::AfterRead();

}

void UMaterialParameterCollection::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UMaterialParameterCollectionInstance::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(Collection, UMaterialParameterCollection);
	READ_PTR_FULL(World, UWorld);
}

void UMaterialParameterCollectionInstance::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(Collection);
	DELE_PTR_FULL(World);
}

void UMatineeInterface::AfterRead()
{
	UInterface::AfterRead();

}

void UMatineeInterface::BeforeDelete()
{
	UInterface::BeforeDelete();

}

// Function:
//		Offset -> 0x02E4F670
//		Name   -> Function Engine.Texture2D.Blueprint_GetSizeY
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UTexture2D::Blueprint_GetSizeY()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Texture2D.Blueprint_GetSizeY");

	UTexture2D_Blueprint_GetSizeY_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E4F640
//		Name   -> Function Engine.Texture2D.Blueprint_GetSizeX
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
int UTexture2D::Blueprint_GetSizeX()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.Texture2D.Blueprint_GetSizeX");

	UTexture2D_Blueprint_GetSizeX_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UTexture2D::AfterRead()
{
	UTexture::AfterRead();

}

void UTexture2D::BeforeDelete()
{
	UTexture::BeforeDelete();

}

// Function:
//		Offset -> 0x02E50E50
//		Name   -> Function Engine.CanvasRenderTarget2D.UpdateResource
//		Flags  -> (Native, Public, BlueprintCallable)
void UCanvasRenderTarget2D::UpdateResource()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.UpdateResource");

	UCanvasRenderTarget2D_UpdateResource_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E50780
//		Name   -> Function Engine.CanvasRenderTarget2D.Render
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UCanvasRenderTarget2D::Render()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.Render");

	UCanvasRenderTarget2D_Render_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x016629C0
//		Name   -> Function Engine.CanvasRenderTarget2D.ReceiveUpdate
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class UCanvas*                                     Canvas                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCanvasRenderTarget2D::ReceiveUpdate(class UCanvas* Canvas, int Width, int Height)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.ReceiveUpdate");

	UCanvasRenderTarget2D_ReceiveUpdate_Params params {};
	params.Canvas = Canvas;
	params.Width = Width;
	params.Height = Height;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E4FE30
//		Name   -> Function Engine.CanvasRenderTarget2D.GetSize
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Width                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Height                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
void UCanvasRenderTarget2D::GetSize(int* Width, int* Height)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.GetSize");

	UCanvasRenderTarget2D_GetSize_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Width != nullptr)
		*Width = params.Width;
	if (Height != nullptr)
		*Height = params.Height;

}


// Function:
//		Offset -> 0x02E4F740
//		Name   -> Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		class UClass*                                      CanvasRenderTarget2DClass                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
//		int                                                Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECanvasRenderTargetMips>        Mips                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               HDR                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               CreateTextureResource                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UCanvasRenderTarget2D*                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UCanvasRenderTarget2D* UCanvasRenderTarget2D::STATIC_CreateCanvasRenderTarget2D(class UObject* WorldContextObject, class UClass* CanvasRenderTarget2DClass, int Width, int Height, TEnumAsByte<Engine_ECanvasRenderTargetMips> Mips, bool HDR, bool CreateTextureResource)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D");

	UCanvasRenderTarget2D_CreateCanvasRenderTarget2D_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.CanvasRenderTarget2DClass = CanvasRenderTarget2DClass;
	params.Width = Width;
	params.Height = Height;
	params.Mips = Mips;
	params.HDR = HDR;
	params.CreateTextureResource = CreateTextureResource;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UCanvasRenderTarget2D::AfterRead()
{
	UTextureRenderTarget2D::AfterRead();

}

void UCanvasRenderTarget2D::BeforeDelete()
{
	UTextureRenderTarget2D::BeforeDelete();

}

// Function:
//		Offset -> 0x02E50E70
//		Name   -> Function Engine.CompressedCanvasRenderTarget2D.UpdateResource
//		Flags  -> (Native, Public, BlueprintCallable)
void UCompressedCanvasRenderTarget2D::UpdateResource()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.CompressedCanvasRenderTarget2D.UpdateResource");

	UCompressedCanvasRenderTarget2D_UpdateResource_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


void UCompressedCanvasRenderTarget2D::AfterRead()
{
	UTexture2D::AfterRead();

	READ_PTR_FULL(RenderTarget, UCanvasRenderTarget2D);
}

void UCompressedCanvasRenderTarget2D::BeforeDelete()
{
	UTexture2D::BeforeDelete();

	DELE_PTR_FULL(RenderTarget);
}

// Function:
//		Offset -> 0x02E50E90
//		Name   -> Function Engine.MaybeCompressedCanvasRenderTarget2D.UpdateResource
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UMaybeCompressedCanvasRenderTarget2D::UpdateResource()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaybeCompressedCanvasRenderTarget2D.UpdateResource");

	UMaybeCompressedCanvasRenderTarget2D_UpdateResource_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x02E4FF10
//		Name   -> Function Engine.MaybeCompressedCanvasRenderTarget2D.GetTexture
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UTexture*                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UTexture* UMaybeCompressedCanvasRenderTarget2D::GetTexture()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaybeCompressedCanvasRenderTarget2D.GetTexture");

	UMaybeCompressedCanvasRenderTarget2D_GetTexture_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x02E4F9F0
//		Name   -> Function Engine.MaybeCompressedCanvasRenderTarget2D.CreateMaybeCompressedCanvasRenderTarget2D
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		int                                                Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		TEnumAsByte<Engine_ECanvasRenderTargetMips>        Mips                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
//		bool                                               HDR                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		bool                                               CreateTextureResource                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
//		class UMaybeCompressedCanvasRenderTarget2D*        ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
class UMaybeCompressedCanvasRenderTarget2D* UMaybeCompressedCanvasRenderTarget2D::STATIC_CreateMaybeCompressedCanvasRenderTarget2D(class UObject* WorldContextObject, int Width, int Height, TEnumAsByte<Engine_ECanvasRenderTargetMips> Mips, bool HDR, bool CreateTextureResource)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Engine.MaybeCompressedCanvasRenderTarget2D.CreateMaybeCompressedCanvasRenderTarget2D");

	UMaybeCompressedCanvasRenderTarget2D_CreateMaybeCompressedCanvasRenderTarget2D_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Width = Width;
	params.Height = Height;
	params.Mips = Mips;
	params.HDR = HDR;
	params.CreateTextureResource = CreateTextureResource;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


void UMaybeCompressedCanvasRenderTarget2D::AfterRead()
{
	UObject::AfterRead();

	READ_PTR_FULL(UncompressedRenderTarget, UCanvasRenderTarget2D);
	READ_PTR_FULL(CompressedRenderTarget, UCompressedCanvasRenderTarget2D);
}

void UMaybeCompressedCanvasRenderTarget2D::BeforeDelete()
{
	UObject::BeforeDelete();

	DELE_PTR_FULL(UncompressedRenderTarget);
	DELE_PTR_FULL(CompressedRenderTarget);
}

void UNavArea_Default::AfterRead()
{
	UNavArea::AfterRead();

}

void UNavArea_Default::BeforeDelete()
{
	UNavArea::BeforeDelete();

}

void UNavArea_LowHeight::AfterRead()
{
	UNavArea::AfterRead();

}

void UNavArea_LowHeight::BeforeDelete()
{
	UNavArea::BeforeDelete();

}

void UNavArea_Null::AfterRead()
{
	UNavArea::AfterRead();

}

void UNavArea_Null::BeforeDelete()
{
	UNavArea::BeforeDelete();

}

void UNavArea_Obstacle::AfterRead()
{
	UNavArea::AfterRead();

}

void UNavArea_Obstacle::BeforeDelete()
{
	UNavArea::BeforeDelete();

}

void UNavAreaMeta::AfterRead()
{
	UNavArea::AfterRead();

}

void UNavAreaMeta::BeforeDelete()
{
	UNavArea::BeforeDelete();

}

void UNavAreaMeta_SwitchByAgent::AfterRead()
{
	UNavAreaMeta::AfterRead();

	READ_PTR_FULL(Agent0Area, UClass);
	READ_PTR_FULL(Agent1Area, UClass);
	READ_PTR_FULL(Agent2Area, UClass);
	READ_PTR_FULL(Agent3Area, UClass);
	READ_PTR_FULL(Agent4Area, UClass);
	READ_PTR_FULL(Agent5Area, UClass);
	READ_PTR_FULL(Agent6Area, UClass);
	READ_PTR_FULL(Agent7Area, UClass);
	READ_PTR_FULL(Agent8Area, UClass);
	READ_PTR_FULL(Agent9Area, UClass);
	READ_PTR_FULL(Agent10Area, UClass);
	READ_PTR_FULL(Agent11Area, UClass);
	READ_PTR_FULL(Agent12Area, UClass);
	READ_PTR_FULL(Agent13Area, UClass);
	READ_PTR_FULL(Agent14Area, UClass);
	READ_PTR_FULL(Agent15Area, UClass);
}

void UNavAreaMeta_SwitchByAgent::BeforeDelete()
{
	UNavAreaMeta::BeforeDelete();

	DELE_PTR_FULL(Agent0Area);
	DELE_PTR_FULL(Agent1Area);
	DELE_PTR_FULL(Agent2Area);
	DELE_PTR_FULL(Agent3Area);
	DELE_PTR_FULL(Agent4Area);
	DELE_PTR_FULL(Agent5Area);
	DELE_PTR_FULL(Agent6Area);
	DELE_PTR_FULL(Agent7Area);
	DELE_PTR_FULL(Agent8Area);
	DELE_PTR_FULL(Agent9Area);
	DELE_PTR_FULL(Agent10Area);
	DELE_PTR_FULL(Agent11Area);
	DELE_PTR_FULL(Agent12Area);
	DELE_PTR_FULL(Agent13Area);
	DELE_PTR_FULL(Agent14Area);
	DELE_PTR_FULL(Agent15Area);
}

void UParticleModuleEventReceiverSpawn::AfterRead()
{
	UParticleModuleEventReceiverBase::AfterRead();

}

void UParticleModuleEventReceiverSpawn::BeforeDelete()
{
	UParticleModuleEventReceiverBase::BeforeDelete();

}

void UParticleModuleKillBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleKillBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleKillBox::AfterRead()
{
	UParticleModuleKillBase::AfterRead();

}

void UParticleModuleKillBox::BeforeDelete()
{
	UParticleModuleKillBase::BeforeDelete();

}

void UParticleModuleKillHeight::AfterRead()
{
	UParticleModuleKillBase::AfterRead();

}

void UParticleModuleKillHeight::BeforeDelete()
{
	UParticleModuleKillBase::BeforeDelete();

}

void UParticleModuleKillOnFFTWater::AfterRead()
{
	UParticleModuleKillBase::AfterRead();

}

void UParticleModuleKillOnFFTWater::BeforeDelete()
{
	UParticleModuleKillBase::BeforeDelete();

}

void UParticleModuleLifetimeBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleLifetimeBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleLifetime::AfterRead()
{
	UParticleModuleLifetimeBase::AfterRead();

}

void UParticleModuleLifetime::BeforeDelete()
{
	UParticleModuleLifetimeBase::BeforeDelete();

}

void UParticleModuleLifetime_Seeded::AfterRead()
{
	UParticleModuleLifetime::AfterRead();

}

void UParticleModuleLifetime_Seeded::BeforeDelete()
{
	UParticleModuleLifetime::BeforeDelete();

}

void UParticleModuleLightBase::AfterRead()
{
	UParticleModule::AfterRead();

}

void UParticleModuleLightBase::BeforeDelete()
{
	UParticleModule::BeforeDelete();

}

void UParticleModuleLight::AfterRead()
{
	UParticleModuleLightBase::AfterRead();

}

void UParticleModuleLight::BeforeDelete()
{
	UParticleModuleLightBase::BeforeDelete();

}

void UParticleModuleLight_Seeded::AfterRead()
{
	UParticleModuleLight::AfterRead();

}

void UParticleModuleLight_Seeded::BeforeDelete()
{
	UParticleModuleLight::BeforeDelete();

}

void UParticleModuleLocationWorldOffset_Seeded::AfterRead()
{
	UParticleModuleLocationWorldOffset::AfterRead();

}

void UParticleModuleLocationWorldOffset_Seeded::BeforeDelete()
{
	UParticleModuleLocationWorldOffset::BeforeDelete();

}

void UParticleModuleLocationBoneSocket::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleLocationBoneSocket::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UParticleModuleLocationDirect::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleLocationDirect::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UParticleModuleLocationEmitter::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleLocationEmitter::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UParticleModuleLocationEmitterDirect::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleLocationEmitterDirect::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UParticleModuleLocationGPU::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModuleLocationGPU::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UParticleModulePivotOffset::AfterRead()
{
	UParticleModuleLocationBase::AfterRead();

}

void UParticleModulePivotOffset::BeforeDelete()
{
	UParticleModuleLocationBase::BeforeDelete();

}

void UParticleModuleVelocityCone::AfterRead()
{
	UParticleModuleVelocityBase::AfterRead();

}

void UParticleModuleVelocityCone::BeforeDelete()
{
	UParticleModuleVelocityBase::BeforeDelete();

}

void UParticleModuleMeshRotationRateMultiplyLife::AfterRead()
{
	UParticleModuleRotationRateBase::AfterRead();

}

void UParticleModuleMeshRotationRateMultiplyLife::BeforeDelete()
{
	UParticleModuleRotationRateBase::BeforeDelete();

}

void UParticleModuleMeshRotationRateOverLife::AfterRead()
{
	UParticleModuleRotationRateBase::AfterRead();

}

void UParticleModuleMeshRotationRateOverLife::BeforeDelete()
{
	UParticleModuleRotationRateBase::BeforeDelete();

}

void UParticleModuleRotationRateMultiplyLife::AfterRead()
{
	UParticleModuleRotationRateBase::AfterRead();

}

void UParticleModuleRotationRateMultiplyLife::BeforeDelete()
{
	UParticleModuleRotationRateBase::BeforeDelete();

}

void USubsurfaceProfile::AfterRead()
{
	UObject::AfterRead();

}

void USubsurfaceProfile::BeforeDelete()
{
	UObject::BeforeDelete();

}

void UTestInterfaceAlternative::AfterRead()
{
	UInterface::AfterRead();

}

void UTestInterfaceAlternative::BeforeDelete()
{
	UInterface::BeforeDelete();

}

void UTextPropertyTestObject::AfterRead()
{
	UObject::AfterRead();

}

void UTextPropertyTestObject::BeforeDelete()
{
	UObject::BeforeDelete();

}

void ULightMapTexture2D::AfterRead()
{
	UTexture2D::AfterRead();

}

void ULightMapTexture2D::BeforeDelete()
{
	UTexture2D::BeforeDelete();

}

void UShadowMapTexture2D::AfterRead()
{
	UTexture2D::AfterRead();

}

void UShadowMapTexture2D::BeforeDelete()
{
	UTexture2D::BeforeDelete();

}

void UTextureLightProfile::AfterRead()
{
	UTexture2D::AfterRead();

}

void UTextureLightProfile::BeforeDelete()
{
	UTexture2D::BeforeDelete();

}

void UTexture2DDynamic::AfterRead()
{
	UTexture::AfterRead();

}

void UTexture2DDynamic::BeforeDelete()
{
	UTexture::BeforeDelete();

}

void UTextureCube::AfterRead()
{
	UTexture::AfterRead();

}

void UTextureCube::BeforeDelete()
{
	UTexture::BeforeDelete();

}

void UTextureRenderTargetCube::AfterRead()
{
	UTextureRenderTarget::AfterRead();

}

void UTextureRenderTargetCube::BeforeDelete()
{
	UTextureRenderTarget::BeforeDelete();

}

void UThumbnailInfo::AfterRead()
{
	UObject::AfterRead();

}

void UThumbnailInfo::BeforeDelete()
{
	UObject::BeforeDelete();

}

}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
